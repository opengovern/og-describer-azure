// Code is generated by go generate. DO NOT EDIT.
package opengovernance

import (
	"context"
	azure "github.com/opengovern/og-describer-azure/discovery/provider"
	essdk "github.com/opengovern/og-util/pkg/opengovernance-es-sdk"
	steampipesdk "github.com/opengovern/og-util/pkg/steampipe"
	"github.com/turbot/steampipe-plugin-sdk/v5/plugin"
	"runtime"
)

type Client struct {
	essdk.Client
}

// ==========================  START: APIManagement =============================

type APIManagement struct {
	ResourceID      string                         `json:"resource_id"`
	PlatformID      string                         `json:"platform_id"`
	Description     azure.APIManagementDescription `json:"Description"`
	Metadata        azure.Metadata                 `json:"metadata"`
	DescribedBy     string                         `json:"described_by"`
	ResourceType    string                         `json:"resource_type"`
	IntegrationType string                         `json:"integration_type"`
	IntegrationID   string                         `json:"integration_id"`
}

type APIManagementHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  APIManagement `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type APIManagementHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []APIManagementHit `json:"hits"`
}

type APIManagementSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  APIManagementHits `json:"hits"`
}

type APIManagementPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAPIManagementPaginator(filters []essdk.BoolFilter, limit *int64) (APIManagementPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_apimanagement_service", filters, limit)
	if err != nil {
		return APIManagementPaginator{}, err
	}

	p := APIManagementPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p APIManagementPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p APIManagementPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p APIManagementPaginator) NextPage(ctx context.Context) ([]APIManagement, error) {
	var response APIManagementSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []APIManagement
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAPIManagementFilters = map[string]string{
	"additional_locations":              "Description.APIManagement.Properties.AdditionalLocations",
	"api_version_constraint":            "Description.APIManagement.Properties.APIVersionConstraint",
	"certificates":                      "Description.APIManagement.Properties.Certificates",
	"custom_properties":                 "Description.APIManagement.Properties.CustomProperties",
	"developer_portal_url":              "Description.APIManagement.properties.developerPortalUrl",
	"diagnostic_settings":               "Description.DiagnosticSettingsResources",
	"disable_gateway":                   "Description.APIManagement.properties.disableGateway",
	"enable_client_certificate":         "Description.APIManagement.properties.enableClientCertificate",
	"etag":                              "Description.APIManagement.etag",
	"gateway_regional_url":              "Description.APIManagement.properties.gatewayRegionalUrl",
	"gateway_url":                       "Description.APIManagement.properties.gatewayUrl",
	"host_name_configurations":          "Description.APIManagement.Properties.HostnameConfigurations",
	"id":                                "Description.APIManagement.id",
	"identity_principal_id":             "Description.APIManagement.identity.principalId",
	"identity_tenant_id":                "Description.APIManagement.identity.tenantId",
	"identity_type":                     "Description.APIManagement.identity.type",
	"identity_user_assigned_identities": "Description.APIManagement.Identity.UserAssignedIdentities",
	"management_api_url":                "Description.APIManagement.properties.managementApiUrl",
	"name":                              "Description.APIManagement.name",
	"notification_sender_email":         "Description.APIManagement.properties.notificationSenderEmail",
	"platform_integration_id":           "IntegrationID",
	"portal_url":                        "Description.APIManagement.properties.portalUrl",
	"private_ip_addresses":              "Description.APIManagement.Properties.PrivateIPAddresses",
	"provisioning_state":                "Description.APIManagement.properties.provisioningState",
	"public_ip_addresses":               "Description.APIManagement.Properties.PublicIPAddresses",
	"publisher_email":                   "Description.APIManagement.properties.publisherEmail",
	"publisher_name":                    "Description.APIManagement.properties.publisherName",
	"resource_group":                    "Description.ResourceGroup",
	"restore":                           "Description.APIManagement.properties.restore",
	"scm_url":                           "Description.APIManagement.properties.scmUrl",
	"sku_capacity":                      "Description.APIManagement.sku.capacity",
	"sku_name":                          "Description.APIManagement.sku.name",
	"tags":                              "Description.APIManagement.Tags",
	"target_provisioning_state":         "Description.APIManagement.properties.targetProvisioningState",
	"title":                             "Description.APIManagement.name",
	"type":                              "Description.APIManagement.type",
	"virtual_network_configuration_id":  "Description.APIManagement.properties.virtualNetworkConfiguration.vnetid",
	"virtual_network_configuration_subnet_name":        "Description.APIManagement.properties.virtualNetworkConfiguration.subnetname",
	"virtual_network_configuration_subnet_resource_id": "Description.APIManagement.properties.virtualNetworkConfiguration.subnetResourceId",
	"virtual_network_type":                             "Description.APIManagement.properties.virtualNetworkType",
	"zones":                                            "Description.APIManagement.Zones",
}

func ListAPIManagement(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAPIManagement")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAPIManagement NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAPIManagement NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAPIManagement GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAPIManagement GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAPIManagement GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAPIManagementPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAPIManagementFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAPIManagement NewAPIManagementPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAPIManagement paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAPIManagementFilters = map[string]string{
	"additional_locations":              "Description.APIManagement.Properties.AdditionalLocations",
	"api_version_constraint":            "Description.APIManagement.Properties.APIVersionConstraint",
	"certificates":                      "Description.APIManagement.Properties.Certificates",
	"custom_properties":                 "Description.APIManagement.Properties.CustomProperties",
	"developer_portal_url":              "Description.APIManagement.properties.developerPortalUrl",
	"diagnostic_settings":               "Description.DiagnosticSettingsResources",
	"disable_gateway":                   "Description.APIManagement.properties.disableGateway",
	"enable_client_certificate":         "Description.APIManagement.properties.enableClientCertificate",
	"etag":                              "Description.APIManagement.etag",
	"gateway_regional_url":              "Description.APIManagement.properties.gatewayRegionalUrl",
	"gateway_url":                       "Description.APIManagement.properties.gatewayUrl",
	"host_name_configurations":          "Description.APIManagement.Properties.HostnameConfigurations",
	"id":                                "Description.APIManagement.id",
	"identity_principal_id":             "Description.APIManagement.identity.principalId",
	"identity_tenant_id":                "Description.APIManagement.identity.tenantId",
	"identity_type":                     "Description.APIManagement.identity.type",
	"identity_user_assigned_identities": "Description.APIManagement.Identity.UserAssignedIdentities",
	"management_api_url":                "Description.APIManagement.properties.managementApiUrl",
	"name":                              "description.APIManagement.name",
	"notification_sender_email":         "Description.APIManagement.properties.notificationSenderEmail",
	"platform_integration_id":           "IntegrationID",
	"portal_url":                        "Description.APIManagement.properties.portalUrl",
	"private_ip_addresses":              "Description.APIManagement.Properties.PrivateIPAddresses",
	"provisioning_state":                "Description.APIManagement.properties.provisioningState",
	"public_ip_addresses":               "Description.APIManagement.Properties.PublicIPAddresses",
	"publisher_email":                   "Description.APIManagement.properties.publisherEmail",
	"publisher_name":                    "Description.APIManagement.properties.publisherName",
	"resource_group":                    "description.ResourceGroup",
	"restore":                           "Description.APIManagement.properties.restore",
	"scm_url":                           "Description.APIManagement.properties.scmUrl",
	"sku_capacity":                      "Description.APIManagement.sku.capacity",
	"sku_name":                          "Description.APIManagement.sku.name",
	"tags":                              "Description.APIManagement.Tags",
	"target_provisioning_state":         "Description.APIManagement.properties.targetProvisioningState",
	"title":                             "Description.APIManagement.name",
	"type":                              "Description.APIManagement.type",
	"virtual_network_configuration_id":  "Description.APIManagement.properties.virtualNetworkConfiguration.vnetid",
	"virtual_network_configuration_subnet_name":        "Description.APIManagement.properties.virtualNetworkConfiguration.subnetname",
	"virtual_network_configuration_subnet_resource_id": "Description.APIManagement.properties.virtualNetworkConfiguration.subnetResourceId",
	"virtual_network_type":                             "Description.APIManagement.properties.virtualNetworkType",
	"zones":                                            "Description.APIManagement.Zones",
}

func GetAPIManagement(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAPIManagement")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAPIManagementPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAPIManagementFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: APIManagement =============================

// ==========================  START: APIManagementBackend =============================

type APIManagementBackend struct {
	ResourceID      string                                `json:"resource_id"`
	PlatformID      string                                `json:"platform_id"`
	Description     azure.APIManagementBackendDescription `json:"Description"`
	Metadata        azure.Metadata                        `json:"metadata"`
	DescribedBy     string                                `json:"described_by"`
	ResourceType    string                                `json:"resource_type"`
	IntegrationType string                                `json:"integration_type"`
	IntegrationID   string                                `json:"integration_id"`
}

type APIManagementBackendHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  APIManagementBackend `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type APIManagementBackendHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []APIManagementBackendHit `json:"hits"`
}

type APIManagementBackendSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  APIManagementBackendHits `json:"hits"`
}

type APIManagementBackendPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAPIManagementBackendPaginator(filters []essdk.BoolFilter, limit *int64) (APIManagementBackendPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_apimanagement_backend", filters, limit)
	if err != nil {
		return APIManagementBackendPaginator{}, err
	}

	p := APIManagementBackendPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p APIManagementBackendPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p APIManagementBackendPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p APIManagementBackendPaginator) NextPage(ctx context.Context) ([]APIManagementBackend, error) {
	var response APIManagementBackendSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []APIManagementBackend
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAPIManagementBackendFilters = map[string]string{
	"credentials":    "Description.APIManagementBackend.Properties.Credentials",
	"description":    "Description.APIManagementBackend.properties.description",
	"id":             "Description.APIManagementBackend.id",
	"name":           "Description.APIManagementBackend.name",
	"properties":     "Description.APIManagementBackend.Properties.Properties",
	"protocol":       "Description.APIManagementBackend.properties.protocol",
	"proxy":          "Description.APIManagementBackend.Properties.Proxy",
	"resource_group": "Description.APIManagementBackend.ResourceGroup",
	"resource_id":    "Description.APIManagementBackend.properties.resourceId",
	"service_name":   "Description.ServiceName",
	"subscription":   "Description.APIManagementBackend.Properties.Subscription",
	"title":          "Description.APIManagementBackend.properties.title",
	"tls":            "Description.APIManagementBackend.Properties.TLS",
	"type":           "Description.APIManagementBackend.type",
	"url":            "Description.APIManagementBackend.properties.url",
}

func ListAPIManagementBackend(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAPIManagementBackend")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAPIManagementBackend NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAPIManagementBackend NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAPIManagementBackend GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAPIManagementBackend GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAPIManagementBackend GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAPIManagementBackendPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAPIManagementBackendFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAPIManagementBackend NewAPIManagementBackendPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAPIManagementBackend paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAPIManagementBackendFilters = map[string]string{
	"credentials":    "Description.APIManagementBackend.Properties.Credentials",
	"description":    "Description.APIManagementBackend.properties.description",
	"id":             "Description.APIManagementBackend.id",
	"name":           "Description.APIManagementBackend.name",
	"properties":     "Description.APIManagementBackend.Properties.Properties",
	"protocol":       "Description.APIManagementBackend.properties.protocol",
	"proxy":          "Description.APIManagementBackend.Properties.Proxy",
	"resource_group": "Description.APIManagementBackend.ResourceGroup",
	"resource_id":    "Description.APIManagementBackend.properties.resourceId",
	"service_name":   "Description.ServiceName",
	"subscription":   "Description.APIManagementBackend.Properties.Subscription",
	"title":          "Description.APIManagementBackend.properties.title",
	"tls":            "Description.APIManagementBackend.Properties.TLS",
	"type":           "Description.APIManagementBackend.type",
	"url":            "Description.APIManagementBackend.properties.url",
}

func GetAPIManagementBackend(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAPIManagementBackend")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAPIManagementBackendPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAPIManagementBackendFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: APIManagementBackend =============================

// ==========================  START: AutomationAccounts =============================

type AutomationAccounts struct {
	ResourceID      string                              `json:"resource_id"`
	PlatformID      string                              `json:"platform_id"`
	Description     azure.AutomationAccountsDescription `json:"Description"`
	Metadata        azure.Metadata                      `json:"metadata"`
	DescribedBy     string                              `json:"described_by"`
	ResourceType    string                              `json:"resource_type"`
	IntegrationType string                              `json:"integration_type"`
	IntegrationID   string                              `json:"integration_id"`
}

type AutomationAccountsHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  AutomationAccounts `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type AutomationAccountsHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []AutomationAccountsHit `json:"hits"`
}

type AutomationAccountsSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  AutomationAccountsHits `json:"hits"`
}

type AutomationAccountsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAutomationAccountsPaginator(filters []essdk.BoolFilter, limit *int64) (AutomationAccountsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_automation_automationaccounts", filters, limit)
	if err != nil {
		return AutomationAccountsPaginator{}, err
	}

	p := AutomationAccountsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AutomationAccountsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AutomationAccountsPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AutomationAccountsPaginator) NextPage(ctx context.Context) ([]AutomationAccounts, error) {
	var response AutomationAccountsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AutomationAccounts
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAutomationAccountsFilters = map[string]string{
	"creation_time":           "Description.Automation.Properties.CreationTime",
	"description":             "Description.Automation.properties.description",
	"etag":                    "Description.Automation.etag",
	"id":                      "Description.Automation.id",
	"last_modified_by":        "Description.Automation.properties.lastModifiedBy",
	"last_modified_time":      "Description.Automation.Properties.LastModifiedTime",
	"name":                    "Description.Automation.name",
	"platform_integration_id": "IntegrationID",
	"sku_capacity":            "Description.Automation.properties.sku.capacity",
	"sku_family":              "Description.Automation.properties.sku.family",
	"sku_name":                "Description.Automation.properties.sku.name",
	"state":                   "Description.Automation.properties.state",
	"subscription":            "Description.Automation.Properties.Subscription",
	"tags":                    "Description.Automation.Tags",
	"title":                   "Description.Automation.name",
	"type":                    "Description.Automation.type",
}

func ListAutomationAccounts(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAutomationAccounts")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutomationAccounts NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutomationAccounts NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutomationAccounts GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutomationAccounts GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutomationAccounts GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAutomationAccountsPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAutomationAccountsFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutomationAccounts NewAutomationAccountsPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAutomationAccounts paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAutomationAccountsFilters = map[string]string{
	"creation_time":           "Description.Automation.Properties.CreationTime",
	"description":             "Description.Automation.properties.description",
	"etag":                    "Description.Automation.etag",
	"id":                      "Description.Automation.id",
	"last_modified_by":        "Description.Automation.properties.lastModifiedBy",
	"last_modified_time":      "Description.Automation.Properties.LastModifiedTime",
	"name":                    "Description.Automation.name",
	"platform_integration_id": "IntegrationID",
	"sku_capacity":            "Description.Automation.properties.sku.capacity",
	"sku_family":              "Description.Automation.properties.sku.family",
	"sku_name":                "Description.Automation.properties.sku.name",
	"state":                   "Description.Automation.properties.state",
	"subscription":            "Description.Automation.Properties.Subscription",
	"tags":                    "Description.Automation.Tags",
	"title":                   "Description.Automation.name",
	"type":                    "Description.Automation.type",
}

func GetAutomationAccounts(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAutomationAccounts")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAutomationAccountsPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAutomationAccountsFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AutomationAccounts =============================

// ==========================  START: AutomationVariables =============================

type AutomationVariables struct {
	ResourceID      string                               `json:"resource_id"`
	PlatformID      string                               `json:"platform_id"`
	Description     azure.AutomationVariablesDescription `json:"Description"`
	Metadata        azure.Metadata                       `json:"metadata"`
	DescribedBy     string                               `json:"described_by"`
	ResourceType    string                               `json:"resource_type"`
	IntegrationType string                               `json:"integration_type"`
	IntegrationID   string                               `json:"integration_id"`
}

type AutomationVariablesHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  AutomationVariables `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type AutomationVariablesHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []AutomationVariablesHit `json:"hits"`
}

type AutomationVariablesSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  AutomationVariablesHits `json:"hits"`
}

type AutomationVariablesPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAutomationVariablesPaginator(filters []essdk.BoolFilter, limit *int64) (AutomationVariablesPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_automation_automationaccounts_variables", filters, limit)
	if err != nil {
		return AutomationVariablesPaginator{}, err
	}

	p := AutomationVariablesPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AutomationVariablesPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AutomationVariablesPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AutomationVariablesPaginator) NextPage(ctx context.Context) ([]AutomationVariables, error) {
	var response AutomationVariablesSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AutomationVariables
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAutomationVariablesFilters = map[string]string{
	"account_name":            "Description.AccountName",
	"creation_time":           "Description.Automation.Properties.CreationTime",
	"description":             "Description.Automation.properties.description",
	"id":                      "Description.Automation.id",
	"is_encrypted":            "Description.Automation.properties.isEncrypted",
	"last_modified_time":      "Description.Automation.Properties.LastModifiedTime",
	"name":                    "Description.Automation.name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "Description.ResourceGroup",
	"subscription":            "Description.Automation.Properties.Subscription",
	"title":                   "Description.Automation.name",
	"type":                    "Description.Automation.type",
	"value":                   "Description.Automation.properties.value",
}

func ListAutomationVariables(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAutomationVariables")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutomationVariables NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutomationVariables NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutomationVariables GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutomationVariables GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutomationVariables GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAutomationVariablesPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAutomationVariablesFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutomationVariables NewAutomationVariablesPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAutomationVariables paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAutomationVariablesFilters = map[string]string{
	"account_name":            "Description.AccountName",
	"creation_time":           "Description.Automation.Properties.CreationTime",
	"description":             "Description.Automation.properties.description",
	"id":                      "Description.Automation.id",
	"is_encrypted":            "Description.Automation.properties.isEncrypted",
	"last_modified_time":      "Description.Automation.Properties.LastModifiedTime",
	"name":                    "Description.Automation.name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "Description.ResourceGroup",
	"subscription":            "Description.Automation.Properties.Subscription",
	"title":                   "Description.Automation.name",
	"type":                    "Description.Automation.type",
	"value":                   "Description.Automation.properties.value",
}

func GetAutomationVariables(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAutomationVariables")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAutomationVariablesPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAutomationVariablesFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AutomationVariables =============================

// ==========================  START: AppConfiguration =============================

type AppConfiguration struct {
	ResourceID      string                            `json:"resource_id"`
	PlatformID      string                            `json:"platform_id"`
	Description     azure.AppConfigurationDescription `json:"Description"`
	Metadata        azure.Metadata                    `json:"metadata"`
	DescribedBy     string                            `json:"described_by"`
	ResourceType    string                            `json:"resource_type"`
	IntegrationType string                            `json:"integration_type"`
	IntegrationID   string                            `json:"integration_id"`
}

type AppConfigurationHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  AppConfiguration `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type AppConfigurationHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []AppConfigurationHit `json:"hits"`
}

type AppConfigurationSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  AppConfigurationHits `json:"hits"`
}

type AppConfigurationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAppConfigurationPaginator(filters []essdk.BoolFilter, limit *int64) (AppConfigurationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_appconfiguration_configurationstores", filters, limit)
	if err != nil {
		return AppConfigurationPaginator{}, err
	}

	p := AppConfigurationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AppConfigurationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AppConfigurationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AppConfigurationPaginator) NextPage(ctx context.Context) ([]AppConfiguration, error) {
	var response AppConfigurationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AppConfiguration
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAppConfigurationFilters = map[string]string{
	"diagnostic_settings":     "Description.DiagnosticSettingsResources",
	"encryption":              "Description.ConfigurationStore.Properties.Encryption",
	"endpoint":                "Description.ConfigurationStore.properties.endpoint",
	"id":                      "Description.ConfigurationStore.id",
	"identity":                "Description.ConfigurationStore.Identity",
	"name":                    "Description.ConfigurationStore.name",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.ConfigurationStore.properties.provisioningState",
	"resource_group":          "Description.ResourceGroup",
	"sku_name":                "Description.ConfigurationStore.sku.name",
	"subscription":            "Description.ConfigurationStore.Properties.Subscription",
	"tags":                    "Description.ConfigurationStore.Tags",
	"title":                   "Description.ConfigurationStore.name",
	"type":                    "Description.ConfigurationStore.type",
}

func ListAppConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAppConfiguration")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppConfiguration NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppConfiguration NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAppConfigurationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAppConfigurationFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppConfiguration NewAppConfigurationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAppConfiguration paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAppConfigurationFilters = map[string]string{
	"diagnostic_settings":     "Description.DiagnosticSettingsResources",
	"encryption":              "Description.ConfigurationStore.Properties.Encryption",
	"endpoint":                "Description.ConfigurationStore.properties.endpoint",
	"id":                      "Description.ConfigurationStore.id",
	"identity":                "Description.ConfigurationStore.Identity",
	"name":                    "description.ConfigurationStore.name",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.ConfigurationStore.properties.provisioningState",
	"resource_group":          "description.ResourceGroup",
	"sku_name":                "Description.ConfigurationStore.sku.name",
	"subscription":            "Description.ConfigurationStore.Properties.Subscription",
	"tags":                    "Description.ConfigurationStore.Tags",
	"title":                   "Description.ConfigurationStore.name",
	"type":                    "Description.ConfigurationStore.type",
}

func GetAppConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAppConfiguration")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAppConfigurationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAppConfigurationFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AppConfiguration =============================

// ==========================  START: AppServiceEnvironment =============================

type AppServiceEnvironment struct {
	ResourceID      string                                 `json:"resource_id"`
	PlatformID      string                                 `json:"platform_id"`
	Description     azure.AppServiceEnvironmentDescription `json:"Description"`
	Metadata        azure.Metadata                         `json:"metadata"`
	DescribedBy     string                                 `json:"described_by"`
	ResourceType    string                                 `json:"resource_type"`
	IntegrationType string                                 `json:"integration_type"`
	IntegrationID   string                                 `json:"integration_id"`
}

type AppServiceEnvironmentHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  AppServiceEnvironment `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type AppServiceEnvironmentHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []AppServiceEnvironmentHit `json:"hits"`
}

type AppServiceEnvironmentSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  AppServiceEnvironmentHits `json:"hits"`
}

type AppServiceEnvironmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAppServiceEnvironmentPaginator(filters []essdk.BoolFilter, limit *int64) (AppServiceEnvironmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_web_hostingenvironments", filters, limit)
	if err != nil {
		return AppServiceEnvironmentPaginator{}, err
	}

	p := AppServiceEnvironmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AppServiceEnvironmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AppServiceEnvironmentPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AppServiceEnvironmentPaginator) NextPage(ctx context.Context) ([]AppServiceEnvironment, error) {
	var response AppServiceEnvironmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AppServiceEnvironment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAppServiceEnvironmentFilters = map[string]string{
	"cluster_settings":               "Description.AppServiceEnvironmentResource.Properties.ClusterSettings",
	"default_front_end_scale_factor": "Description.AppServiceEnvironmentResource.properties.frontEndScaleFactor",
	"dynamic_cache_enabled":          "Description.AppServiceEnvironmentResource.Properties.EnableAcceleratedNetworking",
	"front_end_scale_factor":         "Description.AppServiceEnvironmentResource.properties.frontEndScaleFactor",
	"has_linux_workers":              "Description.AppServiceEnvironmentResource.properties.hasLinuxWorkers",
	"id":                             "Description.AppServiceEnvironmentResource.id",
	"internal_load_balancing_mode":   "Description.AppServiceEnvironmentResource.properties.internalLoadBalancingMode",
	"is_healthy_environment":         "Description.AppServiceEnvironmentResource.Properties.EnvironmentIsHealthy",
	"kind":                           "Description.AppServiceEnvironmentResource.kind",
	"name":                           "Description.AppServiceEnvironmentResource.name",
	"platform_integration_id":        "IntegrationID",
	"provisioning_state":             "Description.AppServiceEnvironmentResource.properties.provisioningState",
	"status":                         "Description.AppServiceEnvironmentResource.properties.status",
	"subscription":                   "Description.AppServiceEnvironmentResource.Properties.Subscription",
	"suspended":                      "Description.AppServiceEnvironmentResource.properties.suspended",
	"tags":                           "Description.AppServiceEnvironmentResource.Tags",
	"title":                          "Description.AppServiceEnvironmentResource.name",
	"type":                           "Description.AppServiceEnvironmentResource.type",
}

func ListAppServiceEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAppServiceEnvironment")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServiceEnvironment NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServiceEnvironment NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServiceEnvironment GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServiceEnvironment GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServiceEnvironment GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAppServiceEnvironmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAppServiceEnvironmentFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServiceEnvironment NewAppServiceEnvironmentPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAppServiceEnvironment paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAppServiceEnvironmentFilters = map[string]string{
	"cluster_settings":               "Description.AppServiceEnvironmentResource.Properties.ClusterSettings",
	"default_front_end_scale_factor": "Description.AppServiceEnvironmentResource.properties.frontEndScaleFactor",
	"dynamic_cache_enabled":          "Description.AppServiceEnvironmentResource.Properties.EnableAcceleratedNetworking",
	"front_end_scale_factor":         "Description.AppServiceEnvironmentResource.properties.frontEndScaleFactor",
	"has_linux_workers":              "Description.AppServiceEnvironmentResource.properties.hasLinuxWorkers",
	"id":                             "Description.AppServiceEnvironmentResource.id",
	"internal_load_balancing_mode":   "Description.AppServiceEnvironmentResource.properties.internalLoadBalancingMode",
	"is_healthy_environment":         "Description.AppServiceEnvironmentResource.Properties.EnvironmentIsHealthy",
	"kind":                           "Description.AppServiceEnvironmentResource.kind",
	"name":                           "description.AppServiceEnvironmentResource.name",
	"platform_integration_id":        "IntegrationID",
	"provisioning_state":             "Description.AppServiceEnvironmentResource.properties.provisioningState",
	"resource_group":                 "description.ResourceGroup",
	"status":                         "Description.AppServiceEnvironmentResource.properties.status",
	"subscription":                   "Description.AppServiceEnvironmentResource.Properties.Subscription",
	"suspended":                      "Description.AppServiceEnvironmentResource.properties.suspended",
	"tags":                           "Description.AppServiceEnvironmentResource.Tags",
	"title":                          "Description.AppServiceEnvironmentResource.name",
	"type":                           "Description.AppServiceEnvironmentResource.type",
}

func GetAppServiceEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAppServiceEnvironment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAppServiceEnvironmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAppServiceEnvironmentFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AppServiceEnvironment =============================

// ==========================  START: AppServiceFunctionApp =============================

type AppServiceFunctionApp struct {
	ResourceID      string                                 `json:"resource_id"`
	PlatformID      string                                 `json:"platform_id"`
	Description     azure.AppServiceFunctionAppDescription `json:"Description"`
	Metadata        azure.Metadata                         `json:"metadata"`
	DescribedBy     string                                 `json:"described_by"`
	ResourceType    string                                 `json:"resource_type"`
	IntegrationType string                                 `json:"integration_type"`
	IntegrationID   string                                 `json:"integration_id"`
}

type AppServiceFunctionAppHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  AppServiceFunctionApp `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type AppServiceFunctionAppHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []AppServiceFunctionAppHit `json:"hits"`
}

type AppServiceFunctionAppSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  AppServiceFunctionAppHits `json:"hits"`
}

type AppServiceFunctionAppPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAppServiceFunctionAppPaginator(filters []essdk.BoolFilter, limit *int64) (AppServiceFunctionAppPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_web_sites", filters, limit)
	if err != nil {
		return AppServiceFunctionAppPaginator{}, err
	}

	p := AppServiceFunctionAppPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AppServiceFunctionAppPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AppServiceFunctionAppPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AppServiceFunctionAppPaginator) NextPage(ctx context.Context) ([]AppServiceFunctionApp, error) {
	var response AppServiceFunctionAppSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AppServiceFunctionApp
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAppServiceFunctionAppFilters = map[string]string{
	"auth_settings":                  "Description.SiteAuthSettings",
	"client_affinity_enabled":        "Description.Site.properties.clientAffinityEnabled",
	"client_cert_enabled":            "Description.Site.properties.clientCertEnabled",
	"configuration":                  "Description.SiteConfigResource",
	"default_site_hostname":          "Description.Site.properties.defaultHostName",
	"enabled":                        "Description.Site.properties.enabled",
	"host_name_disabled":             "Description.Site.properties.hostNamesDisabled",
	"host_names":                     "Description.Site.Properties.HostNames",
	"https_only":                     "Description.Site.properties.httpsOnly",
	"id":                             "Description.Site.id",
	"kind":                           "Description.Site.kind",
	"name":                           "Description.Site.name",
	"outbound_ip_addresses":          "Description.Site.properties.outboundIpAddresses",
	"platform_integration_id":        "IntegrationID",
	"possible_outbound_ip_addresses": "Description.Site.properties.possibleOutboundIpAddresses",
	"reserved":                       "Description.Site.properties.reserved",
	"site_config":                    "Description.Site.Properties.SiteConfig",
	"state":                          "Description.Site.properties.state",
	"subscription":                   "Description.Site.Properties.Subscription",
	"tags":                           "Description.Site.Tags",
	"title":                          "Description.Site.name",
	"type":                           "Description.Site.Properties.Type",
}

func ListAppServiceFunctionApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAppServiceFunctionApp")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServiceFunctionApp NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServiceFunctionApp NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServiceFunctionApp GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServiceFunctionApp GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServiceFunctionApp GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAppServiceFunctionAppPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAppServiceFunctionAppFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServiceFunctionApp NewAppServiceFunctionAppPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAppServiceFunctionApp paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAppServiceFunctionAppFilters = map[string]string{
	"auth_settings":                  "Description.SiteAuthSettings",
	"client_affinity_enabled":        "Description.Site.properties.clientAffinityEnabled",
	"client_cert_enabled":            "Description.Site.properties.clientCertEnabled",
	"configuration":                  "Description.SiteConfigResource",
	"default_site_hostname":          "Description.Site.properties.defaultHostName",
	"enabled":                        "Description.Site.properties.enabled",
	"host_name_disabled":             "Description.Site.properties.hostNamesDisabled",
	"host_names":                     "Description.Site.Properties.HostNames",
	"https_only":                     "Description.Site.properties.httpsOnly",
	"id":                             "Description.Site.id",
	"kind":                           "Description.Site.kind",
	"name":                           "description.Site.name",
	"outbound_ip_addresses":          "Description.Site.properties.outboundIpAddresses",
	"platform_integration_id":        "IntegrationID",
	"possible_outbound_ip_addresses": "Description.Site.properties.possibleOutboundIpAddresses",
	"reserved":                       "Description.Site.properties.reserved",
	"resource_group":                 "description.ResourceGroup",
	"site_config":                    "Description.Site.Properties.SiteConfig",
	"state":                          "Description.Site.properties.state",
	"subscription":                   "Description.Site.Properties.Subscription",
	"tags":                           "Description.Site.Tags",
	"title":                          "Description.Site.name",
	"type":                           "Description.Site.Properties.Type",
}

func GetAppServiceFunctionApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAppServiceFunctionApp")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAppServiceFunctionAppPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAppServiceFunctionAppFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AppServiceFunctionApp =============================

// ==========================  START: AppServiceWebApp =============================

type AppServiceWebApp struct {
	ResourceID      string                            `json:"resource_id"`
	PlatformID      string                            `json:"platform_id"`
	Description     azure.AppServiceWebAppDescription `json:"Description"`
	Metadata        azure.Metadata                    `json:"metadata"`
	DescribedBy     string                            `json:"described_by"`
	ResourceType    string                            `json:"resource_type"`
	IntegrationType string                            `json:"integration_type"`
	IntegrationID   string                            `json:"integration_id"`
}

type AppServiceWebAppHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  AppServiceWebApp `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type AppServiceWebAppHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []AppServiceWebAppHit `json:"hits"`
}

type AppServiceWebAppSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  AppServiceWebAppHits `json:"hits"`
}

type AppServiceWebAppPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAppServiceWebAppPaginator(filters []essdk.BoolFilter, limit *int64) (AppServiceWebAppPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_web_staticsites", filters, limit)
	if err != nil {
		return AppServiceWebAppPaginator{}, err
	}

	p := AppServiceWebAppPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AppServiceWebAppPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AppServiceWebAppPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AppServiceWebAppPaginator) NextPage(ctx context.Context) ([]AppServiceWebApp, error) {
	var response AppServiceWebAppSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AppServiceWebApp
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAppServiceWebAppFilters = map[string]string{
	"auth_settings":                  "Description.SiteAuthSettings",
	"client_affinity_enabled":        "Description.Site.properties.clientAffinityEnabled",
	"client_cert_enabled":            "Description.Site.properties.clientCertEnabled",
	"configuration":                  "Description.SiteConfigResource",
	"default_site_hostname":          "Description.Site.properties.defaultHostName",
	"diagnostic_logs_configuration":  "Description.SiteLogConfig",
	"enabled":                        "Description.Site.properties.enabled",
	"host_name_disabled":             "Description.Site.properties.hostNamesDisabled",
	"host_names":                     "Description.Site.Properties.HostNames",
	"https_only":                     "Description.Site.properties.httpsOnly",
	"id":                             "Description.Site.id",
	"kind":                           "Description.Site.kind",
	"name":                           "Description.Site.name",
	"outbound_ip_addresses":          "Description.Site.properties.outboundIpAddresses",
	"platform_integration_id":        "IntegrationID",
	"possible_outbound_ip_addresses": "Description.Site.properties.possibleOutboundIpAddresses",
	"reserved":                       "Description.Site.properties.reserved",
	"site_config":                    "Description.Site.Properties.SiteConfig",
	"state":                          "Description.Site.properties.state",
	"subscription":                   "Description.Site.Properties.Subscription",
	"tags":                           "Description.Site.Tags",
	"title":                          "Description.Site.name",
	"type":                           "Description.Site.type",
	"vnet_connection":                "Description.VnetInfo",
}

func ListAppServiceWebApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAppServiceWebApp")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServiceWebApp NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServiceWebApp NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServiceWebApp GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServiceWebApp GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServiceWebApp GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAppServiceWebAppPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAppServiceWebAppFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServiceWebApp NewAppServiceWebAppPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAppServiceWebApp paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAppServiceWebAppFilters = map[string]string{
	"auth_settings":                  "Description.SiteAuthSettings",
	"client_affinity_enabled":        "Description.Site.properties.clientAffinityEnabled",
	"client_cert_enabled":            "Description.Site.properties.clientCertEnabled",
	"configuration":                  "Description.SiteConfigResource",
	"default_site_hostname":          "Description.Site.properties.defaultHostName",
	"diagnostic_logs_configuration":  "Description.SiteLogConfig",
	"enabled":                        "Description.Site.properties.enabled",
	"host_name_disabled":             "Description.Site.properties.hostNamesDisabled",
	"host_names":                     "Description.Site.Properties.HostNames",
	"https_only":                     "Description.Site.properties.httpsOnly",
	"id":                             "Description.Site.id",
	"kind":                           "Description.Site.kind",
	"name":                           "description.Site.name",
	"outbound_ip_addresses":          "Description.Site.properties.outboundIpAddresses",
	"platform_integration_id":        "IntegrationID",
	"possible_outbound_ip_addresses": "Description.Site.properties.possibleOutboundIpAddresses",
	"reserved":                       "Description.Site.properties.reserved",
	"resource_group":                 "description.ResourceGroup",
	"site_config":                    "Description.Site.Properties.SiteConfig",
	"state":                          "Description.Site.properties.state",
	"subscription":                   "Description.Site.Properties.Subscription",
	"tags":                           "Description.Site.Tags",
	"title":                          "Description.Site.name",
	"type":                           "Description.Site.type",
	"vnet_connection":                "Description.VnetInfo",
}

func GetAppServiceWebApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAppServiceWebApp")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAppServiceWebAppPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAppServiceWebAppFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AppServiceWebApp =============================

// ==========================  START: AppServiceWebAppSlot =============================

type AppServiceWebAppSlot struct {
	ResourceID      string                                `json:"resource_id"`
	PlatformID      string                                `json:"platform_id"`
	Description     azure.AppServiceWebAppSlotDescription `json:"Description"`
	Metadata        azure.Metadata                        `json:"metadata"`
	DescribedBy     string                                `json:"described_by"`
	ResourceType    string                                `json:"resource_type"`
	IntegrationType string                                `json:"integration_type"`
	IntegrationID   string                                `json:"integration_id"`
}

type AppServiceWebAppSlotHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  AppServiceWebAppSlot `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type AppServiceWebAppSlotHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []AppServiceWebAppSlotHit `json:"hits"`
}

type AppServiceWebAppSlotSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  AppServiceWebAppSlotHits `json:"hits"`
}

type AppServiceWebAppSlotPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAppServiceWebAppSlotPaginator(filters []essdk.BoolFilter, limit *int64) (AppServiceWebAppSlotPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_web_sites_slots", filters, limit)
	if err != nil {
		return AppServiceWebAppSlotPaginator{}, err
	}

	p := AppServiceWebAppSlotPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AppServiceWebAppSlotPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AppServiceWebAppSlotPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AppServiceWebAppSlotPaginator) NextPage(ctx context.Context) ([]AppServiceWebAppSlot, error) {
	var response AppServiceWebAppSlotSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AppServiceWebAppSlot
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAppServiceWebAppSlotFilters = map[string]string{
	"app_name":                       "Description.AppName",
	"availability_state":             "Description.Site.properties.availabilityState",
	"client_affinity_enabled":        "Description.Site.properties.clientAffinityEnabled",
	"client_cert_exclusion_paths":    "Description.Site.properties.clientCertExclusionPaths",
	"client_cert_mode":               "Description.Site.properties.clientCertMode",
	"container_size":                 "Description.Site.properties.containerSize",
	"custom_domain_verification_id":  "Description.Site.properties.customDomainVerificationId",
	"default_host_name":              "Description.Site.properties.defaultHostName",
	"enabled":                        "Description.Site.properties.enabled",
	"enabled_host_names":             "Description.Site.Properties.EnabledHostNames",
	"host_name_ssl_states":           "Description.Site.Properties.HostNameSSLStates",
	"host_names":                     "Description.Site.Properties.HostNames",
	"host_names_disabled":            "Description.Site.properties.hostNamesDisabled",
	"hosting_environment_profile":    "Description.Site.Properties.HostingEnvironmentProfile",
	"https_only":                     "Description.Site.properties.httpsOnly",
	"hyper_v":                        "Description.Site.properties.hyperV",
	"id":                             "Description.Site.id",
	"identity":                       "Description.Site.Identity",
	"is_default_container":           "Description.Site.properties.isDefaultContainer",
	"is_xenon":                       "Description.Site.properties.isXenon",
	"kind":                           "Description.Site.kind",
	"last_modified_time_utc":         "Description.Site.Properties.LastModifiedTimeUTC",
	"outbound_ip_addresses":          "Description.Site.properties.outboundIpAddresses",
	"possible_outbound_ip_addresses": "Description.Site.properties.possibleOutboundIpAddresses",
	"redundancy_mode":                "Description.Site.properties.redundancyMode",
	"repository_site_name":           "Description.Site.properties.repositorySiteName",
	"reserved":                       "Description.Site.properties.reserved",
	"resource_group":                 "Description.ResourceGroup",
	"scm_site_also_stopped":          "Description.Site.properties.scmSiteAlsoStopped",
	"server_farm_id":                 "Description.Site.properties.serverFarmId",
	"site_config":                    "Description.Site.Properties.SiteConfig",
	"site_config_resource":           "Description.Site.Properties.SiteConfig",
	"slot_swap_status":               "Description.Site.Properties.SlotSwapStatus",
	"state":                          "Description.Site.properties.state",
	"subscription":                   "Description.Site.Properties.Subscription",
	"suspended_till":                 "Description.Site.Properties.SuspendedTill",
	"tags":                           "Description.Site.Tags",
	"target_swap_slot":               "Description.Site.properties.targetSwapSlot",
	"title":                          "Description.Site.name",
	"traffic_manager_host_names":     "Description.Site.Properties.TrafficManagerHostNames",
	"type":                           "Description.Site.type",
	"usage_state":                    "Description.Site.properties.usageState",
}

func ListAppServiceWebAppSlot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAppServiceWebAppSlot")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServiceWebAppSlot NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServiceWebAppSlot NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServiceWebAppSlot GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServiceWebAppSlot GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServiceWebAppSlot GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAppServiceWebAppSlotPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAppServiceWebAppSlotFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServiceWebAppSlot NewAppServiceWebAppSlotPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAppServiceWebAppSlot paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAppServiceWebAppSlotFilters = map[string]string{
	"app_name":                       "Description.AppName",
	"availability_state":             "Description.Site.properties.availabilityState",
	"client_affinity_enabled":        "Description.Site.properties.clientAffinityEnabled",
	"client_cert_exclusion_paths":    "Description.Site.properties.clientCertExclusionPaths",
	"client_cert_mode":               "Description.Site.properties.clientCertMode",
	"container_size":                 "Description.Site.properties.containerSize",
	"custom_domain_verification_id":  "Description.Site.properties.customDomainVerificationId",
	"default_host_name":              "Description.Site.properties.defaultHostName",
	"enabled":                        "Description.Site.properties.enabled",
	"enabled_host_names":             "Description.Site.Properties.EnabledHostNames",
	"host_name_ssl_states":           "Description.Site.Properties.HostNameSSLStates",
	"host_names":                     "Description.Site.Properties.HostNames",
	"host_names_disabled":            "Description.Site.properties.hostNamesDisabled",
	"hosting_environment_profile":    "Description.Site.Properties.HostingEnvironmentProfile",
	"https_only":                     "Description.Site.properties.httpsOnly",
	"hyper_v":                        "Description.Site.properties.hyperV",
	"id":                             "Description.Site.id",
	"identity":                       "Description.Site.Identity",
	"is_default_container":           "Description.Site.properties.isDefaultContainer",
	"is_xenon":                       "Description.Site.properties.isXenon",
	"kind":                           "Description.Site.kind",
	"last_modified_time_utc":         "Description.Site.Properties.LastModifiedTimeUTC",
	"outbound_ip_addresses":          "Description.Site.properties.outboundIpAddresses",
	"possible_outbound_ip_addresses": "Description.Site.properties.possibleOutboundIpAddresses",
	"redundancy_mode":                "Description.Site.properties.redundancyMode",
	"repository_site_name":           "Description.Site.properties.repositorySiteName",
	"reserved":                       "Description.Site.properties.reserved",
	"resource_group":                 "Description.ResourceGroup",
	"scm_site_also_stopped":          "Description.Site.properties.scmSiteAlsoStopped",
	"server_farm_id":                 "Description.Site.properties.serverFarmId",
	"site_config":                    "Description.Site.Properties.SiteConfig",
	"site_config_resource":           "Description.Site.Properties.SiteConfig",
	"slot_swap_status":               "Description.Site.Properties.SlotSwapStatus",
	"state":                          "Description.Site.properties.state",
	"subscription":                   "Description.Site.Properties.Subscription",
	"suspended_till":                 "Description.Site.Properties.SuspendedTill",
	"tags":                           "Description.Site.Tags",
	"target_swap_slot":               "Description.Site.properties.targetSwapSlot",
	"title":                          "Description.Site.name",
	"traffic_manager_host_names":     "Description.Site.Properties.TrafficManagerHostNames",
	"type":                           "Description.Site.type",
	"usage_state":                    "Description.Site.properties.usageState",
}

func GetAppServiceWebAppSlot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAppServiceWebAppSlot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAppServiceWebAppSlotPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAppServiceWebAppSlotFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AppServiceWebAppSlot =============================

// ==========================  START: AppServicePlan =============================

type AppServicePlan struct {
	ResourceID      string                          `json:"resource_id"`
	PlatformID      string                          `json:"platform_id"`
	Description     azure.AppServicePlanDescription `json:"Description"`
	Metadata        azure.Metadata                  `json:"metadata"`
	DescribedBy     string                          `json:"described_by"`
	ResourceType    string                          `json:"resource_type"`
	IntegrationType string                          `json:"integration_type"`
	IntegrationID   string                          `json:"integration_id"`
}

type AppServicePlanHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  AppServicePlan `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type AppServicePlanHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []AppServicePlanHit `json:"hits"`
}

type AppServicePlanSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  AppServicePlanHits `json:"hits"`
}

type AppServicePlanPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAppServicePlanPaginator(filters []essdk.BoolFilter, limit *int64) (AppServicePlanPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_web_plan", filters, limit)
	if err != nil {
		return AppServicePlanPaginator{}, err
	}

	p := AppServicePlanPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AppServicePlanPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AppServicePlanPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AppServicePlanPaginator) NextPage(ctx context.Context) ([]AppServicePlan, error) {
	var response AppServicePlanSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AppServicePlan
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAppServicePlanFilters = map[string]string{
	"apps":                         "Description.Apps",
	"hyper_v":                      "Description.Plan.properties.hyperV",
	"id":                           "Description.Plan.id",
	"is_spot":                      "Description.Plan.properties.isSpot",
	"is_xenon":                     "Description.Plan.properties.isXenon",
	"kind":                         "Description.Plan.kind",
	"maximum_elastic_worker_count": "Description.Plan.properties.maximumElasticWorkerCount",
	"maximum_number_of_workers":    "Description.Plan.properties.maximumNumberOfWorkers",
	"name":                         "Description.Plan.name",
	"per_site_scaling":             "Description.Plan.properties.perSiteScaling",
	"platform_integration_id":      "IntegrationID",
	"provisioning_state":           "Description.Plan.properties.provisioningState",
	"reserved":                     "Description.Plan.properties.reserved",
	"sku_capacity":                 "Description.Plan.sku.capacity",
	"sku_family":                   "Description.Plan.sku.family",
	"sku_name":                     "Description.Plan.sku.name",
	"sku_size":                     "Description.Plan.sku.size",
	"sku_tier":                     "Description.Plan.sku.tier",
	"status":                       "Description.Plan.properties.status",
	"subscription":                 "Description.Plan.properties.subscription",
	"tags":                         "Description.Plan.Tags",
	"title":                        "Description.Plan.name",
	"type":                         "Description.Plan.type",
}

func ListAppServicePlan(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAppServicePlan")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServicePlan NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServicePlan NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServicePlan GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServicePlan GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServicePlan GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAppServicePlanPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAppServicePlanFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAppServicePlan NewAppServicePlanPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAppServicePlan paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAppServicePlanFilters = map[string]string{
	"apps":                         "Description.Apps",
	"hyper_v":                      "Description.Plan.properties.hyperV",
	"id":                           "Description.Plan.id",
	"is_spot":                      "Description.Plan.properties.isSpot",
	"is_xenon":                     "Description.Plan.properties.isXenon",
	"kind":                         "Description.Plan.kind",
	"maximum_elastic_worker_count": "Description.Plan.properties.maximumElasticWorkerCount",
	"maximum_number_of_workers":    "Description.Plan.properties.maximumNumberOfWorkers",
	"name":                         "description.Site.name",
	"per_site_scaling":             "Description.Plan.properties.perSiteScaling",
	"platform_integration_id":      "IntegrationID",
	"provisioning_state":           "Description.Plan.properties.provisioningState",
	"reserved":                     "Description.Plan.properties.reserved",
	"resource_group":               "description.ResourceGroup",
	"sku_capacity":                 "Description.Plan.sku.capacity",
	"sku_family":                   "Description.Plan.sku.family",
	"sku_name":                     "Description.Plan.sku.name",
	"sku_size":                     "Description.Plan.sku.size",
	"sku_tier":                     "Description.Plan.sku.tier",
	"status":                       "Description.Plan.properties.status",
	"subscription":                 "Description.Plan.properties.subscription",
	"tags":                         "Description.Plan.Tags",
	"title":                        "Description.Plan.name",
	"type":                         "Description.Plan.type",
}

func GetAppServicePlan(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAppServicePlan")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAppServicePlanPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAppServicePlanFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AppServicePlan =============================

// ==========================  START: ContainerApp =============================

type ContainerApp struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     azure.ContainerAppDescription `json:"Description"`
	Metadata        azure.Metadata                `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type ContainerAppHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ContainerApp  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ContainerAppHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ContainerAppHit `json:"hits"`
}

type ContainerAppSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  ContainerAppHits `json:"hits"`
}

type ContainerAppPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewContainerAppPaginator(filters []essdk.BoolFilter, limit *int64) (ContainerAppPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_app_containerapps", filters, limit)
	if err != nil {
		return ContainerAppPaginator{}, err
	}

	p := ContainerAppPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ContainerAppPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ContainerAppPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ContainerAppPaginator) NextPage(ctx context.Context) ([]ContainerApp, error) {
	var response ContainerAppSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ContainerApp
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listContainerAppFilters = map[string]string{
	"id":                      "Description.Server.id",
	"name":                    "Description.Server.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Server.Properties.Subscription",
	"tags":                    "Description.Server.Tags",
	"title":                   "Description.Server.name",
}

func ListContainerApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListContainerApp")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListContainerApp NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListContainerApp NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListContainerApp GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListContainerApp GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListContainerApp GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewContainerAppPaginator(essdk.BuildFilter(ctx, d.QueryContext, listContainerAppFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListContainerApp NewContainerAppPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListContainerApp paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getContainerAppFilters = map[string]string{
	"id":                      "Description.Server.id",
	"name":                    "Description.Server.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Server.Properties.Subscription",
	"tags":                    "Description.Server.Tags",
	"title":                   "Description.Server.name",
}

func GetContainerApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetContainerApp")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewContainerAppPaginator(essdk.BuildFilter(ctx, d.QueryContext, getContainerAppFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ContainerApp =============================

// ==========================  START: WebServerFarms =============================

type WebServerFarms struct {
	ResourceID      string                          `json:"resource_id"`
	PlatformID      string                          `json:"platform_id"`
	Description     azure.WebServerFarmsDescription `json:"Description"`
	Metadata        azure.Metadata                  `json:"metadata"`
	DescribedBy     string                          `json:"described_by"`
	ResourceType    string                          `json:"resource_type"`
	IntegrationType string                          `json:"integration_type"`
	IntegrationID   string                          `json:"integration_id"`
}

type WebServerFarmsHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  WebServerFarms `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type WebServerFarmsHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []WebServerFarmsHit `json:"hits"`
}

type WebServerFarmsSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  WebServerFarmsHits `json:"hits"`
}

type WebServerFarmsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWebServerFarmsPaginator(filters []essdk.BoolFilter, limit *int64) (WebServerFarmsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_web_serverfarms", filters, limit)
	if err != nil {
		return WebServerFarmsPaginator{}, err
	}

	p := WebServerFarmsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WebServerFarmsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WebServerFarmsPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WebServerFarmsPaginator) NextPage(ctx context.Context) ([]WebServerFarms, error) {
	var response WebServerFarmsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WebServerFarms
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWebServerFarmsFilters = map[string]string{
	"id":                      "Description.ServerFarm.id",
	"name":                    "Description.ServerFarm.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.ServerFarm.Subscription",
	"tags":                    "Description.ServerFarm.Tags",
	"title":                   "Description.ServerFarm.name",
}

func ListWebServerFarms(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWebServerFarms")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWebServerFarms NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWebServerFarms NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWebServerFarms GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWebServerFarms GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWebServerFarms GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWebServerFarmsPaginator(essdk.BuildFilter(ctx, d.QueryContext, listWebServerFarmsFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWebServerFarms NewWebServerFarmsPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWebServerFarms paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWebServerFarmsFilters = map[string]string{
	"id":                      "Description.ServerFarm.id",
	"name":                    "Description.ServerFarm.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.ServerFarm.Subscription",
	"tags":                    "Description.ServerFarm.Tags",
	"title":                   "Description.ServerFarm.name",
}

func GetWebServerFarms(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWebServerFarms")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWebServerFarmsPaginator(essdk.BuildFilter(ctx, d.QueryContext, getWebServerFarmsFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WebServerFarms =============================

// ==========================  START: Blueprint =============================

type Blueprint struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     azure.BlueprintDescription `json:"Description"`
	Metadata        azure.Metadata             `json:"metadata"`
	DescribedBy     string                     `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

type BlueprintHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Blueprint     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type BlueprintHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []BlueprintHit    `json:"hits"`
}

type BlueprintSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  BlueprintHits `json:"hits"`
}

type BlueprintPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBlueprintPaginator(filters []essdk.BoolFilter, limit *int64) (BlueprintPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_blueprint_blueprints", filters, limit)
	if err != nil {
		return BlueprintPaginator{}, err
	}

	p := BlueprintPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BlueprintPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BlueprintPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BlueprintPaginator) NextPage(ctx context.Context) ([]Blueprint, error) {
	var response BlueprintSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Blueprint
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBlueprintFilters = map[string]string{
	"id":                      "Description.Blueprints.ID",
	"name":                    "Description.Blueprint.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Blueprints.Properties.Subscription",
	"title":                   "Description.Blueprint.name",
}

func ListBlueprint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBlueprint")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBlueprint NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBlueprint NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBlueprint GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBlueprint GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBlueprint GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBlueprintPaginator(essdk.BuildFilter(ctx, d.QueryContext, listBlueprintFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBlueprint NewBlueprintPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBlueprint paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBlueprintFilters = map[string]string{
	"id":                      "Description.Blueprints.ID",
	"name":                    "Description.Blueprint.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Blueprints.Properties.Subscription",
	"title":                   "Description.Blueprint.name",
}

func GetBlueprint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBlueprint")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBlueprintPaginator(essdk.BuildFilter(ctx, d.QueryContext, getBlueprintFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Blueprint =============================

// ==========================  START: ComputeDisk =============================

type ComputeDisk struct {
	ResourceID      string                       `json:"resource_id"`
	PlatformID      string                       `json:"platform_id"`
	Description     azure.ComputeDiskDescription `json:"Description"`
	Metadata        azure.Metadata               `json:"metadata"`
	DescribedBy     string                       `json:"described_by"`
	ResourceType    string                       `json:"resource_type"`
	IntegrationType string                       `json:"integration_type"`
	IntegrationID   string                       `json:"integration_id"`
}

type ComputeDiskHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ComputeDisk   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ComputeDiskHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ComputeDiskHit  `json:"hits"`
}

type ComputeDiskSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  ComputeDiskHits `json:"hits"`
}

type ComputeDiskPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeDiskPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeDiskPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_disks", filters, limit)
	if err != nil {
		return ComputeDiskPaginator{}, err
	}

	p := ComputeDiskPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeDiskPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeDiskPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ComputeDiskPaginator) NextPage(ctx context.Context) ([]ComputeDisk, error) {
	var response ComputeDiskSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeDisk
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeDiskFilters = map[string]string{
	"creation_data_gallery_image_reference_id":  "Description.Disk.properties.creationData.galleryImageReference.id",
	"creation_data_gallery_image_reference_lun": "Description.Disk.properties.creationData.galleryImageReference.lun",
	"creation_data_image_reference_id":          "Description.Disk.properties.creationData.imageReference.id",
	"creation_data_image_reference_lun":         "Description.Disk.properties.creationData.imageReference.lun",
	"creation_data_option":                      "Description.Disk.properties.creationData.createOption",
	"creation_data_source_resource_id":          "Description.Disk.properties.creationData.sourceResourceId",
	"creation_data_source_unique_id":            "Description.Disk.properties.creationData.sourceUniqueId",
	"creation_data_source_uri":                  "Description.Disk.properties.creationData.sourceUri",
	"creation_data_storage_account_id":          "Description.Disk.properties.creationData.storageAccountId",
	"creation_data_upload_size_bytes":           "Description.Disk.properties.creationData.uploadSizeBytes",
	"disk_access_id":                            "Description.Disk.properties.diskAccessId",
	"disk_iops_mbps_read_only":                  "Description.Disk.properties.diskMBpsReadOnly",
	"disk_iops_mbps_read_write":                 "Description.Disk.properties.diskMBpsReadWrite",
	"disk_iops_read_only":                       "Description.Disk.properties.diskMBpsReadOnly",
	"disk_iops_read_write":                      "Description.Disk.properties.diskMBpsReadWrite",
	"disk_size_bytes":                           "Description.Disk.properties.diskSizeBytes",
	"disk_size_gb":                              "Description.Disk.properties.diskSizeGB",
	"disk_state":                                "Description.Disk.properties.diskState",
	"encryption_disk_encryption_set_id":         "Description.Disk.properties.encryption.diskEncryptionSetId",
	"encryption_settings_collection_enabled":    "Description.Disk.properties.encryptionSettingsCollection.enabled",
	"encryption_settings_collection_settings":   "Description.Disk.Properties.EncryptionSettingsCollection.EncryptionSettings",
	"encryption_settings_collection_version":    "Description.Disk.properties.encryptionSettingsCollection.encryptionSettingsVersion",
	"encryption_type":                           "Description.Disk.properties.encryption.type",
	"hyper_v_generation":                        "Description.Disk.properties.hyperVGeneration",
	"id":                                        "Description.Disk.id",
	"managed_by":                                "Description.Disk.managedBy",
	"managed_by_extended":                       "Description.Disk.ManagedByExtended",
	"max_shares":                                "Description.Disk.properties.maxShares",
	"name":                                      "Description.Disk.name",
	"network_access_policy":                     "Description.Disk.properties.networkAccessPolicy",
	"os_type":                                   "Description.Disk.properties.osType",
	"platform_integration_id":                   "IntegrationID",
	"provisioning_state":                        "Description.Disk.ProvisioningState",
	"resource_group":                            "Description.ResourceGroup",
	"share_info":                                "Description.Disk.Properties.ShareInfo",
	"sku_name":                                  "Description.Disk.sku.name",
	"sku_tier":                                  "Description.Disk.sku.tier",
	"subscription":                              "Description.Disk.Properties.Subscription",
	"tags":                                      "Description.Disk.Tags",
	"title":                                     "Description.Disk.name",
	"type":                                      "Description.Disk.type",
	"unique_id":                                 "Description.Disk.properties.uniqueId",
	"zones":                                     "Description.Disk.Zones",
}

func ListComputeDisk(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeDisk")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeDisk NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeDisk NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeDisk GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeDisk GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeDisk GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewComputeDiskPaginator(essdk.BuildFilter(ctx, d.QueryContext, listComputeDiskFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeDisk NewComputeDiskPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListComputeDisk paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getComputeDiskFilters = map[string]string{
	"creation_data_gallery_image_reference_id":  "Description.Disk.properties.creationData.galleryImageReference.id",
	"creation_data_gallery_image_reference_lun": "Description.Disk.properties.creationData.galleryImageReference.lun",
	"creation_data_image_reference_id":          "Description.Disk.properties.creationData.imageReference.id",
	"creation_data_image_reference_lun":         "Description.Disk.properties.creationData.imageReference.lun",
	"creation_data_option":                      "Description.Disk.properties.creationData.createOption",
	"creation_data_source_resource_id":          "Description.Disk.properties.creationData.sourceResourceId",
	"creation_data_source_unique_id":            "Description.Disk.properties.creationData.sourceUniqueId",
	"creation_data_source_uri":                  "Description.Disk.properties.creationData.sourceUri",
	"creation_data_storage_account_id":          "Description.Disk.properties.creationData.storageAccountId",
	"creation_data_upload_size_bytes":           "Description.Disk.properties.creationData.uploadSizeBytes",
	"disk_access_id":                            "Description.Disk.properties.diskAccessId",
	"disk_iops_mbps_read_only":                  "Description.Disk.properties.diskMBpsReadOnly",
	"disk_iops_mbps_read_write":                 "Description.Disk.properties.diskMBpsReadWrite",
	"disk_iops_read_only":                       "Description.Disk.properties.diskMBpsReadOnly",
	"disk_iops_read_write":                      "Description.Disk.properties.diskMBpsReadWrite",
	"disk_size_bytes":                           "Description.Disk.properties.diskSizeBytes",
	"disk_size_gb":                              "Description.Disk.properties.diskSizeGB",
	"disk_state":                                "Description.Disk.properties.diskState",
	"encryption_disk_encryption_set_id":         "Description.Disk.properties.encryption.diskEncryptionSetId",
	"encryption_settings_collection_enabled":    "Description.Disk.properties.encryptionSettingsCollection.enabled",
	"encryption_settings_collection_settings":   "Description.Disk.Properties.EncryptionSettingsCollection.EncryptionSettings",
	"encryption_settings_collection_version":    "Description.Disk.properties.encryptionSettingsCollection.encryptionSettingsVersion",
	"encryption_type":                           "Description.Disk.properties.encryption.type",
	"hyper_v_generation":                        "Description.Disk.properties.hyperVGeneration",
	"id":                                        "Description.Disk.id",
	"managed_by":                                "Description.Disk.managedBy",
	"managed_by_extended":                       "Description.Disk.ManagedByExtended",
	"max_shares":                                "Description.Disk.properties.maxShares",
	"name":                                      "description.Disk.name",
	"network_access_policy":                     "Description.Disk.properties.networkAccessPolicy",
	"os_type":                                   "Description.Disk.properties.osType",
	"platform_integration_id":                   "IntegrationID",
	"provisioning_state":                        "Description.Disk.ProvisioningState",
	"resource_group":                            "description.ResourceGroup",
	"share_info":                                "Description.Disk.Properties.ShareInfo",
	"sku_name":                                  "Description.Disk.sku.name",
	"sku_tier":                                  "Description.Disk.sku.tier",
	"subscription":                              "Description.Disk.Properties.Subscription",
	"tags":                                      "Description.Disk.Tags",
	"title":                                     "Description.Disk.name",
	"type":                                      "Description.Disk.type",
	"unique_id":                                 "Description.Disk.properties.uniqueId",
	"zones":                                     "Description.Disk.Zones",
}

func GetComputeDisk(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeDisk")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewComputeDiskPaginator(essdk.BuildFilter(ctx, d.QueryContext, getComputeDiskFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ComputeDisk =============================

// ==========================  START: ComputeDiskAccess =============================

type ComputeDiskAccess struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     azure.ComputeDiskAccessDescription `json:"Description"`
	Metadata        azure.Metadata                     `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type ComputeDiskAccessHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  ComputeDiskAccess `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type ComputeDiskAccessHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []ComputeDiskAccessHit `json:"hits"`
}

type ComputeDiskAccessSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  ComputeDiskAccessHits `json:"hits"`
}

type ComputeDiskAccessPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeDiskAccessPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeDiskAccessPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_diskaccesses", filters, limit)
	if err != nil {
		return ComputeDiskAccessPaginator{}, err
	}

	p := ComputeDiskAccessPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeDiskAccessPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeDiskAccessPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ComputeDiskAccessPaginator) NextPage(ctx context.Context) ([]ComputeDiskAccess, error) {
	var response ComputeDiskAccessSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeDiskAccess
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeDiskAccessFilters = map[string]string{
	"id":                      "Description.DiskAccess.id",
	"name":                    "Description.DiskAccess.name",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.DiskAccess.properties.provisioningState",
	"resource_group":          "Description.ResourceGroup",
	"subscription":            "Description.DiskAccess.Properties.Subscription",
	"tags":                    "Description.DiskAccess.Tags",
	"title":                   "Description.DiskAccess.name",
	"type":                    "Description.DiskAccess.type",
}

func ListComputeDiskAccess(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeDiskAccess")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeDiskAccess NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeDiskAccess NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeDiskAccess GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeDiskAccess GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeDiskAccess GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewComputeDiskAccessPaginator(essdk.BuildFilter(ctx, d.QueryContext, listComputeDiskAccessFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeDiskAccess NewComputeDiskAccessPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListComputeDiskAccess paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getComputeDiskAccessFilters = map[string]string{
	"id":                      "Description.DiskAccess.id",
	"name":                    "description.DiskAccess.name",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.DiskAccess.properties.provisioningState",
	"resource_group":          "description.ResourceGroup",
	"subscription":            "Description.DiskAccess.Properties.Subscription",
	"tags":                    "Description.DiskAccess.Tags",
	"title":                   "Description.DiskAccess.name",
	"type":                    "Description.DiskAccess.type",
}

func GetComputeDiskAccess(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeDiskAccess")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewComputeDiskAccessPaginator(essdk.BuildFilter(ctx, d.QueryContext, getComputeDiskAccessFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ComputeDiskAccess =============================

// ==========================  START: ComputeVirtualMachineScaleSet =============================

type ComputeVirtualMachineScaleSet struct {
	ResourceID      string                                         `json:"resource_id"`
	PlatformID      string                                         `json:"platform_id"`
	Description     azure.ComputeVirtualMachineScaleSetDescription `json:"Description"`
	Metadata        azure.Metadata                                 `json:"metadata"`
	DescribedBy     string                                         `json:"described_by"`
	ResourceType    string                                         `json:"resource_type"`
	IntegrationType string                                         `json:"integration_type"`
	IntegrationID   string                                         `json:"integration_id"`
}

type ComputeVirtualMachineScaleSetHit struct {
	ID      string                        `json:"_id"`
	Score   float64                       `json:"_score"`
	Index   string                        `json:"_index"`
	Type    string                        `json:"_type"`
	Version int64                         `json:"_version,omitempty"`
	Source  ComputeVirtualMachineScaleSet `json:"_source"`
	Sort    []interface{}                 `json:"sort"`
}

type ComputeVirtualMachineScaleSetHits struct {
	Total essdk.SearchTotal                  `json:"total"`
	Hits  []ComputeVirtualMachineScaleSetHit `json:"hits"`
}

type ComputeVirtualMachineScaleSetSearchResponse struct {
	PitID string                            `json:"pit_id"`
	Hits  ComputeVirtualMachineScaleSetHits `json:"hits"`
}

type ComputeVirtualMachineScaleSetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeVirtualMachineScaleSetPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeVirtualMachineScaleSetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_virtualmachinescalesets", filters, limit)
	if err != nil {
		return ComputeVirtualMachineScaleSetPaginator{}, err
	}

	p := ComputeVirtualMachineScaleSetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeVirtualMachineScaleSetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeVirtualMachineScaleSetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ComputeVirtualMachineScaleSetPaginator) NextPage(ctx context.Context) ([]ComputeVirtualMachineScaleSet, error) {
	var response ComputeVirtualMachineScaleSetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeVirtualMachineScaleSet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeVirtualMachineScaleSetFilters = map[string]string{
	"do_not_run_extensions_on_overprovisioned_vms": "Description.VirtualMachineScaleSet.properties.doNotRunExtensionsOnOverprovisionedVMs",
	"extensions":                          "Description.VirtualMachineScaleSetExtensions",
	"id":                                  "Description.VirtualMachineScaleSet.id",
	"identity":                            "Description.VirtualMachineScaleSet.Identity",
	"location":                            "Description.VirtualMachineScaleSet.location",
	"name":                                "Description.VirtualMachineScaleSet.name",
	"overprovision":                       "Description.VirtualMachineScaleSet.properties.overprovision",
	"plan":                                "Description.VirtualMachineScaleSet.Plan",
	"platform_fault_domain_count":         "Description.VirtualMachineScaleSet.properties.platformFaultDomainCount",
	"platform_integration_id":             "IntegrationID",
	"provisioning_state":                  "Description.VirtualMachineScaleSet.properties.provisioningState",
	"resource_group":                      "Description.ResourceGroup",
	"scale_in_policy":                     "Description.VirtualMachineScaleSet.Properties.ScaleInPolicy",
	"single_placement_group":              "Description.VirtualMachineScaleSet.properties.singlePlacementGroup",
	"sku_capacity":                        "Description.VirtualMachineScaleSet.sku.capacity",
	"sku_name":                            "Description.VirtualMachineScaleSet.sku.name",
	"sku_tier":                            "Description.VirtualMachineScaleSet.sku.tier",
	"subscription":                        "Description.VirtualMachineScaleSet.Properties.Subscription",
	"tags":                                "Description.VirtualMachineScaleSet.Tags",
	"tags_src":                            "Description.VirtualMachineScaleSet.Tags",
	"title":                               "Description.VirtualMachineScaleSet.name",
	"type":                                "Description.VirtualMachineScaleSet.type",
	"unique_id":                           "Description.VirtualMachineScaleSet.properties.uniqueId",
	"upgrade_policy":                      "Description.VirtualMachineScaleSet.Properties.UpgradePolicy",
	"virtual_machine_diagnostics_profile": "Description.VirtualMachineScaleSet.Properties.VirtualMachineProfile.DiagnosticsProfile",
	"virtual_machine_extension_profile":   "Description.VirtualMachineScaleSet.Properties.VirtualMachineProfile.ExtensionProfile",
	"virtual_machine_network_profile":     "Description.VirtualMachineScaleSet.Properties.VirtualMachineProfile.NetworkProfile",
	"virtual_machine_os_profile":          "Description.VirtualMachineScaleSet.Properties.VirtualMachineProfile.OSProfile",
	"virtual_machine_security_profile":    "Description.VirtualMachineScaleSet.Properties.VirtualMachineProfile.SecurityProfile",
	"virtual_machine_storage_profile":     "Description.VirtualMachineScaleSet.Properties.VirtualMachineProfile.StorageProfile",
	"zones":                               "Description.VirtualMachineScaleSet.Zones",
}

func ListComputeVirtualMachineScaleSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeVirtualMachineScaleSet")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeVirtualMachineScaleSet NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeVirtualMachineScaleSet NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeVirtualMachineScaleSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeVirtualMachineScaleSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeVirtualMachineScaleSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewComputeVirtualMachineScaleSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listComputeVirtualMachineScaleSetFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeVirtualMachineScaleSet NewComputeVirtualMachineScaleSetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListComputeVirtualMachineScaleSet paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getComputeVirtualMachineScaleSetFilters = map[string]string{
	"do_not_run_extensions_on_overprovisioned_vms": "Description.VirtualMachineScaleSet.properties.doNotRunExtensionsOnOverprovisionedVMs",
	"extensions":                          "Description.VirtualMachineScaleSetExtensions",
	"id":                                  "Description.VirtualMachineScaleSet.id",
	"identity":                            "Description.VirtualMachineScaleSet.Identity",
	"location":                            "Description.VirtualMachineScaleSet.location",
	"name":                                "description.VirtualMachineScaleSet.name",
	"overprovision":                       "Description.VirtualMachineScaleSet.properties.overprovision",
	"plan":                                "Description.VirtualMachineScaleSet.Plan",
	"platform_fault_domain_count":         "Description.VirtualMachineScaleSet.properties.platformFaultDomainCount",
	"platform_integration_id":             "IntegrationID",
	"provisioning_state":                  "Description.VirtualMachineScaleSet.properties.provisioningState",
	"resource_group":                      "description.ResourceGroup",
	"scale_in_policy":                     "Description.VirtualMachineScaleSet.Properties.ScaleInPolicy",
	"single_placement_group":              "Description.VirtualMachineScaleSet.properties.singlePlacementGroup",
	"sku_capacity":                        "Description.VirtualMachineScaleSet.sku.capacity",
	"sku_name":                            "Description.VirtualMachineScaleSet.sku.name",
	"sku_tier":                            "Description.VirtualMachineScaleSet.sku.tier",
	"subscription":                        "Description.VirtualMachineScaleSet.Properties.Subscription",
	"tags":                                "Description.VirtualMachineScaleSet.Tags",
	"tags_src":                            "Description.VirtualMachineScaleSet.Tags",
	"title":                               "Description.VirtualMachineScaleSet.name",
	"type":                                "Description.VirtualMachineScaleSet.type",
	"unique_id":                           "Description.VirtualMachineScaleSet.properties.uniqueId",
	"upgrade_policy":                      "Description.VirtualMachineScaleSet.Properties.UpgradePolicy",
	"virtual_machine_diagnostics_profile": "Description.VirtualMachineScaleSet.Properties.VirtualMachineProfile.DiagnosticsProfile",
	"virtual_machine_extension_profile":   "Description.VirtualMachineScaleSet.Properties.VirtualMachineProfile.ExtensionProfile",
	"virtual_machine_network_profile":     "Description.VirtualMachineScaleSet.Properties.VirtualMachineProfile.NetworkProfile",
	"virtual_machine_os_profile":          "Description.VirtualMachineScaleSet.Properties.VirtualMachineProfile.OSProfile",
	"virtual_machine_security_profile":    "Description.VirtualMachineScaleSet.Properties.VirtualMachineProfile.SecurityProfile",
	"virtual_machine_storage_profile":     "Description.VirtualMachineScaleSet.Properties.VirtualMachineProfile.StorageProfile",
	"zones":                               "Description.VirtualMachineScaleSet.Zones",
}

func GetComputeVirtualMachineScaleSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeVirtualMachineScaleSet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewComputeVirtualMachineScaleSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getComputeVirtualMachineScaleSetFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ComputeVirtualMachineScaleSet =============================

// ==========================  START: ComputeVirtualMachineScaleSetNetworkInterface =============================

type ComputeVirtualMachineScaleSetNetworkInterface struct {
	ResourceID      string                                                         `json:"resource_id"`
	PlatformID      string                                                         `json:"platform_id"`
	Description     azure.ComputeVirtualMachineScaleSetNetworkInterfaceDescription `json:"Description"`
	Metadata        azure.Metadata                                                 `json:"metadata"`
	DescribedBy     string                                                         `json:"described_by"`
	ResourceType    string                                                         `json:"resource_type"`
	IntegrationType string                                                         `json:"integration_type"`
	IntegrationID   string                                                         `json:"integration_id"`
}

type ComputeVirtualMachineScaleSetNetworkInterfaceHit struct {
	ID      string                                        `json:"_id"`
	Score   float64                                       `json:"_score"`
	Index   string                                        `json:"_index"`
	Type    string                                        `json:"_type"`
	Version int64                                         `json:"_version,omitempty"`
	Source  ComputeVirtualMachineScaleSetNetworkInterface `json:"_source"`
	Sort    []interface{}                                 `json:"sort"`
}

type ComputeVirtualMachineScaleSetNetworkInterfaceHits struct {
	Total essdk.SearchTotal                                  `json:"total"`
	Hits  []ComputeVirtualMachineScaleSetNetworkInterfaceHit `json:"hits"`
}

type ComputeVirtualMachineScaleSetNetworkInterfaceSearchResponse struct {
	PitID string                                            `json:"pit_id"`
	Hits  ComputeVirtualMachineScaleSetNetworkInterfaceHits `json:"hits"`
}

type ComputeVirtualMachineScaleSetNetworkInterfacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeVirtualMachineScaleSetNetworkInterfacePaginator(filters []essdk.BoolFilter, limit *int64) (ComputeVirtualMachineScaleSetNetworkInterfacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_virtualmachinescalesets_networkinterfaces", filters, limit)
	if err != nil {
		return ComputeVirtualMachineScaleSetNetworkInterfacePaginator{}, err
	}

	p := ComputeVirtualMachineScaleSetNetworkInterfacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeVirtualMachineScaleSetNetworkInterfacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeVirtualMachineScaleSetNetworkInterfacePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ComputeVirtualMachineScaleSetNetworkInterfacePaginator) NextPage(ctx context.Context) ([]ComputeVirtualMachineScaleSetNetworkInterface, error) {
	var response ComputeVirtualMachineScaleSetNetworkInterfaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeVirtualMachineScaleSetNetworkInterface
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeVirtualMachineScaleSetNetworkInterfaceFilters = map[string]string{
	"id":                      "Description.NetworkInterface.id",
	"mac_address":             "Description.NetworkInterface.MacAddress",
	"name":                    "Description.NetworkInterface.name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "Description.ResourceGroup",
	"scale_set_name":          "Description.VirtualMachineScaleSet.name",
	"subscription":            "Description.NetworkInterface.Properties.Subscription",
	"tags":                    "Description.NetworkInterface.Tags",
	"title":                   "Description.NetworkInterface.name",
	"type":                    "Description.NetworkInterface.type",
}

func ListComputeVirtualMachineScaleSetNetworkInterface(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeVirtualMachineScaleSetNetworkInterface")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeVirtualMachineScaleSetNetworkInterface NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeVirtualMachineScaleSetNetworkInterface NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeVirtualMachineScaleSetNetworkInterface GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeVirtualMachineScaleSetNetworkInterface GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeVirtualMachineScaleSetNetworkInterface GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewComputeVirtualMachineScaleSetNetworkInterfacePaginator(essdk.BuildFilter(ctx, d.QueryContext, listComputeVirtualMachineScaleSetNetworkInterfaceFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeVirtualMachineScaleSetNetworkInterface NewComputeVirtualMachineScaleSetNetworkInterfacePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListComputeVirtualMachineScaleSetNetworkInterface paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getComputeVirtualMachineScaleSetNetworkInterfaceFilters = map[string]string{
	"id":                      "Description.NetworkInterface.id",
	"mac_address":             "Description.NetworkInterface.MacAddress",
	"name":                    "Description.NetworkInterface.name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "Description.ResourceGroup",
	"scale_set_name":          "Description.VirtualMachineScaleSet.name",
	"subscription":            "Description.NetworkInterface.Properties.Subscription",
	"tags":                    "Description.NetworkInterface.Tags",
	"title":                   "Description.NetworkInterface.name",
	"type":                    "Description.NetworkInterface.type",
}

func GetComputeVirtualMachineScaleSetNetworkInterface(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeVirtualMachineScaleSetNetworkInterface")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewComputeVirtualMachineScaleSetNetworkInterfacePaginator(essdk.BuildFilter(ctx, d.QueryContext, getComputeVirtualMachineScaleSetNetworkInterfaceFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ComputeVirtualMachineScaleSetNetworkInterface =============================

// ==========================  START: ComputeVirtualMachineScaleSetVm =============================

type ComputeVirtualMachineScaleSetVm struct {
	ResourceID      string                                           `json:"resource_id"`
	PlatformID      string                                           `json:"platform_id"`
	Description     azure.ComputeVirtualMachineScaleSetVmDescription `json:"Description"`
	Metadata        azure.Metadata                                   `json:"metadata"`
	DescribedBy     string                                           `json:"described_by"`
	ResourceType    string                                           `json:"resource_type"`
	IntegrationType string                                           `json:"integration_type"`
	IntegrationID   string                                           `json:"integration_id"`
}

type ComputeVirtualMachineScaleSetVmHit struct {
	ID      string                          `json:"_id"`
	Score   float64                         `json:"_score"`
	Index   string                          `json:"_index"`
	Type    string                          `json:"_type"`
	Version int64                           `json:"_version,omitempty"`
	Source  ComputeVirtualMachineScaleSetVm `json:"_source"`
	Sort    []interface{}                   `json:"sort"`
}

type ComputeVirtualMachineScaleSetVmHits struct {
	Total essdk.SearchTotal                    `json:"total"`
	Hits  []ComputeVirtualMachineScaleSetVmHit `json:"hits"`
}

type ComputeVirtualMachineScaleSetVmSearchResponse struct {
	PitID string                              `json:"pit_id"`
	Hits  ComputeVirtualMachineScaleSetVmHits `json:"hits"`
}

type ComputeVirtualMachineScaleSetVmPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeVirtualMachineScaleSetVmPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeVirtualMachineScaleSetVmPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_virtualmachinescalesets_virtualmachines", filters, limit)
	if err != nil {
		return ComputeVirtualMachineScaleSetVmPaginator{}, err
	}

	p := ComputeVirtualMachineScaleSetVmPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeVirtualMachineScaleSetVmPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeVirtualMachineScaleSetVmPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ComputeVirtualMachineScaleSetVmPaginator) NextPage(ctx context.Context) ([]ComputeVirtualMachineScaleSetVm, error) {
	var response ComputeVirtualMachineScaleSetVmSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeVirtualMachineScaleSetVm
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeVirtualMachineScaleSetVmFilters = map[string]string{
	"additional_capabilities":             "Description.VirtualMachineScaleSet.Properties.AdditionalCapabilities",
	"availability_set":                    "Description.ScaleSetVM.Properties.AvailabilitySet",
	"id":                                  "Description.NetworkInterface.ID",
	"instance_id":                         "Description.ScaleSetVM.instanceId",
	"latest_model_applied":                "Description.VirtualMachineScaleSet.Properties.LatestModelApplied",
	"license_type":                        "Description.VirtualMachineScaleSet.Properties.LicenseType",
	"location":                            "Description.ScaleSetVM.location",
	"model_definition_applied":            "Description.ScaleSetVM.properties.modelDefinitionApplied",
	"name":                                "Description.ScaleSetVM.name",
	"plan":                                "Description.ScaleSetVM.Plan",
	"platform_integration_id":             "IntegrationID",
	"power_state":                         "Description.PowerState",
	"protection_policy":                   "Description.VirtualMachineScaleSet.Properties.SpotRestorePolicy",
	"provisioning_state":                  "Description.VirtualMachineScaleSet.properties.provisioningState",
	"resource_group":                      "Description.ResourceGroup",
	"resources":                           "Description.ScaleSetVM.Resources",
	"scale_set_name":                      "Description.VirtualMachineScaleSet.name",
	"sku_capacity":                        "Description.ScaleSetVM.sku.capacity",
	"sku_name":                            "Description.ScaleSetVM.sku.name",
	"sku_tier":                            "Description.ScaleSetVM.sku.tier",
	"subscription":                        "Description.ScaleSetVM.Properties.Subscription",
	"tags":                                "Description.ScaleSetVM.Tags",
	"tags_src":                            "Description.ScaleSetVM.Tags",
	"title":                               "Description.ScaleSetVM.name",
	"type":                                "Description.ScaleSetVM.type",
	"upgrade_policy":                      "Description.VirtualMachineScaleSet.Properties.UpgradePolicy",
	"virtual_machine_diagnostics_profile": "Description.VirtualMachineScaleSet.Properties.VirtualMachineProfile.DiagnosticsProfile",
	"virtual_machine_hardware_profile":    "Description.VirtualMachineScaleSet.Properties.VirtualMachineProfile.HardwareProfile",
	"virtual_machine_network_profile":     "Description.ScaleSetVM.Properties.NetworkProfile.NetworkInterfaces",
	"virtual_machine_network_profile_configuration": "Description.ScaleSetVM.Properties.NetworkProfileConfiguration",
	"virtual_machine_os_profile":                    "Description.VirtualMachineScaleSet.Properties.VirtualMachineProfile.OSProfile",
	"virtual_machine_security_profile":              "Description.VirtualMachineScaleSet.Properties.VirtualMachineProfile.SecurityProfile",
	"virtual_machine_storage_profile":               "Description.VirtualMachineScaleSet.Properties.VirtualMachineProfile.StorageProfile",
	"vm_id":                                         "Description.ScaleSetVM.properties.vmId",
	"zones":                                         "Description.ScaleSetVM.Zones",
}

func ListComputeVirtualMachineScaleSetVm(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeVirtualMachineScaleSetVm")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeVirtualMachineScaleSetVm NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeVirtualMachineScaleSetVm NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeVirtualMachineScaleSetVm GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeVirtualMachineScaleSetVm GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeVirtualMachineScaleSetVm GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewComputeVirtualMachineScaleSetVmPaginator(essdk.BuildFilter(ctx, d.QueryContext, listComputeVirtualMachineScaleSetVmFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeVirtualMachineScaleSetVm NewComputeVirtualMachineScaleSetVmPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListComputeVirtualMachineScaleSetVm paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getComputeVirtualMachineScaleSetVmFilters = map[string]string{
	"additional_capabilities":             "Description.VirtualMachineScaleSet.Properties.AdditionalCapabilities",
	"availability_set":                    "Description.ScaleSetVM.Properties.AvailabilitySet",
	"id":                                  "Description.NetworkInterface.ID",
	"instance_id":                         "description.ScaleSetVM.InstanceID",
	"latest_model_applied":                "Description.VirtualMachineScaleSet.Properties.LatestModelApplied",
	"license_type":                        "Description.VirtualMachineScaleSet.Properties.LicenseType",
	"location":                            "Description.ScaleSetVM.location",
	"model_definition_applied":            "Description.ScaleSetVM.properties.modelDefinitionApplied",
	"name":                                "Description.ScaleSetVM.name",
	"plan":                                "Description.ScaleSetVM.Plan",
	"platform_integration_id":             "IntegrationID",
	"power_state":                         "Description.PowerState",
	"protection_policy":                   "Description.VirtualMachineScaleSet.Properties.SpotRestorePolicy",
	"provisioning_state":                  "Description.VirtualMachineScaleSet.properties.provisioningState",
	"resource_group":                      "description.ResourceGroup",
	"resources":                           "Description.ScaleSetVM.Resources",
	"scale_set_name":                      "description.VirtualMachineScaleSet.name",
	"sku_capacity":                        "Description.ScaleSetVM.sku.capacity",
	"sku_name":                            "Description.ScaleSetVM.sku.name",
	"sku_tier":                            "Description.ScaleSetVM.sku.tier",
	"subscription":                        "Description.ScaleSetVM.Properties.Subscription",
	"tags":                                "Description.ScaleSetVM.Tags",
	"tags_src":                            "Description.ScaleSetVM.Tags",
	"title":                               "Description.ScaleSetVM.name",
	"type":                                "Description.ScaleSetVM.type",
	"upgrade_policy":                      "Description.VirtualMachineScaleSet.Properties.UpgradePolicy",
	"virtual_machine_diagnostics_profile": "Description.VirtualMachineScaleSet.Properties.VirtualMachineProfile.DiagnosticsProfile",
	"virtual_machine_hardware_profile":    "Description.VirtualMachineScaleSet.Properties.VirtualMachineProfile.HardwareProfile",
	"virtual_machine_network_profile":     "Description.ScaleSetVM.Properties.NetworkProfile.NetworkInterfaces",
	"virtual_machine_network_profile_configuration": "Description.ScaleSetVM.Properties.NetworkProfileConfiguration",
	"virtual_machine_os_profile":                    "Description.VirtualMachineScaleSet.Properties.VirtualMachineProfile.OSProfile",
	"virtual_machine_security_profile":              "Description.VirtualMachineScaleSet.Properties.VirtualMachineProfile.SecurityProfile",
	"virtual_machine_storage_profile":               "Description.VirtualMachineScaleSet.Properties.VirtualMachineProfile.StorageProfile",
	"vm_id":                                         "Description.ScaleSetVM.properties.vmId",
	"zones":                                         "Description.ScaleSetVM.Zones",
}

func GetComputeVirtualMachineScaleSetVm(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeVirtualMachineScaleSetVm")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewComputeVirtualMachineScaleSetVmPaginator(essdk.BuildFilter(ctx, d.QueryContext, getComputeVirtualMachineScaleSetVmFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ComputeVirtualMachineScaleSetVm =============================

// ==========================  START: ComputeSnapshots =============================

type ComputeSnapshots struct {
	ResourceID      string                            `json:"resource_id"`
	PlatformID      string                            `json:"platform_id"`
	Description     azure.ComputeSnapshotsDescription `json:"Description"`
	Metadata        azure.Metadata                    `json:"metadata"`
	DescribedBy     string                            `json:"described_by"`
	ResourceType    string                            `json:"resource_type"`
	IntegrationType string                            `json:"integration_type"`
	IntegrationID   string                            `json:"integration_id"`
}

type ComputeSnapshotsHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  ComputeSnapshots `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type ComputeSnapshotsHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []ComputeSnapshotsHit `json:"hits"`
}

type ComputeSnapshotsSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  ComputeSnapshotsHits `json:"hits"`
}

type ComputeSnapshotsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeSnapshotsPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeSnapshotsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_snapshots", filters, limit)
	if err != nil {
		return ComputeSnapshotsPaginator{}, err
	}

	p := ComputeSnapshotsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeSnapshotsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeSnapshotsPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ComputeSnapshotsPaginator) NextPage(ctx context.Context) ([]ComputeSnapshots, error) {
	var response ComputeSnapshotsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeSnapshots
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeSnapshotsFilters = map[string]string{
	"create_option":                         "Description.Snapshot.properties.creationData.createOption",
	"disk_access_id":                        "Description.Snapshot.properties.diskAccessId",
	"disk_encryption_set_id":                "Description.Snapshot.properties.encryption.diskEncryptionSetId",
	"disk_size_bytes":                       "Description.Snapshot.properties.diskSizeBytes",
	"disk_size_gb":                          "Description.Snapshot.properties.diskSizeGB",
	"encryption_setting_collection_enabled": "Description.Snapshot.properties.encryptionSettingsCollection.enabled",
	"encryption_setting_version":            "Description.Snapshot.properties.encryptionSettingsCollection.encryptionSettingsVersion",
	"encryption_settings":                   "Description.Snapshot.Properties.EncryptionSettingsCollection.EncryptionSettings",
	"encryption_type":                       "Description.Snapshot.properties.encryption.type",
	"gallery_image_reference_id":            "Description.Snapshot.properties.creationData.galleryImageReference.id",
	"gallery_reference_lun":                 "Description.Snapshot.properties.creationData.galleryImageReference.lun",
	"hyperv_generation":                     "Description.Snapshot.properties.hyperVGeneration",
	"id":                                    "Description.Snapshot.id",
	"image_reference_id":                    "Description.Snapshot.properties.creationData.imageReference.id",
	"image_reference_lun":                   "Description.Snapshot.properties.creationData.imageReference.lun",
	"incremental":                           "Description.Snapshot.properties.incremental",
	"name":                                  "Description.Snapshot.name",
	"network_access_policy":                 "Description.Snapshot.properties.networkAccessPolicy",
	"os_type":                               "Description.Snapshot.properties.osType",
	"platform_integration_id":               "IntegrationID",
	"provisioning_state":                    "Description.Snapshot.properties.provisioningState",
	"resource_group":                        "Description.ResourceGroup",
	"sku_name":                              "Description.Snapshot.sku.name",
	"sku_tier":                              "Description.Snapshot.sku.tier",
	"source_resource_id":                    "Description.Snapshot.properties.creationData.sourceResourceId",
	"source_unique_id":                      "Description.Snapshot.properties.creationData.sourceUniqueId",
	"source_uri":                            "Description.Snapshot.properties.creationData.sourceUri",
	"storage_account_id":                    "Description.Snapshot.properties.creationData.storageAccountId",
	"subscription":                          "Description.Snapshot.Properties.Subscription",
	"tags":                                  "Description.Snapshot.Tags",
	"title":                                 "Description.Snapshot.name",
	"type":                                  "Description.Snapshot.type",
	"unique_id":                             "Description.Snapshot.properties.uniqueId",
	"upload_size_bytes":                     "Description.Snapshot.properties.creationData.uploadSizeBytes",
}

func ListComputeSnapshots(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeSnapshots")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeSnapshots NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeSnapshots NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeSnapshots GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeSnapshots GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeSnapshots GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewComputeSnapshotsPaginator(essdk.BuildFilter(ctx, d.QueryContext, listComputeSnapshotsFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeSnapshots NewComputeSnapshotsPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListComputeSnapshots paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getComputeSnapshotsFilters = map[string]string{
	"create_option":                         "Description.Snapshot.properties.creationData.createOption",
	"disk_access_id":                        "Description.Snapshot.properties.diskAccessId",
	"disk_encryption_set_id":                "Description.Snapshot.properties.encryption.diskEncryptionSetId",
	"disk_size_bytes":                       "Description.Snapshot.properties.diskSizeBytes",
	"disk_size_gb":                          "Description.Snapshot.properties.diskSizeGB",
	"encryption_setting_collection_enabled": "Description.Snapshot.properties.encryptionSettingsCollection.enabled",
	"encryption_setting_version":            "Description.Snapshot.properties.encryptionSettingsCollection.encryptionSettingsVersion",
	"encryption_settings":                   "Description.Snapshot.Properties.EncryptionSettingsCollection.EncryptionSettings",
	"encryption_type":                       "Description.Snapshot.properties.encryption.type",
	"gallery_image_reference_id":            "Description.Snapshot.properties.creationData.galleryImageReference.id",
	"gallery_reference_lun":                 "Description.Snapshot.properties.creationData.galleryImageReference.lun",
	"hyperv_generation":                     "Description.Snapshot.properties.hyperVGeneration",
	"id":                                    "Description.Snapshot.id",
	"image_reference_id":                    "Description.Snapshot.properties.creationData.imageReference.id",
	"image_reference_lun":                   "Description.Snapshot.properties.creationData.imageReference.lun",
	"incremental":                           "Description.Snapshot.properties.incremental",
	"name":                                  "description.Snapshot.Name",
	"network_access_policy":                 "Description.Snapshot.properties.networkAccessPolicy",
	"os_type":                               "Description.Snapshot.properties.osType",
	"platform_integration_id":               "IntegrationID",
	"provisioning_state":                    "Description.Snapshot.properties.provisioningState",
	"resource_group":                        "description.ResourceGroup",
	"sku_name":                              "Description.Snapshot.sku.name",
	"sku_tier":                              "Description.Snapshot.sku.tier",
	"source_resource_id":                    "Description.Snapshot.properties.creationData.sourceResourceId",
	"source_unique_id":                      "Description.Snapshot.properties.creationData.sourceUniqueId",
	"source_uri":                            "Description.Snapshot.properties.creationData.sourceUri",
	"storage_account_id":                    "Description.Snapshot.properties.creationData.storageAccountId",
	"subscription":                          "Description.Snapshot.Properties.Subscription",
	"tags":                                  "Description.Snapshot.Tags",
	"title":                                 "Description.Snapshot.name",
	"type":                                  "Description.Snapshot.type",
	"unique_id":                             "Description.Snapshot.properties.uniqueId",
	"upload_size_bytes":                     "Description.Snapshot.properties.creationData.uploadSizeBytes",
}

func GetComputeSnapshots(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeSnapshots")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewComputeSnapshotsPaginator(essdk.BuildFilter(ctx, d.QueryContext, getComputeSnapshotsFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ComputeSnapshots =============================

// ==========================  START: ComputeAvailabilitySet =============================

type ComputeAvailabilitySet struct {
	ResourceID      string                                  `json:"resource_id"`
	PlatformID      string                                  `json:"platform_id"`
	Description     azure.ComputeAvailabilitySetDescription `json:"Description"`
	Metadata        azure.Metadata                          `json:"metadata"`
	DescribedBy     string                                  `json:"described_by"`
	ResourceType    string                                  `json:"resource_type"`
	IntegrationType string                                  `json:"integration_type"`
	IntegrationID   string                                  `json:"integration_id"`
}

type ComputeAvailabilitySetHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  ComputeAvailabilitySet `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type ComputeAvailabilitySetHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []ComputeAvailabilitySetHit `json:"hits"`
}

type ComputeAvailabilitySetSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  ComputeAvailabilitySetHits `json:"hits"`
}

type ComputeAvailabilitySetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeAvailabilitySetPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeAvailabilitySetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_availabilitysets", filters, limit)
	if err != nil {
		return ComputeAvailabilitySetPaginator{}, err
	}

	p := ComputeAvailabilitySetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeAvailabilitySetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeAvailabilitySetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ComputeAvailabilitySetPaginator) NextPage(ctx context.Context) ([]ComputeAvailabilitySet, error) {
	var response ComputeAvailabilitySetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeAvailabilitySet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeAvailabilitySetFilters = map[string]string{
	"id":                           "Description.AvailabilitySet.id",
	"name":                         "Description.AvailabilitySet.name",
	"platform_fault_domain_count":  "Description.AvailabilitySet.properties.platformFaultDomainCount",
	"platform_integration_id":      "IntegrationID",
	"platform_update_domain_count": "Description.AvailabilitySet.properties.platformUpdateDomainCount",
	"proximity_placement_group_id": "Description.AvailabilitySet.properties.proximityPlacementGroup.id",
	"resource_group":               "Description.ResourceGroup",
	"sku_capacity":                 "Description.AvailabilitySet.sku.capacity",
	"sku_name":                     "Description.AvailabilitySet.sku.name",
	"sku_tier":                     "Description.AvailabilitySet.sku.tier",
	"status":                       "Description.AvailabilitySet.Properties.Statuses",
	"subscription":                 "Description.AvailabilitySet.Properties.Subscription",
	"tags":                         "Description.AvailabilitySet.Tags",
	"title":                        "Description.AvailabilitySet.name",
	"type":                         "Description.AvailabilitySet.type",
	"virtual_machines":             "Description.AvailabilitySet.Properties.VirtualMachines",
}

func ListComputeAvailabilitySet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeAvailabilitySet")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeAvailabilitySet NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeAvailabilitySet NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeAvailabilitySet GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeAvailabilitySet GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeAvailabilitySet GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewComputeAvailabilitySetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listComputeAvailabilitySetFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeAvailabilitySet NewComputeAvailabilitySetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListComputeAvailabilitySet paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getComputeAvailabilitySetFilters = map[string]string{
	"id":                           "Description.AvailabilitySet.id",
	"name":                         "description.AvailabilitySet.Name",
	"platform_fault_domain_count":  "Description.AvailabilitySet.properties.platformFaultDomainCount",
	"platform_integration_id":      "IntegrationID",
	"platform_update_domain_count": "Description.AvailabilitySet.properties.platformUpdateDomainCount",
	"proximity_placement_group_id": "Description.AvailabilitySet.properties.proximityPlacementGroup.id",
	"resource_group":               "description.ResourceGroup",
	"sku_capacity":                 "Description.AvailabilitySet.sku.capacity",
	"sku_name":                     "Description.AvailabilitySet.sku.name",
	"sku_tier":                     "Description.AvailabilitySet.sku.tier",
	"status":                       "Description.AvailabilitySet.Properties.Statuses",
	"subscription":                 "Description.AvailabilitySet.Properties.Subscription",
	"tags":                         "Description.AvailabilitySet.Tags",
	"title":                        "Description.AvailabilitySet.name",
	"type":                         "Description.AvailabilitySet.type",
	"virtual_machines":             "Description.AvailabilitySet.Properties.VirtualMachines",
}

func GetComputeAvailabilitySet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeAvailabilitySet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewComputeAvailabilitySetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getComputeAvailabilitySetFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ComputeAvailabilitySet =============================

// ==========================  START: ComputeDiskEncryptionSet =============================

type ComputeDiskEncryptionSet struct {
	ResourceID      string                                    `json:"resource_id"`
	PlatformID      string                                    `json:"platform_id"`
	Description     azure.ComputeDiskEncryptionSetDescription `json:"Description"`
	Metadata        azure.Metadata                            `json:"metadata"`
	DescribedBy     string                                    `json:"described_by"`
	ResourceType    string                                    `json:"resource_type"`
	IntegrationType string                                    `json:"integration_type"`
	IntegrationID   string                                    `json:"integration_id"`
}

type ComputeDiskEncryptionSetHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  ComputeDiskEncryptionSet `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type ComputeDiskEncryptionSetHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []ComputeDiskEncryptionSetHit `json:"hits"`
}

type ComputeDiskEncryptionSetSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  ComputeDiskEncryptionSetHits `json:"hits"`
}

type ComputeDiskEncryptionSetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeDiskEncryptionSetPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeDiskEncryptionSetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_diskencryptionsets", filters, limit)
	if err != nil {
		return ComputeDiskEncryptionSetPaginator{}, err
	}

	p := ComputeDiskEncryptionSetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeDiskEncryptionSetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeDiskEncryptionSetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ComputeDiskEncryptionSetPaginator) NextPage(ctx context.Context) ([]ComputeDiskEncryptionSet, error) {
	var response ComputeDiskEncryptionSetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeDiskEncryptionSet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeDiskEncryptionSetFilters = map[string]string{
	"active_key_source_vault_id": "Description.DiskEncryptionSet.properties.activeKey.sourceVault.id",
	"active_key_url":             "Description.DiskEncryptionSet.properties.activeKey.keyUrl",
	"encryption_type":            "Description.DiskEncryptionSet.properties.encryptionType",
	"id":                         "Description.DiskEncryptionSet.id",
	"identity_principal_id":      "Description.DiskEncryptionSet.identity.principalId",
	"identity_tenant_id":         "Description.DiskEncryptionSet.identity.tenantId",
	"identity_type":              "Description.DiskEncryptionSet.identity.type",
	"name":                       "Description.DiskEncryptionSet.name",
	"platform_integration_id":    "IntegrationID",
	"previous_keys":              "Description.DiskEncryptionSet.Properties.PreviousKeys",
	"provisioning_state":         "Description.DiskEncryptionSet.properties.provisioningState",
	"resource_group":             "Description.ResourceGroup",
	"subscription":               "Description.DiskEncryptionSet.Properties.Subscription",
	"tags":                       "Description.DiskEncryptionSet.Tags",
	"title":                      "Description.DiskEncryptionSet.name",
	"type":                       "Description.DiskEncryptionSet.type",
}

func ListComputeDiskEncryptionSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeDiskEncryptionSet")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeDiskEncryptionSet NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeDiskEncryptionSet NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeDiskEncryptionSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeDiskEncryptionSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeDiskEncryptionSet GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewComputeDiskEncryptionSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listComputeDiskEncryptionSetFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeDiskEncryptionSet NewComputeDiskEncryptionSetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListComputeDiskEncryptionSet paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getComputeDiskEncryptionSetFilters = map[string]string{
	"active_key_source_vault_id": "Description.DiskEncryptionSet.properties.activeKey.sourceVault.id",
	"active_key_url":             "Description.DiskEncryptionSet.properties.activeKey.keyUrl",
	"encryption_type":            "Description.DiskEncryptionSet.properties.encryptionType",
	"id":                         "Description.DiskEncryptionSet.id",
	"identity_principal_id":      "Description.DiskEncryptionSet.identity.principalId",
	"identity_tenant_id":         "Description.DiskEncryptionSet.identity.tenantId",
	"identity_type":              "Description.DiskEncryptionSet.identity.type",
	"name":                       "description.DiskEncryptionSet.Name",
	"platform_integration_id":    "IntegrationID",
	"previous_keys":              "Description.DiskEncryptionSet.Properties.PreviousKeys",
	"provisioning_state":         "Description.DiskEncryptionSet.properties.provisioningState",
	"resource_group":             "description.ResourceGroup",
	"subscription":               "Description.DiskEncryptionSet.Properties.Subscription",
	"tags":                       "Description.DiskEncryptionSet.Tags",
	"title":                      "Description.DiskEncryptionSet.name",
	"type":                       "Description.DiskEncryptionSet.type",
}

func GetComputeDiskEncryptionSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeDiskEncryptionSet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewComputeDiskEncryptionSetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getComputeDiskEncryptionSetFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ComputeDiskEncryptionSet =============================

// ==========================  START: ComputeImageGallery =============================

type ComputeImageGallery struct {
	ResourceID      string                               `json:"resource_id"`
	PlatformID      string                               `json:"platform_id"`
	Description     azure.ComputeImageGalleryDescription `json:"Description"`
	Metadata        azure.Metadata                       `json:"metadata"`
	DescribedBy     string                               `json:"described_by"`
	ResourceType    string                               `json:"resource_type"`
	IntegrationType string                               `json:"integration_type"`
	IntegrationID   string                               `json:"integration_id"`
}

type ComputeImageGalleryHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  ComputeImageGallery `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type ComputeImageGalleryHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []ComputeImageGalleryHit `json:"hits"`
}

type ComputeImageGallerySearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  ComputeImageGalleryHits `json:"hits"`
}

type ComputeImageGalleryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeImageGalleryPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeImageGalleryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_galleries", filters, limit)
	if err != nil {
		return ComputeImageGalleryPaginator{}, err
	}

	p := ComputeImageGalleryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeImageGalleryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeImageGalleryPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ComputeImageGalleryPaginator) NextPage(ctx context.Context) ([]ComputeImageGallery, error) {
	var response ComputeImageGallerySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeImageGallery
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeImageGalleryFilters = map[string]string{
	"id":                      "Description.ImageGallery.id",
	"name":                    "Description.ImageGallery.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.ImageGallery.Properties.Subscription",
	"tags":                    "Description.ImageGallery.Tags",
	"title":                   "Description.ImageGallery.name",
}

func ListComputeImageGallery(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeImageGallery")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeImageGallery NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeImageGallery NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeImageGallery GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeImageGallery GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeImageGallery GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewComputeImageGalleryPaginator(essdk.BuildFilter(ctx, d.QueryContext, listComputeImageGalleryFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeImageGallery NewComputeImageGalleryPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListComputeImageGallery paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getComputeImageGalleryFilters = map[string]string{
	"id":                      "Description.ImageGallery.id",
	"name":                    "description.ImageGallery.Name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "description.ResourceGroup",
	"subscription":            "Description.ImageGallery.Properties.Subscription",
	"tags":                    "Description.ImageGallery.Tags",
	"title":                   "Description.ImageGallery.name",
}

func GetComputeImageGallery(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeImageGallery")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewComputeImageGalleryPaginator(essdk.BuildFilter(ctx, d.QueryContext, getComputeImageGalleryFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ComputeImageGallery =============================

// ==========================  START: ComputeImage =============================

type ComputeImage struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     azure.ComputeImageDescription `json:"Description"`
	Metadata        azure.Metadata                `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type ComputeImageHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ComputeImage  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ComputeImageHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ComputeImageHit `json:"hits"`
}

type ComputeImageSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  ComputeImageHits `json:"hits"`
}

type ComputeImagePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeImagePaginator(filters []essdk.BoolFilter, limit *int64) (ComputeImagePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_images", filters, limit)
	if err != nil {
		return ComputeImagePaginator{}, err
	}

	p := ComputeImagePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeImagePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeImagePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ComputeImagePaginator) NextPage(ctx context.Context) ([]ComputeImage, error) {
	var response ComputeImageSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeImage
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeImageFilters = map[string]string{
	"hyper_v_generation":                           "Description.Image.properties.hyperVGeneration",
	"id":                                           "Description.Image.id",
	"name":                                         "Description.Image.name",
	"platform_integration_id":                      "IntegrationID",
	"provisioning_state":                           "Description.Image.properties.provisioningState",
	"resource_group":                               "Description.ResourceGroup",
	"source_virtual_machine_id":                    "Description.Image.properties.sourceVirtualMachine.id",
	"storage_profile_data_disks":                   "Description.Image.Properties.StorageProfile.DataDisks",
	"storage_profile_os_disk_blob_uri":             "Description.Image.properties.storageProfile.osDisk.blobUri",
	"storage_profile_os_disk_caching":              "Description.Image.properties.storageProfile.osDisk.caching",
	"storage_profile_os_disk_encryption_set":       "Description.Image.properties.storageProfile.osDisk.diskEncryptionSet.id",
	"storage_profile_os_disk_managed_disk_id":      "Description.Image.properties.storageProfile.osDisk.managedDisk.id",
	"storage_profile_os_disk_size_gb":              "Description.Image.properties.storageProfile.osDisk.diskSizeGB",
	"storage_profile_os_disk_snapshot_id":          "Description.Image.properties.storageProfile.osDisk.snapshot.id",
	"storage_profile_os_disk_state":                "Description.Image.properties.storageProfile.osDisk.osState",
	"storage_profile_os_disk_storage_account_type": "Description.Image.properties.storageProfile.osDisk.storageAccountType",
	"storage_profile_os_disk_type":                 "Description.Image.properties.storageProfile.osDisk.osType",
	"storage_profile_zone_resilient":               "Description.Image.properties.storageProfile.zoneResilient",
	"subscription":                                 "Description.Image.Properties.Subscription",
	"tags":                                         "Description.Image.Tags",
	"title":                                        "Description.Image.name",
	"type":                                         "Description.Image.type",
}

func ListComputeImage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeImage")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeImage NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeImage NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeImage GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeImage GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeImage GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewComputeImagePaginator(essdk.BuildFilter(ctx, d.QueryContext, listComputeImageFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeImage NewComputeImagePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListComputeImage paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getComputeImageFilters = map[string]string{
	"hyper_v_generation":                           "Description.Image.properties.hyperVGeneration",
	"id":                                           "Description.Image.id",
	"name":                                         "Description.Image.Name",
	"platform_integration_id":                      "IntegrationID",
	"provisioning_state":                           "Description.Image.properties.provisioningState",
	"resource_group":                               "Description.Image.ResourceGroup",
	"source_virtual_machine_id":                    "Description.Image.properties.sourceVirtualMachine.id",
	"storage_profile_data_disks":                   "Description.Image.Properties.StorageProfile.DataDisks",
	"storage_profile_os_disk_blob_uri":             "Description.Image.properties.storageProfile.osDisk.blobUri",
	"storage_profile_os_disk_caching":              "Description.Image.properties.storageProfile.osDisk.caching",
	"storage_profile_os_disk_encryption_set":       "Description.Image.properties.storageProfile.osDisk.diskEncryptionSet.id",
	"storage_profile_os_disk_managed_disk_id":      "Description.Image.properties.storageProfile.osDisk.managedDisk.id",
	"storage_profile_os_disk_size_gb":              "Description.Image.properties.storageProfile.osDisk.diskSizeGB",
	"storage_profile_os_disk_snapshot_id":          "Description.Image.properties.storageProfile.osDisk.snapshot.id",
	"storage_profile_os_disk_state":                "Description.Image.properties.storageProfile.osDisk.osState",
	"storage_profile_os_disk_storage_account_type": "Description.Image.properties.storageProfile.osDisk.storageAccountType",
	"storage_profile_os_disk_type":                 "Description.Image.properties.storageProfile.osDisk.osType",
	"storage_profile_zone_resilient":               "Description.Image.properties.storageProfile.zoneResilient",
	"subscription":                                 "Description.Image.Properties.Subscription",
	"tags":                                         "Description.Image.Tags",
	"title":                                        "Description.Image.name",
	"type":                                         "Description.Image.type",
}

func GetComputeImage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeImage")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewComputeImagePaginator(essdk.BuildFilter(ctx, d.QueryContext, getComputeImageFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ComputeImage =============================

// ==========================  START: ComputeHostGroup =============================

type ComputeHostGroup struct {
	ResourceID      string                            `json:"resource_id"`
	PlatformID      string                            `json:"platform_id"`
	Description     azure.ComputeHostGroupDescription `json:"Description"`
	Metadata        azure.Metadata                    `json:"metadata"`
	DescribedBy     string                            `json:"described_by"`
	ResourceType    string                            `json:"resource_type"`
	IntegrationType string                            `json:"integration_type"`
	IntegrationID   string                            `json:"integration_id"`
}

type ComputeHostGroupHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  ComputeHostGroup `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type ComputeHostGroupHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []ComputeHostGroupHit `json:"hits"`
}

type ComputeHostGroupSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  ComputeHostGroupHits `json:"hits"`
}

type ComputeHostGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeHostGroupPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeHostGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_hostgroups", filters, limit)
	if err != nil {
		return ComputeHostGroupPaginator{}, err
	}

	p := ComputeHostGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeHostGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeHostGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ComputeHostGroupPaginator) NextPage(ctx context.Context) ([]ComputeHostGroup, error) {
	var response ComputeHostGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeHostGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeHostGroupFilters = map[string]string{
	"id":           "Description.HostGroup.id",
	"name":         "Description.HostGroup.name",
	"subscription": "Description.HostGroup.Properties.Subscription",
	"tags":         "Description.HostGroup.Tags",
	"title":        "Description.HostGroup.name",
}

func ListComputeHostGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeHostGroup")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeHostGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeHostGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeHostGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeHostGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeHostGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewComputeHostGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listComputeHostGroupFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeHostGroup NewComputeHostGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListComputeHostGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getComputeHostGroupFilters = map[string]string{
	"id":           "Description.HostGroup.id",
	"name":         "Description.HostGroup.name",
	"subscription": "Description.HostGroup.Properties.Subscription",
	"tags":         "Description.HostGroup.Tags",
	"title":        "Description.HostGroup.name",
}

func GetComputeHostGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeHostGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewComputeHostGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getComputeHostGroupFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ComputeHostGroup =============================

// ==========================  START: ComputeHostGroupHost =============================

type ComputeHostGroupHost struct {
	ResourceID      string                                `json:"resource_id"`
	PlatformID      string                                `json:"platform_id"`
	Description     azure.ComputeHostGroupHostDescription `json:"Description"`
	Metadata        azure.Metadata                        `json:"metadata"`
	DescribedBy     string                                `json:"described_by"`
	ResourceType    string                                `json:"resource_type"`
	IntegrationType string                                `json:"integration_type"`
	IntegrationID   string                                `json:"integration_id"`
}

type ComputeHostGroupHostHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  ComputeHostGroupHost `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type ComputeHostGroupHostHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []ComputeHostGroupHostHit `json:"hits"`
}

type ComputeHostGroupHostSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  ComputeHostGroupHostHits `json:"hits"`
}

type ComputeHostGroupHostPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeHostGroupHostPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeHostGroupHostPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_hostgroups_hosts", filters, limit)
	if err != nil {
		return ComputeHostGroupHostPaginator{}, err
	}

	p := ComputeHostGroupHostPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeHostGroupHostPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeHostGroupHostPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ComputeHostGroupHostPaginator) NextPage(ctx context.Context) ([]ComputeHostGroupHost, error) {
	var response ComputeHostGroupHostSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeHostGroupHost
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeHostGroupHostFilters = map[string]string{
	"id":           "Description.Host.id",
	"name":         "Description.Host.name",
	"subscription": "Description.Host.Properties.Subscription",
	"tags":         "Description.Host.Tags",
	"title":        "Description.Host.name",
}

func ListComputeHostGroupHost(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeHostGroupHost")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeHostGroupHost NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeHostGroupHost NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeHostGroupHost GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeHostGroupHost GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeHostGroupHost GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewComputeHostGroupHostPaginator(essdk.BuildFilter(ctx, d.QueryContext, listComputeHostGroupHostFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeHostGroupHost NewComputeHostGroupHostPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListComputeHostGroupHost paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getComputeHostGroupHostFilters = map[string]string{
	"id":           "Description.Host.id",
	"name":         "Description.Host.name",
	"subscription": "Description.Host.Properties.Subscription",
	"tags":         "Description.Host.Tags",
	"title":        "Description.Host.name",
}

func GetComputeHostGroupHost(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeHostGroupHost")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewComputeHostGroupHostPaginator(essdk.BuildFilter(ctx, d.QueryContext, getComputeHostGroupHostFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ComputeHostGroupHost =============================

// ==========================  START: ComputeRestorePointCollection =============================

type ComputeRestorePointCollection struct {
	ResourceID      string                                         `json:"resource_id"`
	PlatformID      string                                         `json:"platform_id"`
	Description     azure.ComputeRestorePointCollectionDescription `json:"Description"`
	Metadata        azure.Metadata                                 `json:"metadata"`
	DescribedBy     string                                         `json:"described_by"`
	ResourceType    string                                         `json:"resource_type"`
	IntegrationType string                                         `json:"integration_type"`
	IntegrationID   string                                         `json:"integration_id"`
}

type ComputeRestorePointCollectionHit struct {
	ID      string                        `json:"_id"`
	Score   float64                       `json:"_score"`
	Index   string                        `json:"_index"`
	Type    string                        `json:"_type"`
	Version int64                         `json:"_version,omitempty"`
	Source  ComputeRestorePointCollection `json:"_source"`
	Sort    []interface{}                 `json:"sort"`
}

type ComputeRestorePointCollectionHits struct {
	Total essdk.SearchTotal                  `json:"total"`
	Hits  []ComputeRestorePointCollectionHit `json:"hits"`
}

type ComputeRestorePointCollectionSearchResponse struct {
	PitID string                            `json:"pit_id"`
	Hits  ComputeRestorePointCollectionHits `json:"hits"`
}

type ComputeRestorePointCollectionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeRestorePointCollectionPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeRestorePointCollectionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_restorepointcollections", filters, limit)
	if err != nil {
		return ComputeRestorePointCollectionPaginator{}, err
	}

	p := ComputeRestorePointCollectionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeRestorePointCollectionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeRestorePointCollectionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ComputeRestorePointCollectionPaginator) NextPage(ctx context.Context) ([]ComputeRestorePointCollection, error) {
	var response ComputeRestorePointCollectionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeRestorePointCollection
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeRestorePointCollectionFilters = map[string]string{
	"id":           "Description.RestorePointCollection.id",
	"name":         "Description.RestorePointCollection.name",
	"subscription": "Description.RestorePointCollection.Properties.Subscription",
	"tags":         "Description.RestorePointCollection.Tags",
	"title":        "Description.RestorePointCollection.name",
}

func ListComputeRestorePointCollection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeRestorePointCollection")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeRestorePointCollection NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeRestorePointCollection NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeRestorePointCollection GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeRestorePointCollection GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeRestorePointCollection GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewComputeRestorePointCollectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listComputeRestorePointCollectionFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeRestorePointCollection NewComputeRestorePointCollectionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListComputeRestorePointCollection paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getComputeRestorePointCollectionFilters = map[string]string{
	"id":           "Description.RestorePointCollection.id",
	"name":         "Description.RestorePointCollection.name",
	"subscription": "Description.RestorePointCollection.Properties.Subscription",
	"tags":         "Description.RestorePointCollection.Tags",
	"title":        "Description.RestorePointCollection.name",
}

func GetComputeRestorePointCollection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeRestorePointCollection")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewComputeRestorePointCollectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getComputeRestorePointCollectionFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ComputeRestorePointCollection =============================

// ==========================  START: ComputeSSHPublicKey =============================

type ComputeSSHPublicKey struct {
	ResourceID      string                               `json:"resource_id"`
	PlatformID      string                               `json:"platform_id"`
	Description     azure.ComputeSSHPublicKeyDescription `json:"Description"`
	Metadata        azure.Metadata                       `json:"metadata"`
	DescribedBy     string                               `json:"described_by"`
	ResourceType    string                               `json:"resource_type"`
	IntegrationType string                               `json:"integration_type"`
	IntegrationID   string                               `json:"integration_id"`
}

type ComputeSSHPublicKeyHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  ComputeSSHPublicKey `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type ComputeSSHPublicKeyHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []ComputeSSHPublicKeyHit `json:"hits"`
}

type ComputeSSHPublicKeySearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  ComputeSSHPublicKeyHits `json:"hits"`
}

type ComputeSSHPublicKeyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeSSHPublicKeyPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeSSHPublicKeyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_sshpublickeys", filters, limit)
	if err != nil {
		return ComputeSSHPublicKeyPaginator{}, err
	}

	p := ComputeSSHPublicKeyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeSSHPublicKeyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeSSHPublicKeyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ComputeSSHPublicKeyPaginator) NextPage(ctx context.Context) ([]ComputeSSHPublicKey, error) {
	var response ComputeSSHPublicKeySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeSSHPublicKey
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeSSHPublicKeyFilters = map[string]string{
	"id":             "Description.SSHPublicKey.id",
	"name":           "Description.SSHPublicKey.name",
	"public_key":     "Description.SSHPublicKey.properties.publicKey",
	"resource_group": "Description.ResourceGroup",
	"subscription":   "Description.SSHPublicKey.Properties.Subscription",
	"tags":           "Description.SSHPublicKey.Tags",
	"title":          "Description.SSHPublicKey.name",
	"type":           "Description.SSHPublicKey.type",
}

func ListComputeSSHPublicKey(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeSSHPublicKey")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeSSHPublicKey NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeSSHPublicKey NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeSSHPublicKey GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeSSHPublicKey GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeSSHPublicKey GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewComputeSSHPublicKeyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listComputeSSHPublicKeyFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeSSHPublicKey NewComputeSSHPublicKeyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListComputeSSHPublicKey paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getComputeSSHPublicKeyFilters = map[string]string{
	"id":             "Description.SSHPublicKey.id",
	"name":           "Description.SSHPublicKey.name",
	"public_key":     "Description.SSHPublicKey.properties.publicKey",
	"resource_group": "Description.ResourceGroup",
	"subscription":   "Description.SSHPublicKey.Properties.Subscription",
	"tags":           "Description.SSHPublicKey.Tags",
	"title":          "Description.SSHPublicKey.name",
	"type":           "Description.SSHPublicKey.type",
}

func GetComputeSSHPublicKey(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeSSHPublicKey")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewComputeSSHPublicKeyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getComputeSSHPublicKeyFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ComputeSSHPublicKey =============================

// ==========================  START: DataboxEdgeDevice =============================

type DataboxEdgeDevice struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     azure.DataboxEdgeDeviceDescription `json:"Description"`
	Metadata        azure.Metadata                     `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type DataboxEdgeDeviceHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  DataboxEdgeDevice `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type DataboxEdgeDeviceHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []DataboxEdgeDeviceHit `json:"hits"`
}

type DataboxEdgeDeviceSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  DataboxEdgeDeviceHits `json:"hits"`
}

type DataboxEdgeDevicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDataboxEdgeDevicePaginator(filters []essdk.BoolFilter, limit *int64) (DataboxEdgeDevicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_databoxedge_databoxedgedevices", filters, limit)
	if err != nil {
		return DataboxEdgeDevicePaginator{}, err
	}

	p := DataboxEdgeDevicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DataboxEdgeDevicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DataboxEdgeDevicePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DataboxEdgeDevicePaginator) NextPage(ctx context.Context) ([]DataboxEdgeDevice, error) {
	var response DataboxEdgeDeviceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DataboxEdgeDevice
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDataboxEdgeDeviceFilters = map[string]string{
	"configured_role_types":       "Description.Device.Properties.ConfiguredRoleTypes",
	"culture":                     "Description.Device.properties.culture",
	"data_box_edge_device_status": "Description.Device.properties.dataBoxEdgeDeviceStatus",
	"description":                 "Description.Device.properties.description",
	"device_hcs_version":          "Description.Device.properties.deviceHcsVersion",
	"device_local_capacity":       "Description.Device.properties.deviceLocalCapacity",
	"device_model":                "Description.Device.properties.deviceModel",
	"device_software_version":     "Description.Device.properties.deviceSoftwareVersion",
	"device_type":                 "Description.Device.properties.deviceType",
	"etag":                        "Description.Device.etag",
	"friendly_name":               "Description.Device.properties.friendlyName",
	"id":                          "Description.Device.id",
	"location":                    "Description.Device.location",
	"model_description":           "Description.Device.properties.modelDescription",
	"name":                        "Description.Device.name",
	"node_count":                  "Description.Device.properties.nodeCount",
	"platform_integration_id":     "IntegrationID",
	"resource_group":              "Description.ResourceGroup",
	"serial_number":               "Description.Device.properties.serialNumber",
	"sku_name":                    "Description.Device.sku.name",
	"sku_tier":                    "Description.Device.sku.tier",
	"subscription":                "Description.Device.Properties.Subscription",
	"tags":                        "Description.Device.Tags",
	"time_zone":                   "Description.Device.properties.timeZone",
	"title":                       "Description.Device.name",
	"type":                        "Description.Device.type",
}

func ListDataboxEdgeDevice(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDataboxEdgeDevice")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataboxEdgeDevice NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataboxEdgeDevice NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataboxEdgeDevice GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataboxEdgeDevice GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataboxEdgeDevice GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDataboxEdgeDevicePaginator(essdk.BuildFilter(ctx, d.QueryContext, listDataboxEdgeDeviceFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataboxEdgeDevice NewDataboxEdgeDevicePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDataboxEdgeDevice paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDataboxEdgeDeviceFilters = map[string]string{
	"configured_role_types":       "Description.Device.Properties.ConfiguredRoleTypes",
	"culture":                     "Description.Device.properties.culture",
	"data_box_edge_device_status": "Description.Device.properties.dataBoxEdgeDeviceStatus",
	"description":                 "Description.Device.properties.description",
	"device_hcs_version":          "Description.Device.properties.deviceHcsVersion",
	"device_local_capacity":       "Description.Device.properties.deviceLocalCapacity",
	"device_model":                "Description.Device.properties.deviceModel",
	"device_software_version":     "Description.Device.properties.deviceSoftwareVersion",
	"device_type":                 "Description.Device.properties.deviceType",
	"etag":                        "Description.Device.etag",
	"friendly_name":               "Description.Device.properties.friendlyName",
	"id":                          "Description.Device.id",
	"location":                    "Description.Device.location",
	"model_description":           "Description.Device.properties.modelDescription",
	"name":                        "description.Device.name",
	"node_count":                  "Description.Device.properties.nodeCount",
	"platform_integration_id":     "IntegrationID",
	"resource_group":              "description.ResourceGroup",
	"serial_number":               "Description.Device.properties.serialNumber",
	"sku_name":                    "Description.Device.sku.name",
	"sku_tier":                    "Description.Device.sku.tier",
	"subscription":                "Description.Device.Properties.Subscription",
	"tags":                        "Description.Device.Tags",
	"time_zone":                   "Description.Device.properties.timeZone",
	"title":                       "Description.Device.name",
	"type":                        "Description.Device.type",
}

func GetDataboxEdgeDevice(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDataboxEdgeDevice")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDataboxEdgeDevicePaginator(essdk.BuildFilter(ctx, d.QueryContext, getDataboxEdgeDeviceFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DataboxEdgeDevice =============================

// ==========================  START: HealthcareService =============================

type HealthcareService struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     azure.HealthcareServiceDescription `json:"Description"`
	Metadata        azure.Metadata                     `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type HealthcareServiceHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  HealthcareService `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type HealthcareServiceHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []HealthcareServiceHit `json:"hits"`
}

type HealthcareServiceSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  HealthcareServiceHits `json:"hits"`
}

type HealthcareServicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewHealthcareServicePaginator(filters []essdk.BoolFilter, limit *int64) (HealthcareServicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_healthcareapis_services", filters, limit)
	if err != nil {
		return HealthcareServicePaginator{}, err
	}

	p := HealthcareServicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p HealthcareServicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p HealthcareServicePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p HealthcareServicePaginator) NextPage(ctx context.Context) ([]HealthcareService, error) {
	var response HealthcareServiceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []HealthcareService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listHealthcareServiceFilters = map[string]string{
	"access_policies":              "Description.ServicesDescription.Properties.AccessPolicies",
	"allow_credentials":            "Description.ServicesDescription.properties.corsConfiguration.allowCredentials",
	"audience":                     "Description.ServicesDescription.properties.authenticationConfiguration.audience",
	"authority":                    "Description.ServicesDescription.properties.authenticationConfiguration.authority",
	"cosmos_db_configuration":      "Description.ServicesDescription.Properties.CosmosDbConfiguration",
	"diagnostic_settings":          "Description.DiagnosticSettingsResources",
	"etag":                         "Description.ServicesDescription.etag",
	"headers":                      "Description.ServicesDescription.Properties.CorsConfiguration.Origins",
	"id":                           "Description.ServicesDescription.id",
	"kind":                         "Description.ServicesDescription.kind",
	"location":                     "Description.ServicesDescription.location",
	"max_age":                      "Description.ServicesDescription.properties.corsConfiguration.maxAge",
	"methods":                      "Description.ServicesDescription.Properties.CorsConfiguration.Methods",
	"name":                         "Description.ServicesDescription.name",
	"origins":                      "Description.ServicesDescription.Properties.CorsConfiguration.Origins",
	"platform_integration_id":      "IntegrationID",
	"private_endpoint_connections": "Description.ServicesDescription.Properties.PrivateEndpointConnections",
	"provisioning_state":           "Description.ServicesDescription.properties.provisioningState",
	"resource_group":               "Description.ResourceGroup",
	"smart_proxy_enabled":          "Description.ServicesDescription.properties.authenticationConfiguration.smartProxyEnabled",
	"subscription":                 "Description.ServicesDescription.Properties.Subscription",
	"tags":                         "Description.ServicesDescription.Tags",
	"title":                        "Description.ServicesDescription.name",
	"type":                         "Description.ServicesDescription.type",
}

func ListHealthcareService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListHealthcareService")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListHealthcareService NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListHealthcareService NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListHealthcareService GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListHealthcareService GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListHealthcareService GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewHealthcareServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, listHealthcareServiceFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListHealthcareService NewHealthcareServicePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListHealthcareService paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getHealthcareServiceFilters = map[string]string{
	"access_policies":              "Description.ServicesDescription.Properties.AccessPolicies",
	"allow_credentials":            "Description.ServicesDescription.properties.corsConfiguration.allowCredentials",
	"audience":                     "Description.ServicesDescription.properties.authenticationConfiguration.audience",
	"authority":                    "Description.ServicesDescription.properties.authenticationConfiguration.authority",
	"cosmos_db_configuration":      "Description.ServicesDescription.Properties.CosmosDbConfiguration",
	"diagnostic_settings":          "Description.DiagnosticSettingsResources",
	"etag":                         "Description.ServicesDescription.etag",
	"headers":                      "Description.ServicesDescription.Properties.CorsConfiguration.Origins",
	"id":                           "Description.ServicesDescription.id",
	"kind":                         "Description.ServicesDescription.kind",
	"location":                     "Description.ServicesDescription.location",
	"max_age":                      "Description.ServicesDescription.properties.corsConfiguration.maxAge",
	"methods":                      "Description.ServicesDescription.Properties.CorsConfiguration.Methods",
	"name":                         "description.ServicesDescription.name",
	"origins":                      "Description.ServicesDescription.Properties.CorsConfiguration.Origins",
	"platform_integration_id":      "IntegrationID",
	"private_endpoint_connections": "Description.ServicesDescription.Properties.PrivateEndpointConnections",
	"provisioning_state":           "Description.ServicesDescription.properties.provisioningState",
	"resource_group":               "description.ResourceGroup",
	"smart_proxy_enabled":          "Description.ServicesDescription.properties.authenticationConfiguration.smartProxyEnabled",
	"subscription":                 "Description.ServicesDescription.Properties.Subscription",
	"tags":                         "Description.ServicesDescription.Tags",
	"title":                        "Description.ServicesDescription.name",
	"type":                         "Description.ServicesDescription.type",
}

func GetHealthcareService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetHealthcareService")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewHealthcareServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, getHealthcareServiceFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: HealthcareService =============================

// ==========================  START: HpcCache =============================

type HpcCache struct {
	ResourceID      string                    `json:"resource_id"`
	PlatformID      string                    `json:"platform_id"`
	Description     azure.HpcCacheDescription `json:"Description"`
	Metadata        azure.Metadata            `json:"metadata"`
	DescribedBy     string                    `json:"described_by"`
	ResourceType    string                    `json:"resource_type"`
	IntegrationType string                    `json:"integration_type"`
	IntegrationID   string                    `json:"integration_id"`
}

type HpcCacheHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  HpcCache      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type HpcCacheHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []HpcCacheHit     `json:"hits"`
}

type HpcCacheSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  HpcCacheHits `json:"hits"`
}

type HpcCachePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewHpcCachePaginator(filters []essdk.BoolFilter, limit *int64) (HpcCachePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_storagecache_caches", filters, limit)
	if err != nil {
		return HpcCachePaginator{}, err
	}

	p := HpcCachePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p HpcCachePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p HpcCachePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p HpcCachePaginator) NextPage(ctx context.Context) ([]HpcCache, error) {
	var response HpcCacheSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []HpcCache
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listHpcCacheFilters = map[string]string{
	"cache_size_gb":               "Description.Cache.properties.cacheSizeGB",
	"directory_services_settings": "Description.Cache.Properties.DirectoryServicesSettings",
	"encryption_settings":         "Description.Cache.Properties.EncryptionSettings",
	"health":                      "Description.Cache.Properties.Health",
	"id":                          "Description.Cache.id",
	"identity":                    "Description.Cache.Identity",
	"mount_addresses":             "Description.Cache.Properties.MountAddresses",
	"name":                        "Description.Cache.name",
	"platform_integration_id":     "IntegrationID",
	"provisioning_state":          "Description.Cache.properties.provisioningState",
	"resource_group":              "Description.ResourceGroup",
	"security_settings":           "Description.Cache.Properties.SecuritySettings",
	"sku_name":                    "Description.Cache.sku.name",
	"subnet":                      "Description.Cache.properties.subnet",
	"subscription":                "Description.Cache.Properties.Subscription",
	"system_data":                 "Description.Cache.SystemData",
	"tags":                        "Description.Cache.Tags",
	"title":                       "Description.Cache.name",
	"type":                        "Description.Cache.type",
}

func ListHpcCache(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListHpcCache")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListHpcCache NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListHpcCache NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListHpcCache GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListHpcCache GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListHpcCache GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewHpcCachePaginator(essdk.BuildFilter(ctx, d.QueryContext, listHpcCacheFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListHpcCache NewHpcCachePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListHpcCache paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getHpcCacheFilters = map[string]string{
	"cache_size_gb":               "Description.Cache.properties.cacheSizeGB",
	"directory_services_settings": "Description.Cache.Properties.DirectoryServicesSettings",
	"encryption_settings":         "Description.Cache.Properties.EncryptionSettings",
	"health":                      "Description.Cache.Properties.Health",
	"id":                          "Description.Cache.id",
	"identity":                    "Description.Cache.Identity",
	"mount_addresses":             "Description.Cache.Properties.MountAddresses",
	"name":                        "description.Cache.name",
	"platform_integration_id":     "IntegrationID",
	"provisioning_state":          "Description.Cache.properties.provisioningState",
	"resource_group":              "description.ResourceGroup",
	"security_settings":           "Description.Cache.Properties.SecuritySettings",
	"sku_name":                    "Description.Cache.sku.name",
	"subnet":                      "Description.Cache.properties.subnet",
	"subscription":                "Description.Cache.Properties.Subscription",
	"system_data":                 "Description.Cache.SystemData",
	"tags":                        "Description.Cache.Tags",
	"title":                       "Description.Cache.name",
	"type":                        "Description.Cache.type",
}

func GetHpcCache(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetHpcCache")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewHpcCachePaginator(essdk.BuildFilter(ctx, d.QueryContext, getHpcCacheFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: HpcCache =============================

// ==========================  START: KeyVaultKey =============================

type KeyVaultKey struct {
	ResourceID      string                       `json:"resource_id"`
	PlatformID      string                       `json:"platform_id"`
	Description     azure.KeyVaultKeyDescription `json:"Description"`
	Metadata        azure.Metadata               `json:"metadata"`
	DescribedBy     string                       `json:"described_by"`
	ResourceType    string                       `json:"resource_type"`
	IntegrationType string                       `json:"integration_type"`
	IntegrationID   string                       `json:"integration_id"`
}

type KeyVaultKeyHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  KeyVaultKey   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type KeyVaultKeyHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []KeyVaultKeyHit  `json:"hits"`
}

type KeyVaultKeySearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  KeyVaultKeyHits `json:"hits"`
}

type KeyVaultKeyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKeyVaultKeyPaginator(filters []essdk.BoolFilter, limit *int64) (KeyVaultKeyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_keyvault_vaults_keys", filters, limit)
	if err != nil {
		return KeyVaultKeyPaginator{}, err
	}

	p := KeyVaultKeyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KeyVaultKeyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KeyVaultKeyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p KeyVaultKeyPaginator) NextPage(ctx context.Context) ([]KeyVaultKey, error) {
	var response KeyVaultKeySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KeyVaultKey
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKeyVaultKeyFilters = map[string]string{
	"curve_name":              "Description.Key.properties.curveName",
	"enabled":                 "Description.Key.properties.attributes.enabled",
	"id":                      "Description.Key.id",
	"key_ops":                 "Description.Key.Properties.KeyOps",
	"key_size":                "Description.Key.properties.keySize",
	"key_type":                "Description.Key.properties.kty",
	"key_uri":                 "Description.Key.properties.keyUri",
	"key_uri_with_version":    "Description.Key.properties.keyUriWithVersion",
	"location":                "Description.Key.location",
	"name":                    "Description.Key.name",
	"platform_integration_id": "IntegrationID",
	"recovery_level":          "Description.Key.properties.attributes.recoveryLevel",
	"resource_group":          "Description.ResourceGroup",
	"subscription":            "Description.Key.Properties.Subscription",
	"tags":                    "Description.Key.Tags",
	"title":                   "Description.Key.name",
	"type":                    "Description.Key.type",
}

func ListKeyVaultKey(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKeyVaultKey")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultKey NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultKey NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultKey GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultKey GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultKey GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewKeyVaultKeyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listKeyVaultKeyFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultKey NewKeyVaultKeyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListKeyVaultKey paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getKeyVaultKeyFilters = map[string]string{
	"curve_name":              "Description.Key.properties.curveName",
	"enabled":                 "Description.Key.properties.attributes.enabled",
	"id":                      "Description.Key.id",
	"key_ops":                 "Description.Key.Properties.KeyOps",
	"key_size":                "Description.Key.properties.keySize",
	"key_type":                "Description.Key.properties.kty",
	"key_uri":                 "Description.Key.properties.keyUri",
	"key_uri_with_version":    "Description.Key.properties.keyUriWithVersion",
	"location":                "Description.Key.location",
	"name":                    "description.Key.name",
	"platform_integration_id": "IntegrationID",
	"recovery_level":          "Description.Key.properties.attributes.recoveryLevel",
	"resource_group":          "description.ResourceGroup",
	"subscription":            "Description.Key.Properties.Subscription",
	"tags":                    "Description.Key.Tags",
	"title":                   "Description.Key.name",
	"type":                    "Description.Key.type",
	"vault_name":              "description.Vault.name",
}

func GetKeyVaultKey(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKeyVaultKey")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewKeyVaultKeyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getKeyVaultKeyFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: KeyVaultKey =============================

// ==========================  START: KeyVaultKeyVersion =============================

type KeyVaultKeyVersion struct {
	ResourceID      string                              `json:"resource_id"`
	PlatformID      string                              `json:"platform_id"`
	Description     azure.KeyVaultKeyVersionDescription `json:"Description"`
	Metadata        azure.Metadata                      `json:"metadata"`
	DescribedBy     string                              `json:"described_by"`
	ResourceType    string                              `json:"resource_type"`
	IntegrationType string                              `json:"integration_type"`
	IntegrationID   string                              `json:"integration_id"`
}

type KeyVaultKeyVersionHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  KeyVaultKeyVersion `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type KeyVaultKeyVersionHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []KeyVaultKeyVersionHit `json:"hits"`
}

type KeyVaultKeyVersionSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  KeyVaultKeyVersionHits `json:"hits"`
}

type KeyVaultKeyVersionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKeyVaultKeyVersionPaginator(filters []essdk.BoolFilter, limit *int64) (KeyVaultKeyVersionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_keyvault_vaults_keys_versions", filters, limit)
	if err != nil {
		return KeyVaultKeyVersionPaginator{}, err
	}

	p := KeyVaultKeyVersionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KeyVaultKeyVersionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KeyVaultKeyVersionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p KeyVaultKeyVersionPaginator) NextPage(ctx context.Context) ([]KeyVaultKeyVersion, error) {
	var response KeyVaultKeyVersionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KeyVaultKeyVersion
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKeyVaultKeyVersionFilters = map[string]string{
	"curve_name":              "Description.Version.properties.curveName",
	"enabled":                 "Description.Version.properties.attributes.enabled",
	"id":                      "Description.Version.id",
	"key_id":                  "Description.Key.id",
	"key_name":                "Description.Key.name",
	"key_ops":                 "Description.Version.Properties.JSONWebKeyOperation",
	"key_size":                "Description.Version.properties.keySize",
	"key_type":                "Description.Version.properties.kty",
	"key_uri":                 "Description.Version.properties.keyUri",
	"key_uri_with_version":    "Description.Version.properties.keyUriWithVersion",
	"location":                "Description.Version.location",
	"name":                    "Description.Version.name",
	"platform_integration_id": "IntegrationID",
	"recovery_level":          "Description.Version.properties.attributes.recoveryLevel",
	"resource_group":          "Description.ResourceGroup",
	"subscription":            "Description.Version.Properties.Subscription",
	"tags":                    "Description.Version.Tags",
	"title":                   "Description.Version.name",
	"type":                    "Description.Version.type",
	"vault_name":              "Description.Vault.name",
}

func ListKeyVaultKeyVersion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKeyVaultKeyVersion")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultKeyVersion NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultKeyVersion NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultKeyVersion GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultKeyVersion GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultKeyVersion GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewKeyVaultKeyVersionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listKeyVaultKeyVersionFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultKeyVersion NewKeyVaultKeyVersionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListKeyVaultKeyVersion paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getKeyVaultKeyVersionFilters = map[string]string{
	"curve_name":              "Description.Version.properties.curveName",
	"enabled":                 "Description.Version.properties.attributes.enabled",
	"id":                      "Description.Version.id",
	"key_id":                  "Description.Key.id",
	"key_name":                "Description.Key.name",
	"key_ops":                 "Description.Version.Properties.JSONWebKeyOperation",
	"key_size":                "Description.Version.properties.keySize",
	"key_type":                "Description.Version.properties.kty",
	"key_uri":                 "Description.Version.properties.keyUri",
	"key_uri_with_version":    "Description.Version.properties.keyUriWithVersion",
	"location":                "Description.Version.location",
	"name":                    "description.Version.name",
	"platform_integration_id": "IntegrationID",
	"recovery_level":          "Description.Version.properties.attributes.recoveryLevel",
	"resource_group":          "description.ResourceGroup",
	"subscription":            "Description.Version.Properties.Subscription",
	"tags":                    "Description.Version.Tags",
	"title":                   "Description.Version.name",
	"type":                    "Description.Version.type",
	"vault_name":              "description.Vault.name",
}

func GetKeyVaultKeyVersion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKeyVaultKeyVersion")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewKeyVaultKeyVersionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getKeyVaultKeyVersionFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: KeyVaultKeyVersion =============================

// ==========================  START: KubernetesCluster =============================

type KubernetesCluster struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     azure.KubernetesClusterDescription `json:"Description"`
	Metadata        azure.Metadata                     `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type KubernetesClusterHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  KubernetesCluster `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type KubernetesClusterHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []KubernetesClusterHit `json:"hits"`
}

type KubernetesClusterSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  KubernetesClusterHits `json:"hits"`
}

type KubernetesClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKubernetesClusterPaginator(filters []essdk.BoolFilter, limit *int64) (KubernetesClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_containerservice_managedclusters", filters, limit)
	if err != nil {
		return KubernetesClusterPaginator{}, err
	}

	p := KubernetesClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KubernetesClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KubernetesClusterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p KubernetesClusterPaginator) NextPage(ctx context.Context) ([]KubernetesCluster, error) {
	var response KubernetesClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KubernetesCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKubernetesClusterFilters = map[string]string{
	"aad_profile":                "Description.ManagedCluster.Properties.AADProfile",
	"addon_profiles":             "Description.ManagedCluster.Properties.AddonProfiles",
	"agent_pool_profiles":        "Description.ManagedCluster.Properties.AgentPoolProfiles",
	"api_server_access_profile":  "Description.ManagedCluster.Properties.APIServerAccessProfile",
	"auto_scaler_profile":        "Description.ManagedCluster.Properties.AutoScalerProfile",
	"auto_upgrade_profile":       "Description.ManagedCluster.Properties.AutoUpgradeProfile",
	"azure_portal_fqdn":          "Description.ManagedCluster.properties.azurePortalFQDN",
	"disk_encryption_set_id":     "Description.ManagedCluster.properties.diskEncryptionSetID",
	"dns_prefix":                 "Description.ManagedCluster.properties.dnsPrefix",
	"enable_pod_security_policy": "Description.ManagedCluster.properties.enablePodSecurityPolicy",
	"enable_rbac":                "Description.ManagedCluster.properties.enableRBAC",
	"fqdn":                       "Description.ManagedCluster.properties.fqdn",
	"fqdn_subdomain":             "Description.ManagedCluster.properties.fqdnSubdomain",
	"id":                         "Description.ManagedCluster.id",
	"identity":                   "Description.ManagedCluster.Identity",
	"identity_profile":           "Description.ManagedCluster.Properties.IdentityProfile",
	"kubernetes_version":         "Description.ManagedCluster.properties.kubernetesVersion",
	"linux_profile":              "Description.ManagedCluster.Properties.LinuxProfile",
	"location":                   "Description.ManagedCluster.location",
	"max_agent_pools":            "Description.ManagedCluster.properties.maxAgentPools",
	"name":                       "Description.ManagedCluster.name",
	"network_profile":            "Description.ManagedCluster.Properties.NetworkProfile",
	"node_resource_group":        "Description.ManagedCluster.properties.nodeResourceGroup",
	"platform_integration_id":    "IntegrationID",
	"pod_identity_profile":       "Description.ManagedCluster.Properties.PodIdentityProfile",
	"power_state":                "Description.ManagedCluster.Properties.PowerState",
	"private_fqdn":               "Description.ManagedCluster.properties.privateFQDN",
	"provisioning_state":         "Description.ManagedCluster.properties.provisioningState",
	"resource_group":             "Description.ResourceGroup",
	"service_principal_profile":  "Description.ManagedCluster.Properties.ServicePrincipalProfile",
	"sku":                        "Description.ManagedCluster.SKU",
	"subscription":               "Description.ManagedCluster.Properties.Subscription",
	"tags":                       "Description.ManagedCluster.Tags",
	"title":                      "Description.ManagedCluster.name",
	"type":                       "Description.ManagedCluster.type",
	"windows_profile":            "Description.ManagedCluster.Properties.WindowsProfile",
}

func ListKubernetesCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKubernetesCluster")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListKubernetesCluster NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListKubernetesCluster NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListKubernetesCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListKubernetesCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListKubernetesCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewKubernetesClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listKubernetesClusterFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListKubernetesCluster NewKubernetesClusterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListKubernetesCluster paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getKubernetesClusterFilters = map[string]string{
	"aad_profile":                "Description.ManagedCluster.Properties.AADProfile",
	"addon_profiles":             "Description.ManagedCluster.Properties.AddonProfiles",
	"agent_pool_profiles":        "Description.ManagedCluster.Properties.AgentPoolProfiles",
	"api_server_access_profile":  "Description.ManagedCluster.Properties.APIServerAccessProfile",
	"auto_scaler_profile":        "Description.ManagedCluster.Properties.AutoScalerProfile",
	"auto_upgrade_profile":       "Description.ManagedCluster.Properties.AutoUpgradeProfile",
	"azure_portal_fqdn":          "Description.ManagedCluster.properties.azurePortalFQDN",
	"disk_encryption_set_id":     "Description.ManagedCluster.properties.diskEncryptionSetID",
	"dns_prefix":                 "Description.ManagedCluster.properties.dnsPrefix",
	"enable_pod_security_policy": "Description.ManagedCluster.properties.enablePodSecurityPolicy",
	"enable_rbac":                "Description.ManagedCluster.properties.enableRBAC",
	"fqdn":                       "Description.ManagedCluster.properties.fqdn",
	"fqdn_subdomain":             "Description.ManagedCluster.properties.fqdnSubdomain",
	"id":                         "Description.ManagedCluster.id",
	"identity":                   "Description.ManagedCluster.Identity",
	"identity_profile":           "Description.ManagedCluster.Properties.IdentityProfile",
	"kubernetes_version":         "Description.ManagedCluster.properties.kubernetesVersion",
	"linux_profile":              "Description.ManagedCluster.Properties.LinuxProfile",
	"location":                   "Description.ManagedCluster.location",
	"max_agent_pools":            "Description.ManagedCluster.properties.maxAgentPools",
	"name":                       "description.ManagedCluster.name",
	"network_profile":            "Description.ManagedCluster.Properties.NetworkProfile",
	"node_resource_group":        "Description.ManagedCluster.properties.nodeResourceGroup",
	"platform_integration_id":    "IntegrationID",
	"pod_identity_profile":       "Description.ManagedCluster.Properties.PodIdentityProfile",
	"power_state":                "Description.ManagedCluster.Properties.PowerState",
	"private_fqdn":               "Description.ManagedCluster.properties.privateFQDN",
	"provisioning_state":         "Description.ManagedCluster.properties.provisioningState",
	"resource_group":             "description.ResourceGroup",
	"service_principal_profile":  "Description.ManagedCluster.Properties.ServicePrincipalProfile",
	"sku":                        "Description.ManagedCluster.SKU",
	"subscription":               "Description.ManagedCluster.Properties.Subscription",
	"tags":                       "Description.ManagedCluster.Tags",
	"title":                      "Description.ManagedCluster.name",
	"type":                       "Description.ManagedCluster.type",
	"windows_profile":            "Description.ManagedCluster.Properties.WindowsProfile",
}

func GetKubernetesCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKubernetesCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewKubernetesClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getKubernetesClusterFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: KubernetesCluster =============================

// ==========================  START: KubernetesServiceVersion =============================

type KubernetesServiceVersion struct {
	ResourceID      string                                    `json:"resource_id"`
	PlatformID      string                                    `json:"platform_id"`
	Description     azure.KubernetesServiceVersionDescription `json:"Description"`
	Metadata        azure.Metadata                            `json:"metadata"`
	DescribedBy     string                                    `json:"described_by"`
	ResourceType    string                                    `json:"resource_type"`
	IntegrationType string                                    `json:"integration_type"`
	IntegrationID   string                                    `json:"integration_id"`
}

type KubernetesServiceVersionHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  KubernetesServiceVersion `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type KubernetesServiceVersionHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []KubernetesServiceVersionHit `json:"hits"`
}

type KubernetesServiceVersionSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  KubernetesServiceVersionHits `json:"hits"`
}

type KubernetesServiceVersionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKubernetesServiceVersionPaginator(filters []essdk.BoolFilter, limit *int64) (KubernetesServiceVersionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_containerservice_serviceversions", filters, limit)
	if err != nil {
		return KubernetesServiceVersionPaginator{}, err
	}

	p := KubernetesServiceVersionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KubernetesServiceVersionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KubernetesServiceVersionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p KubernetesServiceVersionPaginator) NextPage(ctx context.Context) ([]KubernetesServiceVersion, error) {
	var response KubernetesServiceVersionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KubernetesServiceVersion
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKubernetesServiceVersionFilters = map[string]string{
	"capabilities":            "Description.Version.Capabilities",
	"is_preview":              "Description.Version.isPreview",
	"patch_versions":          "Description.Version.PatchVersions",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Version.Properties.Subscription",
	"title":                   "Description.Version.version",
	"version":                 "Description.Version.version",
}

func ListKubernetesServiceVersion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKubernetesServiceVersion")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListKubernetesServiceVersion NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListKubernetesServiceVersion NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListKubernetesServiceVersion GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListKubernetesServiceVersion GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListKubernetesServiceVersion GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewKubernetesServiceVersionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listKubernetesServiceVersionFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListKubernetesServiceVersion NewKubernetesServiceVersionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListKubernetesServiceVersion paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getKubernetesServiceVersionFilters = map[string]string{
	"capabilities":            "Description.Version.Capabilities",
	"is_preview":              "Description.Version.isPreview",
	"name":                    "description.Orchestrator.name",
	"patch_versions":          "Description.Version.PatchVersions",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "description.ResourceGroup",
	"subscription":            "Description.Version.Properties.Subscription",
	"title":                   "Description.Version.version",
	"version":                 "Description.Version.version",
}

func GetKubernetesServiceVersion(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKubernetesServiceVersion")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewKubernetesServiceVersionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getKubernetesServiceVersionFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: KubernetesServiceVersion =============================

// ==========================  START: ContainerInstanceContainerGroup =============================

type ContainerInstanceContainerGroup struct {
	ResourceID      string                                           `json:"resource_id"`
	PlatformID      string                                           `json:"platform_id"`
	Description     azure.ContainerInstanceContainerGroupDescription `json:"Description"`
	Metadata        azure.Metadata                                   `json:"metadata"`
	DescribedBy     string                                           `json:"described_by"`
	ResourceType    string                                           `json:"resource_type"`
	IntegrationType string                                           `json:"integration_type"`
	IntegrationID   string                                           `json:"integration_id"`
}

type ContainerInstanceContainerGroupHit struct {
	ID      string                          `json:"_id"`
	Score   float64                         `json:"_score"`
	Index   string                          `json:"_index"`
	Type    string                          `json:"_type"`
	Version int64                           `json:"_version,omitempty"`
	Source  ContainerInstanceContainerGroup `json:"_source"`
	Sort    []interface{}                   `json:"sort"`
}

type ContainerInstanceContainerGroupHits struct {
	Total essdk.SearchTotal                    `json:"total"`
	Hits  []ContainerInstanceContainerGroupHit `json:"hits"`
}

type ContainerInstanceContainerGroupSearchResponse struct {
	PitID string                              `json:"pit_id"`
	Hits  ContainerInstanceContainerGroupHits `json:"hits"`
}

type ContainerInstanceContainerGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewContainerInstanceContainerGroupPaginator(filters []essdk.BoolFilter, limit *int64) (ContainerInstanceContainerGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_containerinstance_containergroups", filters, limit)
	if err != nil {
		return ContainerInstanceContainerGroupPaginator{}, err
	}

	p := ContainerInstanceContainerGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ContainerInstanceContainerGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ContainerInstanceContainerGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ContainerInstanceContainerGroupPaginator) NextPage(ctx context.Context) ([]ContainerInstanceContainerGroup, error) {
	var response ContainerInstanceContainerGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ContainerInstanceContainerGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listContainerInstanceContainerGroupFilters = map[string]string{
	"containers":                 "Description.ContainerGroup.Properties.Containers",
	"diagnostics":                "Description.ContainerGroup.Properties.Diagnostics",
	"dns_config":                 "Description.ContainerGroup.Properties.DNSConfig",
	"encryption_properties":      "Description.ContainerGroup.Properties.EncryptionProperties",
	"id":                         "Description.ContainerGroup.id",
	"identity":                   "Description.ContainerGroup.Identity",
	"image_registry_credentials": "Description.ContainerGroup.Properties.ImageRegistryCredentials",
	"init_containers":            "Description.ContainerGroup.Properties.InitContainers",
	"instance_view":              "Description.ContainerGroup.Properties.InstanceView",
	"ip_address":                 "Description.ContainerGroup.Properties.IPAddress",
	"name":                       "Description.ContainerGroup.name",
	"os_type":                    "Description.ContainerGroup.properties.osType",
	"platform_integration_id":    "IntegrationID",
	"provisioning_state":         "Description.ContainerGroup.properties.provisioningState",
	"resource_group":             "Description.ResourceGroup",
	"restart_policy":             "Description.ContainerGroup.properties.restartPolicy",
	"sku":                        "Description.ContainerGroup.properties.sku",
	"subnet_ids":                 "Description.ContainerGroup.Properties.SubnetIDs",
	"subscription":               "Description.ContainerGroup.Properties.Subscription",
	"tags":                       "Description.ContainerGroup.Tags",
	"title":                      "Description.ContainerGroup.name",
	"type":                       "Description.ContainerGroup.type",
	"volumes":                    "Description.ContainerGroup.Properties.Volumes",
}

func ListContainerInstanceContainerGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListContainerInstanceContainerGroup")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListContainerInstanceContainerGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListContainerInstanceContainerGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListContainerInstanceContainerGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListContainerInstanceContainerGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListContainerInstanceContainerGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewContainerInstanceContainerGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listContainerInstanceContainerGroupFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListContainerInstanceContainerGroup NewContainerInstanceContainerGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListContainerInstanceContainerGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getContainerInstanceContainerGroupFilters = map[string]string{
	"containers":                 "Description.ContainerGroup.Properties.Containers",
	"diagnostics":                "Description.ContainerGroup.Properties.Diagnostics",
	"dns_config":                 "Description.ContainerGroup.Properties.DNSConfig",
	"encryption_properties":      "Description.ContainerGroup.Properties.EncryptionProperties",
	"id":                         "Description.ContainerGroup.id",
	"identity":                   "Description.ContainerGroup.Identity",
	"image_registry_credentials": "Description.ContainerGroup.Properties.ImageRegistryCredentials",
	"init_containers":            "Description.ContainerGroup.Properties.InitContainers",
	"instance_view":              "Description.ContainerGroup.Properties.InstanceView",
	"ip_address":                 "Description.ContainerGroup.Properties.IPAddress",
	"name":                       "Description.ContainerGroup.name",
	"os_type":                    "Description.ContainerGroup.properties.osType",
	"platform_integration_id":    "IntegrationID",
	"provisioning_state":         "Description.ContainerGroup.properties.provisioningState",
	"resource_group":             "Description.ResourceGroup",
	"restart_policy":             "Description.ContainerGroup.properties.restartPolicy",
	"sku":                        "Description.ContainerGroup.properties.sku",
	"subnet_ids":                 "Description.ContainerGroup.Properties.SubnetIDs",
	"subscription":               "Description.ContainerGroup.Properties.Subscription",
	"tags":                       "Description.ContainerGroup.Tags",
	"title":                      "Description.ContainerGroup.name",
	"type":                       "Description.ContainerGroup.type",
	"volumes":                    "Description.ContainerGroup.Properties.Volumes",
}

func GetContainerInstanceContainerGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetContainerInstanceContainerGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewContainerInstanceContainerGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getContainerInstanceContainerGroupFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ContainerInstanceContainerGroup =============================

// ==========================  START: CDNProfile =============================

type CDNProfile struct {
	ResourceID      string                      `json:"resource_id"`
	PlatformID      string                      `json:"platform_id"`
	Description     azure.CDNProfileDescription `json:"Description"`
	Metadata        azure.Metadata              `json:"metadata"`
	DescribedBy     string                      `json:"described_by"`
	ResourceType    string                      `json:"resource_type"`
	IntegrationType string                      `json:"integration_type"`
	IntegrationID   string                      `json:"integration_id"`
}

type CDNProfileHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  CDNProfile    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type CDNProfileHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []CDNProfileHit   `json:"hits"`
}

type CDNProfileSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  CDNProfileHits `json:"hits"`
}

type CDNProfilePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCDNProfilePaginator(filters []essdk.BoolFilter, limit *int64) (CDNProfilePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_cdn_profiles", filters, limit)
	if err != nil {
		return CDNProfilePaginator{}, err
	}

	p := CDNProfilePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CDNProfilePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CDNProfilePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CDNProfilePaginator) NextPage(ctx context.Context) ([]CDNProfile, error) {
	var response CDNProfileSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CDNProfile
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCDNProfileFilters = map[string]string{
	"front_door_id":                   "Description.Profile.properties.frontDoorId",
	"id":                              "Description.Profiles.ID",
	"kind":                            "Description.Profile.kind",
	"name":                            "Description.Profile.name",
	"origin_response_timeout_seconds": "Description.Profile.properties.originResponseTimeoutSeconds",
	"platform_integration_id":         "IntegrationID",
	"provisioning_state":              "Description.Profile.properties.provisioningState",
	"resource_group":                  "Description.ResourceGroup",
	"sku_name":                        "Description.Profile.sku.name",
	"subscription":                    "Description.Profiles.Properties.Subscription",
	"tags":                            "Description.Profile.Tags",
	"title":                           "Description.Profile.name",
	"type":                            "Description.Profile.type",
}

func ListCDNProfile(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCDNProfile")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCDNProfile NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCDNProfile NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCDNProfile GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCDNProfile GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCDNProfile GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCDNProfilePaginator(essdk.BuildFilter(ctx, d.QueryContext, listCDNProfileFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCDNProfile NewCDNProfilePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCDNProfile paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCDNProfileFilters = map[string]string{
	"front_door_id":                   "Description.Profile.properties.frontDoorId",
	"id":                              "Description.Profiles.ID",
	"kind":                            "Description.Profile.kind",
	"name":                            "Description.Profile.name",
	"origin_response_timeout_seconds": "Description.Profile.properties.originResponseTimeoutSeconds",
	"platform_integration_id":         "IntegrationID",
	"provisioning_state":              "Description.Profile.properties.provisioningState",
	"resource_group":                  "Description.ResourceGroup",
	"sku_name":                        "Description.Profile.sku.name",
	"subscription":                    "Description.Profiles.Properties.Subscription",
	"tags":                            "Description.Profile.Tags",
	"title":                           "Description.Profile.name",
	"type":                            "Description.Profile.type",
}

func GetCDNProfile(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCDNProfile")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCDNProfilePaginator(essdk.BuildFilter(ctx, d.QueryContext, getCDNProfileFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CDNProfile =============================

// ==========================  START: CDNEndpoint =============================

type CDNEndpoint struct {
	ResourceID      string                       `json:"resource_id"`
	PlatformID      string                       `json:"platform_id"`
	Description     azure.CDNEndpointDescription `json:"Description"`
	Metadata        azure.Metadata               `json:"metadata"`
	DescribedBy     string                       `json:"described_by"`
	ResourceType    string                       `json:"resource_type"`
	IntegrationType string                       `json:"integration_type"`
	IntegrationID   string                       `json:"integration_id"`
}

type CDNEndpointHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  CDNEndpoint   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type CDNEndpointHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []CDNEndpointHit  `json:"hits"`
}

type CDNEndpointSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  CDNEndpointHits `json:"hits"`
}

type CDNEndpointPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCDNEndpointPaginator(filters []essdk.BoolFilter, limit *int64) (CDNEndpointPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_cdn_profiles_endpoints", filters, limit)
	if err != nil {
		return CDNEndpointPaginator{}, err
	}

	p := CDNEndpointPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CDNEndpointPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CDNEndpointPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CDNEndpointPaginator) NextPage(ctx context.Context) ([]CDNEndpoint, error) {
	var response CDNEndpointSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CDNEndpoint
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCDNEndpointFilters = map[string]string{
	"id":           "Description.Endpoint.id",
	"name":         "Description.Endpoint.name",
	"subscription": "Description.Endpoint.Properties.Subscription",
	"tags":         "Description.Endpoint.Tags",
	"title":        "Description.Endpoint.name",
}

func ListCDNEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCDNEndpoint")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCDNEndpoint NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCDNEndpoint NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCDNEndpoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCDNEndpoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCDNEndpoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCDNEndpointPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCDNEndpointFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCDNEndpoint NewCDNEndpointPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCDNEndpoint paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCDNEndpointFilters = map[string]string{
	"id":           "Description.Endpoint.id",
	"name":         "Description.Endpoint.name",
	"subscription": "Description.Endpoint.Properties.Subscription",
	"tags":         "Description.Endpoint.Tags",
	"title":        "Description.Endpoint.name",
}

func GetCDNEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCDNEndpoint")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCDNEndpointPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCDNEndpointFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CDNEndpoint =============================

// ==========================  START: NetworkInterface =============================

type NetworkInterface struct {
	ResourceID      string                            `json:"resource_id"`
	PlatformID      string                            `json:"platform_id"`
	Description     azure.NetworkInterfaceDescription `json:"Description"`
	Metadata        azure.Metadata                    `json:"metadata"`
	DescribedBy     string                            `json:"described_by"`
	ResourceType    string                            `json:"resource_type"`
	IntegrationType string                            `json:"integration_type"`
	IntegrationID   string                            `json:"integration_id"`
}

type NetworkInterfaceHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  NetworkInterface `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type NetworkInterfaceHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []NetworkInterfaceHit `json:"hits"`
}

type NetworkInterfaceSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  NetworkInterfaceHits `json:"hits"`
}

type NetworkInterfacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNetworkInterfacePaginator(filters []essdk.BoolFilter, limit *int64) (NetworkInterfacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_networkinterfaces", filters, limit)
	if err != nil {
		return NetworkInterfacePaginator{}, err
	}

	p := NetworkInterfacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NetworkInterfacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NetworkInterfacePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p NetworkInterfacePaginator) NextPage(ctx context.Context) ([]NetworkInterface, error) {
	var response NetworkInterfaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NetworkInterface
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNetworkInterfaceFilters = map[string]string{
	"applied_dns_servers":           "Description.Interface.Properties.DNSSettings.AppliedDNSServers",
	"auxiliary_mode":                "Description.Interface.properties.auxiliaryMode",
	"dns_servers":                   "Description.Interface.Properties.DNSSettings.DNSServers",
	"dscp_configuration":            "Description.Interface.Properties.DscpConfiguration",
	"enable_accelerated_networking": "Description.Interface.properties.enableAcceleratedNetworking",
	"enable_ip_forwarding":          "Description.Interface.properties.enableIPForwarding",
	"etag":                          "Description.Interface.etag",
	"hosted_workloads":              "Description.Interface.Properties.HostedWorkloads",
	"id":                            "Description.Interface.id",
	"internal_dns_name_label":       "Description.Interface.properties.dnsSettings.internalDnsNameLabel",
	"internal_domain_name_suffix":   "Description.Interface.properties.dnsSettings.internalDomainNameSuffix",
	"internal_fqdn":                 "Description.Interface.properties.dnsSettings.internalFqdn",
	"ip_configurations":             "Description.Interface.Properties.IPConfigurations",
	"is_primary":                    "Description.Interface.properties.primary",
	"mac_address":                   "Description.Interface.properties.macAddress",
	"migration_phase":               "Description.Interface.properties.migrationPhase",
	"name":                          "Description.Interface.name",
	"network_security_group_id":     "Description.Interface.properties.networkSecurityGroup.id",
	"nic_type":                      "Description.Interface.properties.nicType",
	"platform_integration_id":       "IntegrationID",
	"private_endpoint":              "Description.Interface.Properties.PrivateEndpoint",
	"private_link_service":          "Description.Interface.Properties.PrivateLinkService",
	"provisioning_state":            "Description.Interface.properties.provisioningState",
	"resource_group":                "Description.ResourceGroup",
	"resource_guid":                 "Description.Interface.properties.resourceGuid",
	"subscription":                  "Description.Interface.Properties.Subscription",
	"tags":                          "Description.Interface.Tags",
	"tap_configurations":            "Description.Interface.Properties.TapConfigurations",
	"title":                         "Description.Interface.name",
	"type":                          "Description.Interface.type",
	"virtual_machine_id":            "Description.Interface.properties.virtualMachine.id",
	"vnet_encryption_supported":     "Description.Interface.properties.vnetEncryptionSupported",
	"workload_type":                 "Description.Interface.properties.workloadType",
}

func ListNetworkInterface(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNetworkInterface")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkInterface NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkInterface NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkInterface GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkInterface GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkInterface GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewNetworkInterfacePaginator(essdk.BuildFilter(ctx, d.QueryContext, listNetworkInterfaceFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkInterface NewNetworkInterfacePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListNetworkInterface paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getNetworkInterfaceFilters = map[string]string{
	"applied_dns_servers":           "Description.Interface.Properties.DNSSettings.AppliedDNSServers",
	"auxiliary_mode":                "Description.Interface.properties.auxiliaryMode",
	"dns_servers":                   "Description.Interface.Properties.DNSSettings.DNSServers",
	"dscp_configuration":            "Description.Interface.Properties.DscpConfiguration",
	"enable_accelerated_networking": "Description.Interface.properties.enableAcceleratedNetworking",
	"enable_ip_forwarding":          "Description.Interface.properties.enableIPForwarding",
	"etag":                          "Description.Interface.etag",
	"hosted_workloads":              "Description.Interface.Properties.HostedWorkloads",
	"id":                            "Description.Interface.id",
	"internal_dns_name_label":       "Description.Interface.properties.dnsSettings.internalDnsNameLabel",
	"internal_domain_name_suffix":   "Description.Interface.properties.dnsSettings.internalDomainNameSuffix",
	"internal_fqdn":                 "Description.Interface.properties.dnsSettings.internalFqdn",
	"ip_configurations":             "Description.Interface.Properties.IPConfigurations",
	"is_primary":                    "Description.Interface.properties.primary",
	"mac_address":                   "Description.Interface.properties.macAddress",
	"migration_phase":               "Description.Interface.properties.migrationPhase",
	"name":                          "description.Interface.name",
	"network_security_group_id":     "Description.Interface.properties.networkSecurityGroup.id",
	"nic_type":                      "Description.Interface.properties.nicType",
	"platform_integration_id":       "IntegrationID",
	"private_endpoint":              "Description.Interface.Properties.PrivateEndpoint",
	"private_link_service":          "Description.Interface.Properties.PrivateLinkService",
	"provisioning_state":            "Description.Interface.properties.provisioningState",
	"resource_group":                "description.ResourceGroup",
	"resource_guid":                 "Description.Interface.properties.resourceGuid",
	"subscription":                  "Description.Interface.Properties.Subscription",
	"tags":                          "Description.Interface.Tags",
	"tap_configurations":            "Description.Interface.Properties.TapConfigurations",
	"title":                         "Description.Interface.name",
	"type":                          "Description.Interface.type",
	"virtual_machine_id":            "Description.Interface.properties.virtualMachine.id",
	"vnet_encryption_supported":     "Description.Interface.properties.vnetEncryptionSupported",
	"workload_type":                 "Description.Interface.properties.workloadType",
}

func GetNetworkInterface(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNetworkInterface")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewNetworkInterfacePaginator(essdk.BuildFilter(ctx, d.QueryContext, getNetworkInterfaceFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: NetworkInterface =============================

// ==========================  START: NetworkWatcherFlowLog =============================

type NetworkWatcherFlowLog struct {
	ResourceID      string                                 `json:"resource_id"`
	PlatformID      string                                 `json:"platform_id"`
	Description     azure.NetworkWatcherFlowLogDescription `json:"Description"`
	Metadata        azure.Metadata                         `json:"metadata"`
	DescribedBy     string                                 `json:"described_by"`
	ResourceType    string                                 `json:"resource_type"`
	IntegrationType string                                 `json:"integration_type"`
	IntegrationID   string                                 `json:"integration_id"`
}

type NetworkWatcherFlowLogHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  NetworkWatcherFlowLog `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type NetworkWatcherFlowLogHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []NetworkWatcherFlowLogHit `json:"hits"`
}

type NetworkWatcherFlowLogSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  NetworkWatcherFlowLogHits `json:"hits"`
}

type NetworkWatcherFlowLogPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNetworkWatcherFlowLogPaginator(filters []essdk.BoolFilter, limit *int64) (NetworkWatcherFlowLogPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_networkwatchers_flowlogs", filters, limit)
	if err != nil {
		return NetworkWatcherFlowLogPaginator{}, err
	}

	p := NetworkWatcherFlowLogPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NetworkWatcherFlowLogPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NetworkWatcherFlowLogPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p NetworkWatcherFlowLogPaginator) NextPage(ctx context.Context) ([]NetworkWatcherFlowLog, error) {
	var response NetworkWatcherFlowLogSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NetworkWatcherFlowLog
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNetworkWatcherFlowLogFilters = map[string]string{
	"enabled":                  "Description.FlowLog.properties.enabled",
	"etag":                     "Description.FlowLog.etag",
	"file_type":                "Description.FlowLog.properties.format.type",
	"id":                       "Description.FlowLog.id",
	"name":                     "Description.FlowLog.name",
	"network_watcher_name":     "Description.NetworkWatcherName",
	"platform_integration_id":  "IntegrationID",
	"provisioning_state":       "Description.FlowLog.properties.provisioningState",
	"resource_group":           "Description.ResourceGroup",
	"retention_policy_days":    "Description.FlowLog.properties.retentionPolicy.days",
	"retention_policy_enabled": "Description.FlowLog.properties.retentionPolicy.enabled",
	"storage_id":               "Description.FlowLog.properties.storageId",
	"subscription":             "Description.FlowLog.Properties.Subscription",
	"tags":                     "Description.FlowLog.Tags",
	"target_resource_guid":     "Description.FlowLog.properties.targetResourceGuid",
	"target_resource_id":       "Description.FlowLog.properties.targetResourceId",
	"title":                    "Description.FlowLog.name",
	"traffic_analytics":        "Description.FlowLog.Properties.FlowAnalyticsConfiguration.NetworkWatcherFlowAnalyticsConfiguration",
	"type":                     "Description.FlowLog.type",
	"version":                  "Description.FlowLog.properties.format.version",
}

func ListNetworkWatcherFlowLog(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNetworkWatcherFlowLog")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkWatcherFlowLog NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkWatcherFlowLog NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkWatcherFlowLog GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkWatcherFlowLog GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkWatcherFlowLog GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewNetworkWatcherFlowLogPaginator(essdk.BuildFilter(ctx, d.QueryContext, listNetworkWatcherFlowLogFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkWatcherFlowLog NewNetworkWatcherFlowLogPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListNetworkWatcherFlowLog paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getNetworkWatcherFlowLogFilters = map[string]string{
	"enabled":                  "Description.FlowLog.properties.enabled",
	"etag":                     "Description.FlowLog.etag",
	"file_type":                "Description.FlowLog.properties.format.type",
	"id":                       "Description.FlowLog.id",
	"name":                     "description.ManagedCluster.name",
	"network_watcher_name":     "description.NetworkWatcherName",
	"platform_integration_id":  "IntegrationID",
	"provisioning_state":       "Description.FlowLog.properties.provisioningState",
	"resource_group":           "description.ResourceGroup",
	"retention_policy_days":    "Description.FlowLog.properties.retentionPolicy.days",
	"retention_policy_enabled": "Description.FlowLog.properties.retentionPolicy.enabled",
	"storage_id":               "Description.FlowLog.properties.storageId",
	"subscription":             "Description.FlowLog.Properties.Subscription",
	"tags":                     "Description.FlowLog.Tags",
	"target_resource_guid":     "Description.FlowLog.properties.targetResourceGuid",
	"target_resource_id":       "Description.FlowLog.properties.targetResourceId",
	"title":                    "Description.FlowLog.name",
	"traffic_analytics":        "Description.FlowLog.Properties.FlowAnalyticsConfiguration.NetworkWatcherFlowAnalyticsConfiguration",
	"type":                     "Description.FlowLog.type",
	"version":                  "Description.FlowLog.properties.format.version",
}

func GetNetworkWatcherFlowLog(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNetworkWatcherFlowLog")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewNetworkWatcherFlowLogPaginator(essdk.BuildFilter(ctx, d.QueryContext, getNetworkWatcherFlowLogFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: NetworkWatcherFlowLog =============================

// ==========================  START: RouteTables =============================

type RouteTables struct {
	ResourceID      string                       `json:"resource_id"`
	PlatformID      string                       `json:"platform_id"`
	Description     azure.RouteTablesDescription `json:"Description"`
	Metadata        azure.Metadata               `json:"metadata"`
	DescribedBy     string                       `json:"described_by"`
	ResourceType    string                       `json:"resource_type"`
	IntegrationType string                       `json:"integration_type"`
	IntegrationID   string                       `json:"integration_id"`
}

type RouteTablesHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  RouteTables   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RouteTablesHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []RouteTablesHit  `json:"hits"`
}

type RouteTablesSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  RouteTablesHits `json:"hits"`
}

type RouteTablesPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRouteTablesPaginator(filters []essdk.BoolFilter, limit *int64) (RouteTablesPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_routetables", filters, limit)
	if err != nil {
		return RouteTablesPaginator{}, err
	}

	p := RouteTablesPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RouteTablesPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RouteTablesPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RouteTablesPaginator) NextPage(ctx context.Context) ([]RouteTables, error) {
	var response RouteTablesSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RouteTables
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRouteTablesFilters = map[string]string{
	"disable_bgp_route_propagation": "Description.RouteTable.properties.disableBgpRoutePropagation",
	"etag":                          "Description.RouteTable.etag",
	"name":                          "Description.RouteTable.name",
	"platform_integration_id":       "IntegrationID",
	"provisioning_state":            "Description.RouteTable.properties.provisioningState",
	"routes":                        "Description.RouteTable.Properties.Routes",
	"subnets":                       "Description.RouteTable.Properties.Subnets",
	"subscription":                  "Description.RouteTable.Properties.Subscription",
	"tags":                          "Description.RouteTable.Tags",
	"title":                         "Description.RouteTable.name",
	"type":                          "Description.RouteTable.type",
}

func ListRouteTables(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRouteTables")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRouteTables NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRouteTables NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRouteTables GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRouteTables GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRouteTables GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRouteTablesPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRouteTablesFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRouteTables NewRouteTablesPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRouteTables paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRouteTablesFilters = map[string]string{
	"disable_bgp_route_propagation": "Description.RouteTable.properties.disableBgpRoutePropagation",
	"etag":                          "Description.RouteTable.etag",
	"name":                          "description.RouteTable.Name",
	"platform_integration_id":       "IntegrationID",
	"provisioning_state":            "Description.RouteTable.properties.provisioningState",
	"resource_group":                "description.ResourceGroup",
	"routes":                        "Description.RouteTable.Properties.Routes",
	"subnets":                       "Description.RouteTable.Properties.Subnets",
	"subscription":                  "Description.RouteTable.Properties.Subscription",
	"tags":                          "Description.RouteTable.Tags",
	"title":                         "Description.RouteTable.name",
	"type":                          "Description.RouteTable.type",
}

func GetRouteTables(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRouteTables")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRouteTablesPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRouteTablesFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RouteTables =============================

// ==========================  START: NetworkApplicationSecurityGroups =============================

type NetworkApplicationSecurityGroups struct {
	ResourceID      string                                            `json:"resource_id"`
	PlatformID      string                                            `json:"platform_id"`
	Description     azure.NetworkApplicationSecurityGroupsDescription `json:"Description"`
	Metadata        azure.Metadata                                    `json:"metadata"`
	DescribedBy     string                                            `json:"described_by"`
	ResourceType    string                                            `json:"resource_type"`
	IntegrationType string                                            `json:"integration_type"`
	IntegrationID   string                                            `json:"integration_id"`
}

type NetworkApplicationSecurityGroupsHit struct {
	ID      string                           `json:"_id"`
	Score   float64                          `json:"_score"`
	Index   string                           `json:"_index"`
	Type    string                           `json:"_type"`
	Version int64                            `json:"_version,omitempty"`
	Source  NetworkApplicationSecurityGroups `json:"_source"`
	Sort    []interface{}                    `json:"sort"`
}

type NetworkApplicationSecurityGroupsHits struct {
	Total essdk.SearchTotal                     `json:"total"`
	Hits  []NetworkApplicationSecurityGroupsHit `json:"hits"`
}

type NetworkApplicationSecurityGroupsSearchResponse struct {
	PitID string                               `json:"pit_id"`
	Hits  NetworkApplicationSecurityGroupsHits `json:"hits"`
}

type NetworkApplicationSecurityGroupsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNetworkApplicationSecurityGroupsPaginator(filters []essdk.BoolFilter, limit *int64) (NetworkApplicationSecurityGroupsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_applicationsecuritygroups", filters, limit)
	if err != nil {
		return NetworkApplicationSecurityGroupsPaginator{}, err
	}

	p := NetworkApplicationSecurityGroupsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NetworkApplicationSecurityGroupsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NetworkApplicationSecurityGroupsPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p NetworkApplicationSecurityGroupsPaginator) NextPage(ctx context.Context) ([]NetworkApplicationSecurityGroups, error) {
	var response NetworkApplicationSecurityGroupsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NetworkApplicationSecurityGroups
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNetworkApplicationSecurityGroupsFilters = map[string]string{
	"etag":                    "Description.ApplicationSecurityGroup.etag",
	"name":                    "Description.ApplicationSecurityGroup.name",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.ApplicationSecurityGroup.properties.provisioningState",
	"resource_group":          "Description.ResourceGroup",
	"resource_guid":           "Description.ApplicationSecurityGroup.properties.resourceGuid",
	"subscription":            "Description.ApplicationSecurityGroup.Properties.Subscription",
	"tags":                    "Description.ApplicationSecurityGroup.Tags",
	"title":                   "Description.ApplicationSecurityGroup.name",
	"type":                    "Description.ApplicationSecurityGroup.type",
}

func ListNetworkApplicationSecurityGroups(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNetworkApplicationSecurityGroups")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkApplicationSecurityGroups NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkApplicationSecurityGroups NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkApplicationSecurityGroups GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkApplicationSecurityGroups GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkApplicationSecurityGroups GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewNetworkApplicationSecurityGroupsPaginator(essdk.BuildFilter(ctx, d.QueryContext, listNetworkApplicationSecurityGroupsFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkApplicationSecurityGroups NewNetworkApplicationSecurityGroupsPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListNetworkApplicationSecurityGroups paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getNetworkApplicationSecurityGroupsFilters = map[string]string{
	"etag":                    "Description.ApplicationSecurityGroup.etag",
	"name":                    "description.ApplicationSecurityGroup.Name",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.ApplicationSecurityGroup.properties.provisioningState",
	"resource_group":          "description.ResourceGroup",
	"resource_guid":           "Description.ApplicationSecurityGroup.properties.resourceGuid",
	"subscription":            "Description.ApplicationSecurityGroup.Properties.Subscription",
	"tags":                    "Description.ApplicationSecurityGroup.Tags",
	"title":                   "Description.ApplicationSecurityGroup.name",
	"type":                    "Description.ApplicationSecurityGroup.type",
}

func GetNetworkApplicationSecurityGroups(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNetworkApplicationSecurityGroups")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewNetworkApplicationSecurityGroupsPaginator(essdk.BuildFilter(ctx, d.QueryContext, getNetworkApplicationSecurityGroupsFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: NetworkApplicationSecurityGroups =============================

// ==========================  START: NetworkAzureFirewall =============================

type NetworkAzureFirewall struct {
	ResourceID      string                                `json:"resource_id"`
	PlatformID      string                                `json:"platform_id"`
	Description     azure.NetworkAzureFirewallDescription `json:"Description"`
	Metadata        azure.Metadata                        `json:"metadata"`
	DescribedBy     string                                `json:"described_by"`
	ResourceType    string                                `json:"resource_type"`
	IntegrationType string                                `json:"integration_type"`
	IntegrationID   string                                `json:"integration_id"`
}

type NetworkAzureFirewallHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  NetworkAzureFirewall `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type NetworkAzureFirewallHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []NetworkAzureFirewallHit `json:"hits"`
}

type NetworkAzureFirewallSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  NetworkAzureFirewallHits `json:"hits"`
}

type NetworkAzureFirewallPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNetworkAzureFirewallPaginator(filters []essdk.BoolFilter, limit *int64) (NetworkAzureFirewallPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_azurefirewalls", filters, limit)
	if err != nil {
		return NetworkAzureFirewallPaginator{}, err
	}

	p := NetworkAzureFirewallPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NetworkAzureFirewallPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NetworkAzureFirewallPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p NetworkAzureFirewallPaginator) NextPage(ctx context.Context) ([]NetworkAzureFirewall, error) {
	var response NetworkAzureFirewallSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NetworkAzureFirewall
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNetworkAzureFirewallFilters = map[string]string{
	"additional_properties":        "Description.AzureFirewall.Properties.AdditionalProperties",
	"application_rule_collections": "Description.AzureFirewall.Properties.ApplicationRuleCollections",
	"availability_zones":           "Description.AzureFirewall.Zones",
	"etag":                         "Description.AzureFirewall.etag",
	"firewall_policy_id":           "Description.AzureFirewall.properties.firewallPolicy.id",
	"hub_private_ip_address":       "Description.AzureFirewall.properties.hubIPAddresses.privateIPAddress",
	"hub_public_ip_address_count":  "Description.AzureFirewall.properties.hubIPAddresses.publicIPs.count",
	"hub_public_ip_addresses":      "Description.AzureFirewall.Properties.HubIPAddresses.PublicIPs.Addresses",
	"id":                           "Description.AzureFirewall.id",
	"ip_groups":                    "Description.AzureFirewall.Properties.IPGroups",
	"name":                         "Description.AzureFirewall.name",
	"nat_rule_collections":         "Description.AzureFirewall.Properties.NatRuleCollections",
	"network_rule_collections":     "Description.AzureFirewall.Properties.NetworkRuleCollections",
	"platform_integration_id":      "IntegrationID",
	"provisioning_state":           "Description.AzureFirewall.properties.provisioningState",
	"resource_group":               "Description.ResourceGroup",
	"sku_name":                     "Description.AzureFirewall.properties.sku.name",
	"sku_tier":                     "Description.AzureFirewall.properties.sku.tier",
	"subscription":                 "Description.AzureFirewall.Properties.Subscription",
	"tags":                         "Description.AzureFirewall.Tags",
	"threat_intel_mode":            "Description.AzureFirewall.properties.threatIntelMode",
	"title":                        "Description.AzureFirewall.name",
	"type":                         "Description.AzureFirewall.type",
	"virtual_hub_id":               "Description.AzureFirewall.properties.virtualHub.id",
}

func ListNetworkAzureFirewall(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNetworkAzureFirewall")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkAzureFirewall NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkAzureFirewall NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkAzureFirewall GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkAzureFirewall GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkAzureFirewall GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewNetworkAzureFirewallPaginator(essdk.BuildFilter(ctx, d.QueryContext, listNetworkAzureFirewallFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkAzureFirewall NewNetworkAzureFirewallPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListNetworkAzureFirewall paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getNetworkAzureFirewallFilters = map[string]string{
	"additional_properties":        "Description.AzureFirewall.Properties.AdditionalProperties",
	"application_rule_collections": "Description.AzureFirewall.Properties.ApplicationRuleCollections",
	"availability_zones":           "Description.AzureFirewall.Zones",
	"etag":                         "Description.AzureFirewall.etag",
	"firewall_policy_id":           "Description.AzureFirewall.properties.firewallPolicy.id",
	"hub_private_ip_address":       "Description.AzureFirewall.properties.hubIPAddresses.privateIPAddress",
	"hub_public_ip_address_count":  "Description.AzureFirewall.properties.hubIPAddresses.publicIPs.count",
	"hub_public_ip_addresses":      "Description.AzureFirewall.Properties.HubIPAddresses.PublicIPs.Addresses",
	"id":                           "Description.AzureFirewall.id",
	"ip_groups":                    "Description.AzureFirewall.Properties.IPGroups",
	"name":                         "description.AzureFirewall.Name",
	"nat_rule_collections":         "Description.AzureFirewall.Properties.NatRuleCollections",
	"network_rule_collections":     "Description.AzureFirewall.Properties.NetworkRuleCollections",
	"platform_integration_id":      "IntegrationID",
	"provisioning_state":           "Description.AzureFirewall.properties.provisioningState",
	"resource_group":               "description.ResourceGroup",
	"sku_name":                     "Description.AzureFirewall.properties.sku.name",
	"sku_tier":                     "Description.AzureFirewall.properties.sku.tier",
	"subscription":                 "Description.AzureFirewall.Properties.Subscription",
	"tags":                         "Description.AzureFirewall.Tags",
	"threat_intel_mode":            "Description.AzureFirewall.properties.threatIntelMode",
	"title":                        "Description.AzureFirewall.name",
	"type":                         "Description.AzureFirewall.type",
	"virtual_hub_id":               "Description.AzureFirewall.properties.virtualHub.id",
}

func GetNetworkAzureFirewall(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNetworkAzureFirewall")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewNetworkAzureFirewallPaginator(essdk.BuildFilter(ctx, d.QueryContext, getNetworkAzureFirewallFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: NetworkAzureFirewall =============================

// ==========================  START: ExpressRouteCircuit =============================

type ExpressRouteCircuit struct {
	ResourceID      string                               `json:"resource_id"`
	PlatformID      string                               `json:"platform_id"`
	Description     azure.ExpressRouteCircuitDescription `json:"Description"`
	Metadata        azure.Metadata                       `json:"metadata"`
	DescribedBy     string                               `json:"described_by"`
	ResourceType    string                               `json:"resource_type"`
	IntegrationType string                               `json:"integration_type"`
	IntegrationID   string                               `json:"integration_id"`
}

type ExpressRouteCircuitHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  ExpressRouteCircuit `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type ExpressRouteCircuitHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []ExpressRouteCircuitHit `json:"hits"`
}

type ExpressRouteCircuitSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  ExpressRouteCircuitHits `json:"hits"`
}

type ExpressRouteCircuitPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewExpressRouteCircuitPaginator(filters []essdk.BoolFilter, limit *int64) (ExpressRouteCircuitPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_expressroutecircuits", filters, limit)
	if err != nil {
		return ExpressRouteCircuitPaginator{}, err
	}

	p := ExpressRouteCircuitPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ExpressRouteCircuitPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ExpressRouteCircuitPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ExpressRouteCircuitPaginator) NextPage(ctx context.Context) ([]ExpressRouteCircuit, error) {
	var response ExpressRouteCircuitSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ExpressRouteCircuit
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listExpressRouteCircuitFilters = map[string]string{
	"allow_classic_operations":            "Description.ExpressRouteCircuit.properties.allowClassicOperations",
	"authorizations":                      "Description.ExpressRouteCircuit.Properties.Authorizations",
	"bandwidth_in_gbps":                   "Description.ExpressRouteCircuit.properties.bandwidthInGbps",
	"circuit_provisioning_state":          "Description.ExpressRouteCircuit.properties.circuitProvisioningState",
	"etag":                                "Description.ExpressRouteCircuit.etag",
	"express_route_port":                  "Description.ExpressRouteCircuit.Properties.ExpressRoutePort",
	"global_reach_enabled":                "Description.ExpressRouteCircuit.properties.globalReachEnabled",
	"id":                                  "Description.ExpressRouteCircuit.id",
	"name":                                "Description.ExpressRouteCircuit.name",
	"peerings":                            "Description.ExpressRouteCircuit.Properties.Peerings",
	"platform_integration_id":             "IntegrationID",
	"provisioning_state":                  "Description.ExpressRouteCircuit.properties.provisioningState",
	"resource_group":                      "Description.ResourceGroup",
	"service_key":                         "Description.ExpressRouteCircuit.properties.serviceKey",
	"service_provider_notes":              "Description.ExpressRouteCircuit.properties.serviceProviderNotes",
	"service_provider_properties":         "Description.ExpressRouteCircuit.Properties.ServiceProviderProperties",
	"service_provider_provisioning_state": "Description.ExpressRouteCircuit.properties.serviceProviderProvisioningState",
	"sku_family":                          "Description.ExpressRouteCircuit.sku.family",
	"sku_name":                            "Description.ExpressRouteCircuit.sku.name",
	"sku_tier":                            "Description.ExpressRouteCircuit.sku.tier",
	"subscription":                        "Description.ExpressRouteCircuit.Properties.Subscription",
	"tags":                                "Description.ExpressRouteCircuit.Tags",
	"title":                               "Description.ExpressRouteCircuit.name",
}

func ListExpressRouteCircuit(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListExpressRouteCircuit")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListExpressRouteCircuit NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListExpressRouteCircuit NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListExpressRouteCircuit GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListExpressRouteCircuit GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListExpressRouteCircuit GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewExpressRouteCircuitPaginator(essdk.BuildFilter(ctx, d.QueryContext, listExpressRouteCircuitFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListExpressRouteCircuit NewExpressRouteCircuitPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListExpressRouteCircuit paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getExpressRouteCircuitFilters = map[string]string{
	"allow_classic_operations":            "Description.ExpressRouteCircuit.properties.allowClassicOperations",
	"authorizations":                      "Description.ExpressRouteCircuit.Properties.Authorizations",
	"bandwidth_in_gbps":                   "Description.ExpressRouteCircuit.properties.bandwidthInGbps",
	"circuit_provisioning_state":          "Description.ExpressRouteCircuit.properties.circuitProvisioningState",
	"etag":                                "Description.ExpressRouteCircuit.etag",
	"express_route_port":                  "Description.ExpressRouteCircuit.Properties.ExpressRoutePort",
	"global_reach_enabled":                "Description.ExpressRouteCircuit.properties.globalReachEnabled",
	"id":                                  "Description.ExpressRouteCircuit.id",
	"name":                                "description.ExpressRouteCircuit.name",
	"peerings":                            "Description.ExpressRouteCircuit.Properties.Peerings",
	"platform_integration_id":             "IntegrationID",
	"provisioning_state":                  "Description.ExpressRouteCircuit.properties.provisioningState",
	"resource_group":                      "description.ResourceGroup",
	"service_key":                         "Description.ExpressRouteCircuit.properties.serviceKey",
	"service_provider_notes":              "Description.ExpressRouteCircuit.properties.serviceProviderNotes",
	"service_provider_properties":         "Description.ExpressRouteCircuit.Properties.ServiceProviderProperties",
	"service_provider_provisioning_state": "Description.ExpressRouteCircuit.properties.serviceProviderProvisioningState",
	"sku_family":                          "Description.ExpressRouteCircuit.sku.family",
	"sku_name":                            "Description.ExpressRouteCircuit.sku.name",
	"sku_tier":                            "Description.ExpressRouteCircuit.sku.tier",
	"subscription":                        "Description.ExpressRouteCircuit.Properties.Subscription",
	"tags":                                "Description.ExpressRouteCircuit.Tags",
	"title":                               "Description.ExpressRouteCircuit.name",
}

func GetExpressRouteCircuit(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetExpressRouteCircuit")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewExpressRouteCircuitPaginator(essdk.BuildFilter(ctx, d.QueryContext, getExpressRouteCircuitFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ExpressRouteCircuit =============================

// ==========================  START: VirtualNetworkGateway =============================

type VirtualNetworkGateway struct {
	ResourceID      string                                 `json:"resource_id"`
	PlatformID      string                                 `json:"platform_id"`
	Description     azure.VirtualNetworkGatewayDescription `json:"Description"`
	Metadata        azure.Metadata                         `json:"metadata"`
	DescribedBy     string                                 `json:"described_by"`
	ResourceType    string                                 `json:"resource_type"`
	IntegrationType string                                 `json:"integration_type"`
	IntegrationID   string                                 `json:"integration_id"`
}

type VirtualNetworkGatewayHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  VirtualNetworkGateway `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type VirtualNetworkGatewayHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []VirtualNetworkGatewayHit `json:"hits"`
}

type VirtualNetworkGatewaySearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  VirtualNetworkGatewayHits `json:"hits"`
}

type VirtualNetworkGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewVirtualNetworkGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (VirtualNetworkGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_virtualnetworkgateways", filters, limit)
	if err != nil {
		return VirtualNetworkGatewayPaginator{}, err
	}

	p := VirtualNetworkGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p VirtualNetworkGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p VirtualNetworkGatewayPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p VirtualNetworkGatewayPaginator) NextPage(ctx context.Context) ([]VirtualNetworkGateway, error) {
	var response VirtualNetworkGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []VirtualNetworkGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listVirtualNetworkGatewayFilters = map[string]string{
	"active_active":                   "Description.VirtualNetworkGateway.properties.activeActive",
	"bgp_settings":                    "Description.VirtualNetworkGateway.Properties.BgpSettings",
	"custom_routes_address_prefixes":  "Description.VirtualNetworkGateway.Properties.CustomRoutes.AddressPrefixes",
	"enable_bgp":                      "Description.VirtualNetworkGateway.properties.enableBgp",
	"enable_dns_forwarding":           "Description.VirtualNetworkGateway.properties.enableDnsForwarding",
	"enable_private_ip_address":       "Description.VirtualNetworkGateway.properties.enablePrivateIpAddress",
	"etag":                            "Description.VirtualNetworkGateway.etag",
	"gateway_connections":             "Description.VirtualNetworkGatewayConnection",
	"gateway_default_site":            "Description.VirtualNetworkGateway.properties.gatewayDefaultSite.id",
	"gateway_type":                    "Description.VirtualNetworkGateway.properties.gatewayType",
	"id":                              "Description.VirtualNetworkGateway.id",
	"inbound_dns_forwarding_endpoint": "Description.VirtualNetworkGateway.properties.inboundDnsForwardingEndpoint",
	"ip_configurations":               "Description.VirtualNetworkGateway.Properties.IPConfigurations",
	"name":                            "Description.VirtualNetworkGateway.name",
	"platform_integration_id":         "IntegrationID",
	"provisioning_state":              "Description.VirtualNetworkGateway.properties.provisioningState",
	"resource_group":                  "Description.ResourceGroup",
	"resource_guid":                   "Description.VirtualNetworkGateway.properties.resourceGuid",
	"sku_capacity":                    "Description.VirtualNetworkGateway.properties.sku.capacity",
	"sku_name":                        "Description.VirtualNetworkGateway.properties.sku.name",
	"sku_tier":                        "Description.VirtualNetworkGateway.properties.sku.tier",
	"subscription":                    "Description.VirtualNetworkGateway.Properties.Subscription",
	"tags":                            "Description.VirtualNetworkGateway.Tags",
	"title":                           "Description.VirtualNetworkGateway.name",
	"type":                            "Description.VirtualNetworkGateway.type",
	"vpn_client_configuration":        "Description.VirtualNetworkGateway.Properties.VPNClientConfiguration",
	"vpn_gateway_generation":          "Description.VirtualNetworkGateway.properties.vpnGatewayGeneration",
	"vpn_type":                        "Description.VirtualNetworkGateway.properties.vpnType",
}

func ListVirtualNetworkGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListVirtualNetworkGateway")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualNetworkGateway NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualNetworkGateway NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualNetworkGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualNetworkGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualNetworkGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewVirtualNetworkGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, listVirtualNetworkGatewayFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualNetworkGateway NewVirtualNetworkGatewayPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListVirtualNetworkGateway paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getVirtualNetworkGatewayFilters = map[string]string{
	"active_active":                   "Description.VirtualNetworkGateway.properties.activeActive",
	"bgp_settings":                    "Description.VirtualNetworkGateway.Properties.BgpSettings",
	"custom_routes_address_prefixes":  "Description.VirtualNetworkGateway.Properties.CustomRoutes.AddressPrefixes",
	"enable_bgp":                      "Description.VirtualNetworkGateway.properties.enableBgp",
	"enable_dns_forwarding":           "Description.VirtualNetworkGateway.properties.enableDnsForwarding",
	"enable_private_ip_address":       "Description.VirtualNetworkGateway.properties.enablePrivateIpAddress",
	"etag":                            "Description.VirtualNetworkGateway.etag",
	"gateway_connections":             "Description.VirtualNetworkGatewayConnection",
	"gateway_default_site":            "Description.VirtualNetworkGateway.properties.gatewayDefaultSite.id",
	"gateway_type":                    "Description.VirtualNetworkGateway.properties.gatewayType",
	"id":                              "Description.VirtualNetworkGateway.id",
	"inbound_dns_forwarding_endpoint": "Description.VirtualNetworkGateway.properties.inboundDnsForwardingEndpoint",
	"ip_configurations":               "Description.VirtualNetworkGateway.Properties.IPConfigurations",
	"name":                            "description.VirtualNetworkGateway.Name",
	"platform_integration_id":         "IntegrationID",
	"provisioning_state":              "Description.VirtualNetworkGateway.properties.provisioningState",
	"resource_group":                  "description.ResourceGroup",
	"resource_guid":                   "Description.VirtualNetworkGateway.properties.resourceGuid",
	"sku_capacity":                    "Description.VirtualNetworkGateway.properties.sku.capacity",
	"sku_name":                        "Description.VirtualNetworkGateway.properties.sku.name",
	"sku_tier":                        "Description.VirtualNetworkGateway.properties.sku.tier",
	"subscription":                    "Description.VirtualNetworkGateway.Properties.Subscription",
	"tags":                            "Description.VirtualNetworkGateway.Tags",
	"title":                           "Description.VirtualNetworkGateway.name",
	"type":                            "Description.VirtualNetworkGateway.type",
	"vpn_client_configuration":        "Description.VirtualNetworkGateway.Properties.VPNClientConfiguration",
	"vpn_gateway_generation":          "Description.VirtualNetworkGateway.properties.vpnGatewayGeneration",
	"vpn_type":                        "Description.VirtualNetworkGateway.properties.vpnType",
}

func GetVirtualNetworkGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetVirtualNetworkGateway")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewVirtualNetworkGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, getVirtualNetworkGatewayFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: VirtualNetworkGateway =============================

// ==========================  START: FirewallPolicy =============================

type FirewallPolicy struct {
	ResourceID      string                          `json:"resource_id"`
	PlatformID      string                          `json:"platform_id"`
	Description     azure.FirewallPolicyDescription `json:"Description"`
	Metadata        azure.Metadata                  `json:"metadata"`
	DescribedBy     string                          `json:"described_by"`
	ResourceType    string                          `json:"resource_type"`
	IntegrationType string                          `json:"integration_type"`
	IntegrationID   string                          `json:"integration_id"`
}

type FirewallPolicyHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  FirewallPolicy `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type FirewallPolicyHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []FirewallPolicyHit `json:"hits"`
}

type FirewallPolicySearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  FirewallPolicyHits `json:"hits"`
}

type FirewallPolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewFirewallPolicyPaginator(filters []essdk.BoolFilter, limit *int64) (FirewallPolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_firewallpolicies", filters, limit)
	if err != nil {
		return FirewallPolicyPaginator{}, err
	}

	p := FirewallPolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p FirewallPolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p FirewallPolicyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p FirewallPolicyPaginator) NextPage(ctx context.Context) ([]FirewallPolicy, error) {
	var response FirewallPolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []FirewallPolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listFirewallPolicyFilters = map[string]string{
	"base_policy":                         "Description.FirewallPolicy.Properties.BasePolicy",
	"child_policies":                      "Description.FirewallPolicy.Properties.ChildPolicies",
	"dns_settings":                        "Description.FirewallPolicy.Properties.DNSSettings",
	"etag":                                "Description.FirewallPolicy.etag",
	"firewalls":                           "Description.FirewallPolicy.Properties.Firewalls",
	"id":                                  "Description.FirewallPolicy.id",
	"identity":                            "Description.FirewallPolicy.Identity",
	"intrusion_detection_configuration":   "Description.FirewallPolicy.Properties.IntrusionDetection.Configuration",
	"intrusion_detection_mode":            "Description.FirewallPolicy.properties.intrusionDetection.mode",
	"name":                                "Description.FirewallPolicy.name",
	"platform_integration_id":             "IntegrationID",
	"provisioning_state":                  "Description.FirewallPolicy.properties.provisioningState",
	"resource_group":                      "Description.ResourceGroup",
	"rule_collection_groups":              "Description.FirewallPolicy.Properties.RuleCollectionGroups",
	"sku_tier":                            "Description.FirewallPolicy.properties.sku.tier",
	"subscription":                        "Description.FirewallPolicy.Properties.Subscription",
	"tags":                                "Description.FirewallPolicy.Tags",
	"threat_intel_mode":                   "Description.FirewallPolicy.properties.threatIntelMode",
	"threat_intel_whitelist_fqdns":        "Description.FirewallPolicy.Properties.ThreatIntelWhitelist.Fqdns",
	"threat_intel_whitelist_ip_addresses": "Description.FirewallPolicy.Properties.ThreatIntelWhitelist.IPAddresses",
	"title":                               "Description.FirewallPolicy.name",
	"transport_security_certificate_authority": "Description.FirewallPolicy.Properties.TransportSecurity.CertificateAuthority",
	"type": "Description.FirewallPolicy.type",
}

func ListFirewallPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListFirewallPolicy")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListFirewallPolicy NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListFirewallPolicy NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListFirewallPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListFirewallPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListFirewallPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewFirewallPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listFirewallPolicyFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListFirewallPolicy NewFirewallPolicyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListFirewallPolicy paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getFirewallPolicyFilters = map[string]string{
	"base_policy":                         "Description.FirewallPolicy.Properties.BasePolicy",
	"child_policies":                      "Description.FirewallPolicy.Properties.ChildPolicies",
	"dns_settings":                        "Description.FirewallPolicy.Properties.DNSSettings",
	"etag":                                "Description.FirewallPolicy.etag",
	"firewalls":                           "Description.FirewallPolicy.Properties.Firewalls",
	"id":                                  "Description.FirewallPolicy.id",
	"identity":                            "Description.FirewallPolicy.Identity",
	"intrusion_detection_configuration":   "Description.FirewallPolicy.Properties.IntrusionDetection.Configuration",
	"intrusion_detection_mode":            "Description.FirewallPolicy.properties.intrusionDetection.mode",
	"name":                                "description.FirewallPolicy.Name",
	"platform_integration_id":             "IntegrationID",
	"provisioning_state":                  "Description.FirewallPolicy.properties.provisioningState",
	"resource_group":                      "description.ResourceGroup",
	"rule_collection_groups":              "Description.FirewallPolicy.Properties.RuleCollectionGroups",
	"sku_tier":                            "Description.FirewallPolicy.properties.sku.tier",
	"subscription":                        "Description.FirewallPolicy.Properties.Subscription",
	"tags":                                "Description.FirewallPolicy.Tags",
	"threat_intel_mode":                   "Description.FirewallPolicy.properties.threatIntelMode",
	"threat_intel_whitelist_fqdns":        "Description.FirewallPolicy.Properties.ThreatIntelWhitelist.Fqdns",
	"threat_intel_whitelist_ip_addresses": "Description.FirewallPolicy.Properties.ThreatIntelWhitelist.IPAddresses",
	"title":                               "Description.FirewallPolicy.name",
	"transport_security_certificate_authority": "Description.FirewallPolicy.Properties.TransportSecurity.CertificateAuthority",
	"type": "Description.FirewallPolicy.type",
}

func GetFirewallPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetFirewallPolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewFirewallPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getFirewallPolicyFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: FirewallPolicy =============================

// ==========================  START: LocalNetworkGateway =============================

type LocalNetworkGateway struct {
	ResourceID      string                               `json:"resource_id"`
	PlatformID      string                               `json:"platform_id"`
	Description     azure.LocalNetworkGatewayDescription `json:"Description"`
	Metadata        azure.Metadata                       `json:"metadata"`
	DescribedBy     string                               `json:"described_by"`
	ResourceType    string                               `json:"resource_type"`
	IntegrationType string                               `json:"integration_type"`
	IntegrationID   string                               `json:"integration_id"`
}

type LocalNetworkGatewayHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  LocalNetworkGateway `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type LocalNetworkGatewayHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []LocalNetworkGatewayHit `json:"hits"`
}

type LocalNetworkGatewaySearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  LocalNetworkGatewayHits `json:"hits"`
}

type LocalNetworkGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLocalNetworkGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (LocalNetworkGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_localnetworkgateways", filters, limit)
	if err != nil {
		return LocalNetworkGatewayPaginator{}, err
	}

	p := LocalNetworkGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LocalNetworkGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LocalNetworkGatewayPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LocalNetworkGatewayPaginator) NextPage(ctx context.Context) ([]LocalNetworkGateway, error) {
	var response LocalNetworkGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LocalNetworkGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLocalNetworkGatewayFilters = map[string]string{
	"id":                      "Description.LocalNetworkGateways.ID",
	"name":                    "Description.LocalNetworkGateway.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.LocalNetworkGateways.Properties.Subscription",
	"tags":                    "Description.LocalNetworkGateway.Tags",
	"title":                   "Description.LocalNetworkGateway.name",
}

func ListLocalNetworkGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLocalNetworkGateway")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLocalNetworkGateway NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLocalNetworkGateway NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLocalNetworkGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLocalNetworkGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLocalNetworkGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLocalNetworkGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, listLocalNetworkGatewayFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLocalNetworkGateway NewLocalNetworkGatewayPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLocalNetworkGateway paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLocalNetworkGatewayFilters = map[string]string{
	"id":                      "Description.LocalNetworkGateways.ID",
	"name":                    "description.LocalNetworkGateway.Name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "description.ResourceGroup",
	"subscription":            "Description.LocalNetworkGateways.Properties.Subscription",
	"tags":                    "Description.LocalNetworkGateway.Tags",
	"title":                   "Description.LocalNetworkGateway.name",
}

func GetLocalNetworkGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLocalNetworkGateway")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLocalNetworkGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, getLocalNetworkGatewayFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: LocalNetworkGateway =============================

// ==========================  START: NatGateway =============================

type NatGateway struct {
	ResourceID      string                      `json:"resource_id"`
	PlatformID      string                      `json:"platform_id"`
	Description     azure.NatGatewayDescription `json:"Description"`
	Metadata        azure.Metadata              `json:"metadata"`
	DescribedBy     string                      `json:"described_by"`
	ResourceType    string                      `json:"resource_type"`
	IntegrationType string                      `json:"integration_type"`
	IntegrationID   string                      `json:"integration_id"`
}

type NatGatewayHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  NatGateway    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type NatGatewayHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []NatGatewayHit   `json:"hits"`
}

type NatGatewaySearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  NatGatewayHits `json:"hits"`
}

type NatGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNatGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (NatGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_natgateways", filters, limit)
	if err != nil {
		return NatGatewayPaginator{}, err
	}

	p := NatGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NatGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NatGatewayPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p NatGatewayPaginator) NextPage(ctx context.Context) ([]NatGateway, error) {
	var response NatGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NatGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNatGatewayFilters = map[string]string{
	"etag":                    "Description.NatGateway.etag",
	"id":                      "Description.NatGateway.id",
	"name":                    "Description.NatGateway.name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "Description.ResourceGroup",
	"sku_name":                "Description.NatGateway.sku.name",
	"subscription":            "Description.NatGateway.Properties.Subscription",
	"tags":                    "Description.NatGateway.Tags",
	"title":                   "Description.NatGateway.name",
	"type":                    "Description.NatGateway.type",
	"zones":                   "Description.NatGateway.Zones",
}

func ListNatGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNatGateway")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListNatGateway NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListNatGateway NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListNatGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListNatGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListNatGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewNatGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, listNatGatewayFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListNatGateway NewNatGatewayPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListNatGateway paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getNatGatewayFilters = map[string]string{
	"etag":                    "Description.NatGateway.etag",
	"id":                      "Description.NatGateway.id",
	"name":                    "description.NatGateway.Name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "description.ResourceGroup",
	"sku_name":                "Description.NatGateway.sku.name",
	"subscription":            "Description.NatGateway.Properties.Subscription",
	"tags":                    "Description.NatGateway.Tags",
	"title":                   "Description.NatGateway.name",
	"type":                    "Description.NatGateway.type",
	"zones":                   "Description.NatGateway.Zones",
}

func GetNatGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNatGateway")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewNatGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, getNatGatewayFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: NatGateway =============================

// ==========================  START: PrivateLinkService =============================

type PrivateLinkService struct {
	ResourceID      string                              `json:"resource_id"`
	PlatformID      string                              `json:"platform_id"`
	Description     azure.PrivateLinkServiceDescription `json:"Description"`
	Metadata        azure.Metadata                      `json:"metadata"`
	DescribedBy     string                              `json:"described_by"`
	ResourceType    string                              `json:"resource_type"`
	IntegrationType string                              `json:"integration_type"`
	IntegrationID   string                              `json:"integration_id"`
}

type PrivateLinkServiceHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  PrivateLinkService `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type PrivateLinkServiceHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []PrivateLinkServiceHit `json:"hits"`
}

type PrivateLinkServiceSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  PrivateLinkServiceHits `json:"hits"`
}

type PrivateLinkServicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPrivateLinkServicePaginator(filters []essdk.BoolFilter, limit *int64) (PrivateLinkServicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_privatelinkservices", filters, limit)
	if err != nil {
		return PrivateLinkServicePaginator{}, err
	}

	p := PrivateLinkServicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PrivateLinkServicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PrivateLinkServicePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p PrivateLinkServicePaginator) NextPage(ctx context.Context) ([]PrivateLinkService, error) {
	var response PrivateLinkServiceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PrivateLinkService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPrivateLinkServiceFilters = map[string]string{
	"id":                      "Description.PrivateLinkServices.ID",
	"name":                    "Description.PrivateLinkService.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.PrivateLinkServices.Properties.Subscription",
	"tags":                    "Description.PrivateLinkService.Tags",
	"title":                   "Description.PrivateLinkService.name",
}

func ListPrivateLinkService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPrivateLinkService")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListPrivateLinkService NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListPrivateLinkService NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListPrivateLinkService GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListPrivateLinkService GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListPrivateLinkService GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewPrivateLinkServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, listPrivateLinkServiceFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListPrivateLinkService NewPrivateLinkServicePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListPrivateLinkService paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getPrivateLinkServiceFilters = map[string]string{
	"id":                      "Description.PrivateLinkServices.ID",
	"name":                    "description.PrivateLinkService.Name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "description.ResourceGroup",
	"subscription":            "Description.PrivateLinkServices.Properties.Subscription",
	"tags":                    "Description.PrivateLinkService.Tags",
	"title":                   "Description.PrivateLinkService.name",
}

func GetPrivateLinkService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPrivateLinkService")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewPrivateLinkServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, getPrivateLinkServiceFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: PrivateLinkService =============================

// ==========================  START: VpnGateway =============================

type VpnGateway struct {
	ResourceID      string                      `json:"resource_id"`
	PlatformID      string                      `json:"platform_id"`
	Description     azure.VpnGatewayDescription `json:"Description"`
	Metadata        azure.Metadata              `json:"metadata"`
	DescribedBy     string                      `json:"described_by"`
	ResourceType    string                      `json:"resource_type"`
	IntegrationType string                      `json:"integration_type"`
	IntegrationID   string                      `json:"integration_id"`
}

type VpnGatewayHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  VpnGateway    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type VpnGatewayHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []VpnGatewayHit   `json:"hits"`
}

type VpnGatewaySearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  VpnGatewayHits `json:"hits"`
}

type VpnGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewVpnGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (VpnGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_vpngateways", filters, limit)
	if err != nil {
		return VpnGatewayPaginator{}, err
	}

	p := VpnGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p VpnGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p VpnGatewayPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p VpnGatewayPaginator) NextPage(ctx context.Context) ([]VpnGateway, error) {
	var response VpnGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []VpnGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listVpnGatewayFilters = map[string]string{
	"id":                      "Description.VPNGateways.ID",
	"name":                    "Description.VpnGateway.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.VPNGateways.Properties.Subscription",
	"tags":                    "Description.VpnGateway.Tags",
	"title":                   "Description.VpnGateway.name",
}

func ListVpnGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListVpnGateway")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListVpnGateway NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListVpnGateway NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListVpnGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListVpnGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListVpnGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewVpnGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, listVpnGatewayFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListVpnGateway NewVpnGatewayPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListVpnGateway paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getVpnGatewayFilters = map[string]string{
	"id":                      "Description.VPNGateways.ID",
	"name":                    "description.VpnGateway.Name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "description.ResourceGroup",
	"subscription":            "Description.VPNGateways.Properties.Subscription",
	"tags":                    "Description.VpnGateway.Tags",
	"title":                   "Description.VpnGateway.name",
}

func GetVpnGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetVpnGateway")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewVpnGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, getVpnGatewayFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: VpnGateway =============================

// ==========================  START: VpnGatewayVpnConnection =============================

type VpnGatewayVpnConnection struct {
	ResourceID      string                                   `json:"resource_id"`
	PlatformID      string                                   `json:"platform_id"`
	Description     azure.VpnGatewayVpnConnectionDescription `json:"Description"`
	Metadata        azure.Metadata                           `json:"metadata"`
	DescribedBy     string                                   `json:"described_by"`
	ResourceType    string                                   `json:"resource_type"`
	IntegrationType string                                   `json:"integration_type"`
	IntegrationID   string                                   `json:"integration_id"`
}

type VpnGatewayVpnConnectionHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  VpnGatewayVpnConnection `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type VpnGatewayVpnConnectionHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []VpnGatewayVpnConnectionHit `json:"hits"`
}

type VpnGatewayVpnConnectionSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  VpnGatewayVpnConnectionHits `json:"hits"`
}

type VpnGatewayVpnConnectionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewVpnGatewayVpnConnectionPaginator(filters []essdk.BoolFilter, limit *int64) (VpnGatewayVpnConnectionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_vpngateways_vpnconnections", filters, limit)
	if err != nil {
		return VpnGatewayVpnConnectionPaginator{}, err
	}

	p := VpnGatewayVpnConnectionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p VpnGatewayVpnConnectionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p VpnGatewayVpnConnectionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p VpnGatewayVpnConnectionPaginator) NextPage(ctx context.Context) ([]VpnGatewayVpnConnection, error) {
	var response VpnGatewayVpnConnectionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []VpnGatewayVpnConnection
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listVpnGatewayVpnConnectionFilters = map[string]string{
	"id":                      "Description.VPNConnections.ID",
	"name":                    "Description.VpnConnection.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.VPNConnections.Properties.Subscription",
	"tags":                    "Description.VpnConnection.etag",
	"title":                   "Description.VpnConnection.name",
}

func ListVpnGatewayVpnConnection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListVpnGatewayVpnConnection")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListVpnGatewayVpnConnection NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListVpnGatewayVpnConnection NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListVpnGatewayVpnConnection GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListVpnGatewayVpnConnection GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListVpnGatewayVpnConnection GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewVpnGatewayVpnConnectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listVpnGatewayVpnConnectionFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListVpnGatewayVpnConnection NewVpnGatewayVpnConnectionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListVpnGatewayVpnConnection paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getVpnGatewayVpnConnectionFilters = map[string]string{
	"id":                      "Description.VPNConnections.ID",
	"name":                    "Description.VpnConnection.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.VPNConnections.Properties.Subscription",
	"tags":                    "Description.VpnConnection.etag",
	"title":                   "Description.VpnConnection.name",
}

func GetVpnGatewayVpnConnection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetVpnGatewayVpnConnection")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewVpnGatewayVpnConnectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getVpnGatewayVpnConnectionFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: VpnGatewayVpnConnection =============================

// ==========================  START: VpnSite =============================

type VpnSite struct {
	ResourceID      string                   `json:"resource_id"`
	PlatformID      string                   `json:"platform_id"`
	Description     azure.VpnSiteDescription `json:"Description"`
	Metadata        azure.Metadata           `json:"metadata"`
	DescribedBy     string                   `json:"described_by"`
	ResourceType    string                   `json:"resource_type"`
	IntegrationType string                   `json:"integration_type"`
	IntegrationID   string                   `json:"integration_id"`
}

type VpnSiteHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  VpnSite       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type VpnSiteHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []VpnSiteHit      `json:"hits"`
}

type VpnSiteSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  VpnSiteHits `json:"hits"`
}

type VpnSitePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewVpnSitePaginator(filters []essdk.BoolFilter, limit *int64) (VpnSitePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_vpnsites", filters, limit)
	if err != nil {
		return VpnSitePaginator{}, err
	}

	p := VpnSitePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p VpnSitePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p VpnSitePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p VpnSitePaginator) NextPage(ctx context.Context) ([]VpnSite, error) {
	var response VpnSiteSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []VpnSite
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listVpnSiteFilters = map[string]string{
	"id":                      "Description.VPNSites.ID",
	"name":                    "Description.VpnSite.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.VPNSites.Properties.Subscription",
	"tags":                    "Description.VpnSite.Tags",
	"title":                   "Description.VpnSite.name",
}

func ListVpnSite(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListVpnSite")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListVpnSite NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListVpnSite NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListVpnSite GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListVpnSite GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListVpnSite GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewVpnSitePaginator(essdk.BuildFilter(ctx, d.QueryContext, listVpnSiteFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListVpnSite NewVpnSitePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListVpnSite paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getVpnSiteFilters = map[string]string{
	"id":                      "Description.VPNSites.ID",
	"name":                    "Description.VpnSite.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.VPNSites.Properties.Subscription",
	"tags":                    "Description.VpnSite.Tags",
	"title":                   "Description.VpnSite.name",
}

func GetVpnSite(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetVpnSite")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewVpnSitePaginator(essdk.BuildFilter(ctx, d.QueryContext, getVpnSiteFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: VpnSite =============================

// ==========================  START: PublicIPAddress =============================

type PublicIPAddress struct {
	ResourceID      string                           `json:"resource_id"`
	PlatformID      string                           `json:"platform_id"`
	Description     azure.PublicIPAddressDescription `json:"Description"`
	Metadata        azure.Metadata                   `json:"metadata"`
	DescribedBy     string                           `json:"described_by"`
	ResourceType    string                           `json:"resource_type"`
	IntegrationType string                           `json:"integration_type"`
	IntegrationID   string                           `json:"integration_id"`
}

type PublicIPAddressHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  PublicIPAddress `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type PublicIPAddressHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []PublicIPAddressHit `json:"hits"`
}

type PublicIPAddressSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  PublicIPAddressHits `json:"hits"`
}

type PublicIPAddressPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPublicIPAddressPaginator(filters []essdk.BoolFilter, limit *int64) (PublicIPAddressPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_publicipaddresses", filters, limit)
	if err != nil {
		return PublicIPAddressPaginator{}, err
	}

	p := PublicIPAddressPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PublicIPAddressPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PublicIPAddressPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p PublicIPAddressPaginator) NextPage(ctx context.Context) ([]PublicIPAddress, error) {
	var response PublicIPAddressSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PublicIPAddress
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPublicIPAddressFilters = map[string]string{
	"ddos_custom_policy_id":             "Description.PublicIPAddress.properties.ddosSettings.ddosCustomPolicy.id",
	"ddos_settings_protected_ip":        "Description.PublicIPAddress.properties.ddosSettings.protectedIP",
	"ddos_settings_protection_coverage": "Description.PublicIPAddress.properties.ddosSettings.protectionCoverage",
	"dns_settings_domain_name_label":    "Description.PublicIPAddress.properties.dnsSettings.domainNameLabel",
	"dns_settings_fqdn":                 "Description.PublicIPAddress.properties.dnsSettings.fqdn",
	"dns_settings_reverse_fqdn":         "Description.PublicIPAddress.properties.dnsSettings.reverseFqdn",
	"etag":                              "Description.PublicIPAddress.etag",
	"id":                                "Description.PublicIPAddress.id",
	"idle_timeout_in_minutes":           "Description.PublicIPAddress.properties.idleTimeoutInMinutes",
	"ip_address":                        "Description.PublicIPAddress.properties.ipAddress",
	"ip_configuration_id":               "Description.PublicIPAddress.properties.ipConfiguration.id",
	"ip_tags":                           "Description.PublicIPAddress.PublicIPAddressPropertiesFormat.IPTags",
	"name":                              "Description.PublicIPAddress.name",
	"platform_integration_id":           "IntegrationID",
	"provisioning_state":                "Description.PublicIPAddress.properties.provisioningState",
	"public_ip_address_version":         "Description.PublicIPAddress.properties.publicIPAddressVersion",
	"public_ip_allocation_method":       "Description.PublicIPAddress.properties.publicIPAllocationMethod",
	"public_ip_prefix_id":               "Description.PublicIPAddress.properties.publicIPPrefix.id",
	"resource_group":                    "Description.ResourceGroup",
	"resource_guid":                     "Description.PublicIPAddress.properties.resourceGuid",
	"sku_name":                          "Description.PublicIPAddress.sku.name",
	"subscription":                      "Description.PublicIPAddress.Properties.Subscription",
	"tags":                              "Description.PublicIPAddress.Tags",
	"title":                             "Description.PublicIPAddress.name",
	"type":                              "Description.PublicIPAddress.type",
	"zones":                             "Description.PublicIPAddress.Zones",
}

func ListPublicIPAddress(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPublicIPAddress")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListPublicIPAddress NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListPublicIPAddress NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListPublicIPAddress GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListPublicIPAddress GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListPublicIPAddress GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewPublicIPAddressPaginator(essdk.BuildFilter(ctx, d.QueryContext, listPublicIPAddressFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListPublicIPAddress NewPublicIPAddressPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListPublicIPAddress paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getPublicIPAddressFilters = map[string]string{
	"ddos_custom_policy_id":             "Description.PublicIPAddress.properties.ddosSettings.ddosCustomPolicy.id",
	"ddos_settings_protected_ip":        "Description.PublicIPAddress.properties.ddosSettings.protectedIP",
	"ddos_settings_protection_coverage": "Description.PublicIPAddress.properties.ddosSettings.protectionCoverage",
	"dns_settings_domain_name_label":    "Description.PublicIPAddress.properties.dnsSettings.domainNameLabel",
	"dns_settings_fqdn":                 "Description.PublicIPAddress.properties.dnsSettings.fqdn",
	"dns_settings_reverse_fqdn":         "Description.PublicIPAddress.properties.dnsSettings.reverseFqdn",
	"etag":                              "Description.PublicIPAddress.etag",
	"id":                                "Description.PublicIPAddress.id",
	"idle_timeout_in_minutes":           "Description.PublicIPAddress.properties.idleTimeoutInMinutes",
	"ip_address":                        "Description.PublicIPAddress.properties.ipAddress",
	"ip_configuration_id":               "Description.PublicIPAddress.properties.ipConfiguration.id",
	"ip_tags":                           "Description.PublicIPAddress.PublicIPAddressPropertiesFormat.IPTags",
	"name":                              "description.PublicIPAddress.Name",
	"platform_integration_id":           "IntegrationID",
	"provisioning_state":                "Description.PublicIPAddress.properties.provisioningState",
	"public_ip_address_version":         "Description.PublicIPAddress.properties.publicIPAddressVersion",
	"public_ip_allocation_method":       "Description.PublicIPAddress.properties.publicIPAllocationMethod",
	"public_ip_prefix_id":               "Description.PublicIPAddress.properties.publicIPPrefix.id",
	"resource_group":                    "description.ResourceGroup",
	"resource_guid":                     "Description.PublicIPAddress.properties.resourceGuid",
	"sku_name":                          "Description.PublicIPAddress.sku.name",
	"subscription":                      "Description.PublicIPAddress.Properties.Subscription",
	"tags":                              "Description.PublicIPAddress.Tags",
	"title":                             "Description.PublicIPAddress.name",
	"type":                              "Description.PublicIPAddress.type",
	"zones":                             "Description.PublicIPAddress.Zones",
}

func GetPublicIPAddress(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPublicIPAddress")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewPublicIPAddressPaginator(essdk.BuildFilter(ctx, d.QueryContext, getPublicIPAddressFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: PublicIPAddress =============================

// ==========================  START: PublicIPPrefix =============================

type PublicIPPrefix struct {
	ResourceID      string                          `json:"resource_id"`
	PlatformID      string                          `json:"platform_id"`
	Description     azure.PublicIPPrefixDescription `json:"Description"`
	Metadata        azure.Metadata                  `json:"metadata"`
	DescribedBy     string                          `json:"described_by"`
	ResourceType    string                          `json:"resource_type"`
	IntegrationType string                          `json:"integration_type"`
	IntegrationID   string                          `json:"integration_id"`
}

type PublicIPPrefixHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  PublicIPPrefix `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type PublicIPPrefixHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []PublicIPPrefixHit `json:"hits"`
}

type PublicIPPrefixSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  PublicIPPrefixHits `json:"hits"`
}

type PublicIPPrefixPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPublicIPPrefixPaginator(filters []essdk.BoolFilter, limit *int64) (PublicIPPrefixPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_publicipprefixes", filters, limit)
	if err != nil {
		return PublicIPPrefixPaginator{}, err
	}

	p := PublicIPPrefixPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PublicIPPrefixPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PublicIPPrefixPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p PublicIPPrefixPaginator) NextPage(ctx context.Context) ([]PublicIPPrefix, error) {
	var response PublicIPPrefixSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PublicIPPrefix
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPublicIPPrefixFilters = map[string]string{
	"id":                      "Description.PublicIPPrefixes.ID",
	"name":                    "Description.PublicIPPrefix.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.PublicIPPrefixes.Properties.Subscription",
	"tags":                    "Description.PublicIPPrefix.Tags",
	"title":                   "Description.PublicIPPrefix.name",
}

func ListPublicIPPrefix(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPublicIPPrefix")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListPublicIPPrefix NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListPublicIPPrefix NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListPublicIPPrefix GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListPublicIPPrefix GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListPublicIPPrefix GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewPublicIPPrefixPaginator(essdk.BuildFilter(ctx, d.QueryContext, listPublicIPPrefixFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListPublicIPPrefix NewPublicIPPrefixPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListPublicIPPrefix paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getPublicIPPrefixFilters = map[string]string{
	"id":                      "Description.PublicIPPrefixes.ID",
	"name":                    "Description.PublicIPPrefix.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.PublicIPPrefixes.Properties.Subscription",
	"tags":                    "Description.PublicIPPrefix.Tags",
	"title":                   "Description.PublicIPPrefix.name",
}

func GetPublicIPPrefix(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPublicIPPrefix")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewPublicIPPrefixPaginator(essdk.BuildFilter(ctx, d.QueryContext, getPublicIPPrefixFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: PublicIPPrefix =============================

// ==========================  START: DNSZones =============================

type DNSZones struct {
	ResourceID      string                    `json:"resource_id"`
	PlatformID      string                    `json:"platform_id"`
	Description     azure.DNSZonesDescription `json:"Description"`
	Metadata        azure.Metadata            `json:"metadata"`
	DescribedBy     string                    `json:"described_by"`
	ResourceType    string                    `json:"resource_type"`
	IntegrationType string                    `json:"integration_type"`
	IntegrationID   string                    `json:"integration_id"`
}

type DNSZonesHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  DNSZones      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DNSZonesHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []DNSZonesHit     `json:"hits"`
}

type DNSZonesSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  DNSZonesHits `json:"hits"`
}

type DNSZonesPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDNSZonesPaginator(filters []essdk.BoolFilter, limit *int64) (DNSZonesPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_dnszones", filters, limit)
	if err != nil {
		return DNSZonesPaginator{}, err
	}

	p := DNSZonesPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DNSZonesPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DNSZonesPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DNSZonesPaginator) NextPage(ctx context.Context) ([]DNSZones, error) {
	var response DNSZonesSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DNSZones
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDNSZonesFilters = map[string]string{
	"etag":                                 "Description.Zone.Etag",
	"id":                                   "Description.Zone.ID",
	"max_number_of_record_sets":            "Description.Zone.Properties.MaxNumberOfRecordSets",
	"max_number_of_records_per_record_set": "Description.Zone.Properties.MaxNumberOfRecordsPerRecordSet",
	"name":                                 "Description.Zone.Name",
	"name_servers":                         "Description.Zone.Properties.NameServers",
	"number_of_record_sets":                "Description.Zone.Properties.NumberOfRecordSets",
	"platform_integration_id":              "IntegrationID",
	"registration_virtual_networks":        "Description.Zone.Properties.RegistrationVirtualNetworks",
	"resolution_virtual_networks":          "Description.Zone.Properties.ResolutionVirtualNetworks",
	"resource_group":                       "Description.ResourceGroup",
	"subscription":                         "Description.Zone.Properties.Subscription",
	"tags":                                 "Description.Zone.Tags",
	"title":                                "Description.Zone.Name",
	"type":                                 "Description.Zone.Type",
	"zone_type":                            "Description.Zone.Properties.ZoneType",
}

func ListDNSZones(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDNSZones")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDNSZones NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDNSZones NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDNSZones GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDNSZones GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDNSZones GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDNSZonesPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDNSZonesFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDNSZones NewDNSZonesPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDNSZones paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDNSZonesFilters = map[string]string{
	"etag":                                 "Description.Zone.Etag",
	"id":                                   "Description.Zone.ID",
	"max_number_of_record_sets":            "Description.Zone.Properties.MaxNumberOfRecordSets",
	"max_number_of_records_per_record_set": "Description.Zone.Properties.MaxNumberOfRecordsPerRecordSet",
	"name":                                 "Description.Zone.Name",
	"name_servers":                         "Description.Zone.Properties.NameServers",
	"number_of_record_sets":                "Description.Zone.Properties.NumberOfRecordSets",
	"platform_integration_id":              "IntegrationID",
	"registration_virtual_networks":        "Description.Zone.Properties.RegistrationVirtualNetworks",
	"resolution_virtual_networks":          "Description.Zone.Properties.ResolutionVirtualNetworks",
	"resource_group":                       "Description.ResourceGroup",
	"subscription":                         "Description.Zone.Properties.Subscription",
	"tags":                                 "Description.Zone.Tags",
	"title":                                "Description.Zone.Name",
	"type":                                 "Description.Zone.Type",
	"zone_type":                            "Description.Zone.Properties.ZoneType",
}

func GetDNSZones(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDNSZones")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDNSZonesPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDNSZonesFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DNSZones =============================

// ==========================  START: BastionHosts =============================

type BastionHosts struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     azure.BastionHostsDescription `json:"Description"`
	Metadata        azure.Metadata                `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type BastionHostsHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  BastionHosts  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type BastionHostsHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []BastionHostsHit `json:"hits"`
}

type BastionHostsSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  BastionHostsHits `json:"hits"`
}

type BastionHostsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBastionHostsPaginator(filters []essdk.BoolFilter, limit *int64) (BastionHostsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_bastionhosts", filters, limit)
	if err != nil {
		return BastionHostsPaginator{}, err
	}

	p := BastionHostsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BastionHostsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BastionHostsPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BastionHostsPaginator) NextPage(ctx context.Context) ([]BastionHosts, error) {
	var response BastionHostsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BastionHosts
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBastionHostsFilters = map[string]string{
	"dns_name":                "Description.BastianHost.properties.dnsName",
	"etag":                    "Description.BastianHost.etag",
	"id":                      "Description.BastianHost.id",
	"ip_configurations":       "Description.BastianHost.Properties.IPConfigurations",
	"name":                    "Description.BastianHost.name",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.BastianHost.properties.provisioningState",
	"region":                  "Description.BastianHost.location",
	"resource_group":          "Description.ResourceGroup",
	"subscription":            "Description.BastianHost.Properties.Subscription",
	"tags":                    "Description.BastianHost.Tags",
	"title":                   "Description.BastianHost.name",
	"type":                    "Description.BastianHost.type",
}

func ListBastionHosts(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBastionHosts")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBastionHosts NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBastionHosts NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBastionHosts GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBastionHosts GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBastionHosts GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBastionHostsPaginator(essdk.BuildFilter(ctx, d.QueryContext, listBastionHostsFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBastionHosts NewBastionHostsPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBastionHosts paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBastionHostsFilters = map[string]string{
	"dns_name":                "Description.BastianHost.properties.dnsName",
	"etag":                    "Description.BastianHost.etag",
	"id":                      "Description.BastianHost.id",
	"ip_configurations":       "Description.BastianHost.Properties.IPConfigurations",
	"name":                    "Description.BastianHost.name",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.BastianHost.properties.provisioningState",
	"region":                  "Description.BastianHost.location",
	"resource_group":          "Description.ResourceGroup",
	"subscription":            "Description.BastianHost.Properties.Subscription",
	"tags":                    "Description.BastianHost.Tags",
	"title":                   "Description.BastianHost.name",
	"type":                    "Description.BastianHost.type",
}

func GetBastionHosts(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBastionHosts")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBastionHostsPaginator(essdk.BuildFilter(ctx, d.QueryContext, getBastionHostsFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: BastionHosts =============================

// ==========================  START: Connection =============================

type Connection struct {
	ResourceID      string                      `json:"resource_id"`
	PlatformID      string                      `json:"platform_id"`
	Description     azure.ConnectionDescription `json:"Description"`
	Metadata        azure.Metadata              `json:"metadata"`
	DescribedBy     string                      `json:"described_by"`
	ResourceType    string                      `json:"resource_type"`
	IntegrationType string                      `json:"integration_type"`
	IntegrationID   string                      `json:"integration_id"`
}

type ConnectionHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Connection    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ConnectionHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ConnectionHit   `json:"hits"`
}

type ConnectionSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  ConnectionHits `json:"hits"`
}

type ConnectionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewConnectionPaginator(filters []essdk.BoolFilter, limit *int64) (ConnectionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_connections", filters, limit)
	if err != nil {
		return ConnectionPaginator{}, err
	}

	p := ConnectionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ConnectionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ConnectionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ConnectionPaginator) NextPage(ctx context.Context) ([]Connection, error) {
	var response ConnectionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Connection
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listConnectionFilters = map[string]string{
	"id":                      "Description.Connection.id",
	"name":                    "Description.Connection.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Connection.Properties.Subscription",
	"tags":                    "Description.Connection.Tags",
	"title":                   "Description.Connection.name",
}

func ListConnection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListConnection")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListConnection NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListConnection NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListConnection GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListConnection GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListConnection GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewConnectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listConnectionFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListConnection NewConnectionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListConnection paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getConnectionFilters = map[string]string{
	"id":                      "Description.Connection.id",
	"name":                    "Description.Connection.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Connection.Properties.Subscription",
	"tags":                    "Description.Connection.Tags",
	"title":                   "Description.Connection.name",
}

func GetConnection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetConnection")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewConnectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getConnectionFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Connection =============================

// ==========================  START: VirtualHubs =============================

type VirtualHubs struct {
	ResourceID      string                       `json:"resource_id"`
	PlatformID      string                       `json:"platform_id"`
	Description     azure.VirtualHubsDescription `json:"Description"`
	Metadata        azure.Metadata               `json:"metadata"`
	DescribedBy     string                       `json:"described_by"`
	ResourceType    string                       `json:"resource_type"`
	IntegrationType string                       `json:"integration_type"`
	IntegrationID   string                       `json:"integration_id"`
}

type VirtualHubsHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  VirtualHubs   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type VirtualHubsHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []VirtualHubsHit  `json:"hits"`
}

type VirtualHubsSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  VirtualHubsHits `json:"hits"`
}

type VirtualHubsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewVirtualHubsPaginator(filters []essdk.BoolFilter, limit *int64) (VirtualHubsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_virtualhubs", filters, limit)
	if err != nil {
		return VirtualHubsPaginator{}, err
	}

	p := VirtualHubsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p VirtualHubsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p VirtualHubsPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p VirtualHubsPaginator) NextPage(ctx context.Context) ([]VirtualHubs, error) {
	var response VirtualHubsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []VirtualHubs
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listVirtualHubsFilters = map[string]string{
	"id":                      "Description.VirtualHubs.ID",
	"name":                    "Description.VirtualHub.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.VirtualHubs.Properties.Subscription",
	"tags":                    "Description.VirtualHub.Tags",
	"title":                   "Description.VirtualHub.name",
}

func ListVirtualHubs(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListVirtualHubs")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualHubs NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualHubs NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualHubs GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualHubs GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualHubs GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewVirtualHubsPaginator(essdk.BuildFilter(ctx, d.QueryContext, listVirtualHubsFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualHubs NewVirtualHubsPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListVirtualHubs paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getVirtualHubsFilters = map[string]string{
	"id":                      "Description.VirtualHubs.ID",
	"name":                    "Description.VirtualHub.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.VirtualHubs.Properties.Subscription",
	"tags":                    "Description.VirtualHub.Tags",
	"title":                   "Description.VirtualHub.name",
}

func GetVirtualHubs(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetVirtualHubs")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewVirtualHubsPaginator(essdk.BuildFilter(ctx, d.QueryContext, getVirtualHubsFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: VirtualHubs =============================

// ==========================  START: VirtualWans =============================

type VirtualWans struct {
	ResourceID      string                       `json:"resource_id"`
	PlatformID      string                       `json:"platform_id"`
	Description     azure.VirtualWansDescription `json:"Description"`
	Metadata        azure.Metadata               `json:"metadata"`
	DescribedBy     string                       `json:"described_by"`
	ResourceType    string                       `json:"resource_type"`
	IntegrationType string                       `json:"integration_type"`
	IntegrationID   string                       `json:"integration_id"`
}

type VirtualWansHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  VirtualWans   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type VirtualWansHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []VirtualWansHit  `json:"hits"`
}

type VirtualWansSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  VirtualWansHits `json:"hits"`
}

type VirtualWansPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewVirtualWansPaginator(filters []essdk.BoolFilter, limit *int64) (VirtualWansPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_virtualwans", filters, limit)
	if err != nil {
		return VirtualWansPaginator{}, err
	}

	p := VirtualWansPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p VirtualWansPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p VirtualWansPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p VirtualWansPaginator) NextPage(ctx context.Context) ([]VirtualWans, error) {
	var response VirtualWansSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []VirtualWans
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listVirtualWansFilters = map[string]string{
	"id":                      "Description.VirtualWans.ID",
	"name":                    "Description.VirtualWan.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.VirtualWans.Properties.Subscription",
	"tags":                    "Description.VirtualWan.Tags",
	"title":                   "Description.VirtualWan.name",
}

func ListVirtualWans(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListVirtualWans")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualWans NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualWans NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualWans GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualWans GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualWans GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewVirtualWansPaginator(essdk.BuildFilter(ctx, d.QueryContext, listVirtualWansFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualWans NewVirtualWansPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListVirtualWans paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getVirtualWansFilters = map[string]string{
	"id":                      "Description.VirtualWans.ID",
	"name":                    "Description.VirtualWan.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.VirtualWans.Properties.Subscription",
	"tags":                    "Description.VirtualWan.Tags",
	"title":                   "Description.VirtualWan.name",
}

func GetVirtualWans(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetVirtualWans")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewVirtualWansPaginator(essdk.BuildFilter(ctx, d.QueryContext, getVirtualWansFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: VirtualWans =============================

// ==========================  START: DNSResolver =============================

type DNSResolver struct {
	ResourceID      string                       `json:"resource_id"`
	PlatformID      string                       `json:"platform_id"`
	Description     azure.DNSResolverDescription `json:"Description"`
	Metadata        azure.Metadata               `json:"metadata"`
	DescribedBy     string                       `json:"described_by"`
	ResourceType    string                       `json:"resource_type"`
	IntegrationType string                       `json:"integration_type"`
	IntegrationID   string                       `json:"integration_id"`
}

type DNSResolverHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  DNSResolver   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DNSResolverHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []DNSResolverHit  `json:"hits"`
}

type DNSResolverSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  DNSResolverHits `json:"hits"`
}

type DNSResolverPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDNSResolverPaginator(filters []essdk.BoolFilter, limit *int64) (DNSResolverPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_dnsresolvers", filters, limit)
	if err != nil {
		return DNSResolverPaginator{}, err
	}

	p := DNSResolverPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DNSResolverPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DNSResolverPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DNSResolverPaginator) NextPage(ctx context.Context) ([]DNSResolver, error) {
	var response DNSResolverSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DNSResolver
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDNSResolverFilters = map[string]string{
	"id":                      "Description.DNSResolver.id",
	"name":                    "Description.DNSResolver.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.DNSResolver.Properties.Subscription",
	"tags":                    "Description.DNSResolver.Tags",
	"title":                   "Description.DNSResolver.name",
}

func ListDNSResolver(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDNSResolver")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDNSResolver NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDNSResolver NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDNSResolver GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDNSResolver GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDNSResolver GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDNSResolverPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDNSResolverFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDNSResolver NewDNSResolverPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDNSResolver paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDNSResolverFilters = map[string]string{
	"id":                      "Description.DNSResolver.id",
	"name":                    "Description.DNSResolver.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.DNSResolver.Properties.Subscription",
	"tags":                    "Description.DNSResolver.Tags",
	"title":                   "Description.DNSResolver.name",
}

func GetDNSResolver(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDNSResolver")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDNSResolverPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDNSResolverFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DNSResolver =============================

// ==========================  START: TrafficManagerProfile =============================

type TrafficManagerProfile struct {
	ResourceID      string                                 `json:"resource_id"`
	PlatformID      string                                 `json:"platform_id"`
	Description     azure.TrafficManagerProfileDescription `json:"Description"`
	Metadata        azure.Metadata                         `json:"metadata"`
	DescribedBy     string                                 `json:"described_by"`
	ResourceType    string                                 `json:"resource_type"`
	IntegrationType string                                 `json:"integration_type"`
	IntegrationID   string                                 `json:"integration_id"`
}

type TrafficManagerProfileHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  TrafficManagerProfile `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type TrafficManagerProfileHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []TrafficManagerProfileHit `json:"hits"`
}

type TrafficManagerProfileSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  TrafficManagerProfileHits `json:"hits"`
}

type TrafficManagerProfilePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewTrafficManagerProfilePaginator(filters []essdk.BoolFilter, limit *int64) (TrafficManagerProfilePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_trafficmanagerprofiles", filters, limit)
	if err != nil {
		return TrafficManagerProfilePaginator{}, err
	}

	p := TrafficManagerProfilePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p TrafficManagerProfilePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p TrafficManagerProfilePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p TrafficManagerProfilePaginator) NextPage(ctx context.Context) ([]TrafficManagerProfile, error) {
	var response TrafficManagerProfileSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []TrafficManagerProfile
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listTrafficManagerProfileFilters = map[string]string{
	"id":           "Description.Profile.id",
	"name":         "Description.Profile.name",
	"subscription": "Description.Profile.Properties.Subscription",
	"tags":         "Description.Profile.Tags",
	"title":        "Description.Profile.name",
}

func ListTrafficManagerProfile(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListTrafficManagerProfile")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficManagerProfile NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficManagerProfile NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficManagerProfile GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficManagerProfile GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficManagerProfile GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewTrafficManagerProfilePaginator(essdk.BuildFilter(ctx, d.QueryContext, listTrafficManagerProfileFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListTrafficManagerProfile NewTrafficManagerProfilePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListTrafficManagerProfile paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getTrafficManagerProfileFilters = map[string]string{
	"id":           "Description.Profile.id",
	"name":         "Description.Profile.name",
	"subscription": "Description.Profile.Properties.Subscription",
	"tags":         "Description.Profile.Tags",
	"title":        "Description.Profile.name",
}

func GetTrafficManagerProfile(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetTrafficManagerProfile")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewTrafficManagerProfilePaginator(essdk.BuildFilter(ctx, d.QueryContext, getTrafficManagerProfileFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: TrafficManagerProfile =============================

// ==========================  START: PrivateDNSZones =============================

type PrivateDNSZones struct {
	ResourceID      string                           `json:"resource_id"`
	PlatformID      string                           `json:"platform_id"`
	Description     azure.PrivateDNSZonesDescription `json:"Description"`
	Metadata        azure.Metadata                   `json:"metadata"`
	DescribedBy     string                           `json:"described_by"`
	ResourceType    string                           `json:"resource_type"`
	IntegrationType string                           `json:"integration_type"`
	IntegrationID   string                           `json:"integration_id"`
}

type PrivateDNSZonesHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  PrivateDNSZones `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type PrivateDNSZonesHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []PrivateDNSZonesHit `json:"hits"`
}

type PrivateDNSZonesSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  PrivateDNSZonesHits `json:"hits"`
}

type PrivateDNSZonesPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPrivateDNSZonesPaginator(filters []essdk.BoolFilter, limit *int64) (PrivateDNSZonesPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_privatednszones", filters, limit)
	if err != nil {
		return PrivateDNSZonesPaginator{}, err
	}

	p := PrivateDNSZonesPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PrivateDNSZonesPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PrivateDNSZonesPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p PrivateDNSZonesPaginator) NextPage(ctx context.Context) ([]PrivateDNSZones, error) {
	var response PrivateDNSZonesSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PrivateDNSZones
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPrivateDNSZonesFilters = map[string]string{
	"etag":                                "Description.PrivateZone.etag",
	"id":                                  "Description.PrivateZone.id",
	"max_number_of_record_sets":           "Description.PrivateZone.properties.maxNumberOfRecordSets",
	"max_number_of_virtual_network_links": "Description.PrivateZone.properties.maxNumberOfVirtualNetworkLinks",
	"max_number_of_virtual_network_links_with_registration": "Description.PrivateZone.properties.maxNumberOfVirtualNetworkLinksWithRegistration",
	"name":                            "Description.PrivateZone.name",
	"number_of_record_sets":           "Description.PrivateZone.properties.numberOfRecordSets",
	"number_of_virtual_network_links": "Description.PrivateZone.properties.numberOfVirtualNetworkLinks",
	"number_of_virtual_network_links_with_registration": "Description.PrivateZone.properties.numberOfVirtualNetworkLinksWithRegistration",
	"platform_integration_id":                           "IntegrationID",
	"provisioning_state":                                "Description.PrivateZone.properties.provisioningState",
	"resource_group":                                    "Description.ResourceGroup",
	"subscription":                                      "Description.PrivateZone.Properties.Subscription",
	"tags":                                              "Description.PrivateZone.Tags",
	"title":                                             "Description.PrivateZone.name",
	"type":                                              "Description.PrivateZone.type",
}

func ListPrivateDNSZones(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPrivateDNSZones")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListPrivateDNSZones NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListPrivateDNSZones NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListPrivateDNSZones GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListPrivateDNSZones GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListPrivateDNSZones GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewPrivateDNSZonesPaginator(essdk.BuildFilter(ctx, d.QueryContext, listPrivateDNSZonesFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListPrivateDNSZones NewPrivateDNSZonesPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListPrivateDNSZones paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getPrivateDNSZonesFilters = map[string]string{
	"etag":                                "Description.PrivateZone.etag",
	"id":                                  "Description.PrivateZone.id",
	"max_number_of_record_sets":           "Description.PrivateZone.properties.maxNumberOfRecordSets",
	"max_number_of_virtual_network_links": "Description.PrivateZone.properties.maxNumberOfVirtualNetworkLinks",
	"max_number_of_virtual_network_links_with_registration": "Description.PrivateZone.properties.maxNumberOfVirtualNetworkLinksWithRegistration",
	"name":                            "Description.PrivateZone.name",
	"number_of_record_sets":           "Description.PrivateZone.properties.numberOfRecordSets",
	"number_of_virtual_network_links": "Description.PrivateZone.properties.numberOfVirtualNetworkLinks",
	"number_of_virtual_network_links_with_registration": "Description.PrivateZone.properties.numberOfVirtualNetworkLinksWithRegistration",
	"platform_integration_id":                           "IntegrationID",
	"provisioning_state":                                "Description.PrivateZone.properties.provisioningState",
	"resource_group":                                    "Description.ResourceGroup",
	"subscription":                                      "Description.PrivateZone.Properties.Subscription",
	"tags":                                              "Description.PrivateZone.Tags",
	"title":                                             "Description.PrivateZone.name",
	"type":                                              "Description.PrivateZone.type",
}

func GetPrivateDNSZones(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPrivateDNSZones")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewPrivateDNSZonesPaginator(essdk.BuildFilter(ctx, d.QueryContext, getPrivateDNSZonesFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: PrivateDNSZones =============================

// ==========================  START: PrivateEndpoint =============================

type PrivateEndpoint struct {
	ResourceID      string                           `json:"resource_id"`
	PlatformID      string                           `json:"platform_id"`
	Description     azure.PrivateEndpointDescription `json:"Description"`
	Metadata        azure.Metadata                   `json:"metadata"`
	DescribedBy     string                           `json:"described_by"`
	ResourceType    string                           `json:"resource_type"`
	IntegrationType string                           `json:"integration_type"`
	IntegrationID   string                           `json:"integration_id"`
}

type PrivateEndpointHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  PrivateEndpoint `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type PrivateEndpointHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []PrivateEndpointHit `json:"hits"`
}

type PrivateEndpointSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  PrivateEndpointHits `json:"hits"`
}

type PrivateEndpointPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPrivateEndpointPaginator(filters []essdk.BoolFilter, limit *int64) (PrivateEndpointPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_privateendpoints", filters, limit)
	if err != nil {
		return PrivateEndpointPaginator{}, err
	}

	p := PrivateEndpointPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PrivateEndpointPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PrivateEndpointPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p PrivateEndpointPaginator) NextPage(ctx context.Context) ([]PrivateEndpoint, error) {
	var response PrivateEndpointSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PrivateEndpoint
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPrivateEndpointFilters = map[string]string{
	"id":                      "Description.PrivateEndpoints.ID",
	"name":                    "Description.PrivateEndpoint.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.PrivateEndpoints.Properties.Subscription",
	"tags":                    "Description.PrivateEndpoint.Tags",
	"title":                   "Description.PrivateEndpoint.name",
}

func ListPrivateEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPrivateEndpoint")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListPrivateEndpoint NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListPrivateEndpoint NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListPrivateEndpoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListPrivateEndpoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListPrivateEndpoint GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewPrivateEndpointPaginator(essdk.BuildFilter(ctx, d.QueryContext, listPrivateEndpointFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListPrivateEndpoint NewPrivateEndpointPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListPrivateEndpoint paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getPrivateEndpointFilters = map[string]string{
	"id":                      "Description.PrivateEndpoints.ID",
	"name":                    "Description.PrivateEndpoint.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.PrivateEndpoints.Properties.Subscription",
	"tags":                    "Description.PrivateEndpoint.Tags",
	"title":                   "Description.PrivateEndpoint.name",
}

func GetPrivateEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPrivateEndpoint")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewPrivateEndpointPaginator(essdk.BuildFilter(ctx, d.QueryContext, getPrivateEndpointFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: PrivateEndpoint =============================

// ==========================  START: NetworkDDoSProtectionPlan =============================

type NetworkDDoSProtectionPlan struct {
	ResourceID      string                                     `json:"resource_id"`
	PlatformID      string                                     `json:"platform_id"`
	Description     azure.NetworkDDoSProtectionPlanDescription `json:"Description"`
	Metadata        azure.Metadata                             `json:"metadata"`
	DescribedBy     string                                     `json:"described_by"`
	ResourceType    string                                     `json:"resource_type"`
	IntegrationType string                                     `json:"integration_type"`
	IntegrationID   string                                     `json:"integration_id"`
}

type NetworkDDoSProtectionPlanHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  NetworkDDoSProtectionPlan `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type NetworkDDoSProtectionPlanHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []NetworkDDoSProtectionPlanHit `json:"hits"`
}

type NetworkDDoSProtectionPlanSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  NetworkDDoSProtectionPlanHits `json:"hits"`
}

type NetworkDDoSProtectionPlanPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNetworkDDoSProtectionPlanPaginator(filters []essdk.BoolFilter, limit *int64) (NetworkDDoSProtectionPlanPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_ddosprotectionplans", filters, limit)
	if err != nil {
		return NetworkDDoSProtectionPlanPaginator{}, err
	}

	p := NetworkDDoSProtectionPlanPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NetworkDDoSProtectionPlanPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NetworkDDoSProtectionPlanPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p NetworkDDoSProtectionPlanPaginator) NextPage(ctx context.Context) ([]NetworkDDoSProtectionPlan, error) {
	var response NetworkDDoSProtectionPlanSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NetworkDDoSProtectionPlan
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNetworkDDoSProtectionPlanFilters = map[string]string{
	"id":           "Description.DDoSProtectionPlan.id",
	"name":         "Description.DDoSProtectionPlan.name",
	"subscription": "Description.DDoSProtectionPlan.Properties.Subscription",
	"tags":         "Description.DDoSProtectionPlan.Tags",
	"title":        "Description.DDoSProtectionPlan.name",
}

func ListNetworkDDoSProtectionPlan(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNetworkDDoSProtectionPlan")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkDDoSProtectionPlan NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkDDoSProtectionPlan NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkDDoSProtectionPlan GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkDDoSProtectionPlan GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkDDoSProtectionPlan GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewNetworkDDoSProtectionPlanPaginator(essdk.BuildFilter(ctx, d.QueryContext, listNetworkDDoSProtectionPlanFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkDDoSProtectionPlan NewNetworkDDoSProtectionPlanPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListNetworkDDoSProtectionPlan paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getNetworkDDoSProtectionPlanFilters = map[string]string{
	"id":           "Description.DDoSProtectionPlan.id",
	"name":         "Description.DDoSProtectionPlan.name",
	"subscription": "Description.DDoSProtectionPlan.Properties.Subscription",
	"tags":         "Description.DDoSProtectionPlan.Tags",
	"title":        "Description.DDoSProtectionPlan.name",
}

func GetNetworkDDoSProtectionPlan(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNetworkDDoSProtectionPlan")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewNetworkDDoSProtectionPlanPaginator(essdk.BuildFilter(ctx, d.QueryContext, getNetworkDDoSProtectionPlanFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: NetworkDDoSProtectionPlan =============================

// ==========================  START: PolicyAssignment =============================

type PolicyAssignment struct {
	ResourceID      string                            `json:"resource_id"`
	PlatformID      string                            `json:"platform_id"`
	Description     azure.PolicyAssignmentDescription `json:"Description"`
	Metadata        azure.Metadata                    `json:"metadata"`
	DescribedBy     string                            `json:"described_by"`
	ResourceType    string                            `json:"resource_type"`
	IntegrationType string                            `json:"integration_type"`
	IntegrationID   string                            `json:"integration_id"`
}

type PolicyAssignmentHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  PolicyAssignment `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type PolicyAssignmentHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []PolicyAssignmentHit `json:"hits"`
}

type PolicyAssignmentSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  PolicyAssignmentHits `json:"hits"`
}

type PolicyAssignmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPolicyAssignmentPaginator(filters []essdk.BoolFilter, limit *int64) (PolicyAssignmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_authorization_policyassignments", filters, limit)
	if err != nil {
		return PolicyAssignmentPaginator{}, err
	}

	p := PolicyAssignmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PolicyAssignmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PolicyAssignmentPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p PolicyAssignmentPaginator) NextPage(ctx context.Context) ([]PolicyAssignment, error) {
	var response PolicyAssignmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PolicyAssignment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPolicyAssignmentFilters = map[string]string{
	"description":             "Description.Assignment.properties.description",
	"display_name":            "Description.Assignment.properties.displayName",
	"enforcement_mode":        "Description.Assignment.properties.enforcementMode",
	"id":                      "Description.Assignment.id",
	"identity":                "Description.Assignment.Identity",
	"metadata":                "Description.Assignment.Properties.Metadata",
	"name":                    "Description.Assignment.name",
	"not_scopes":              "Description.Assignment.Properties.NotScopes",
	"parameters":              "Description.Assignment.Properties.Parameters",
	"platform_integration_id": "IntegrationID",
	"policy_definition_id":    "Description.Assignment.properties.policyDefinitionId",
	"scope":                   "Description.Assignment.properties.scope",
	"sku_name":                "Description.Resource.sku.name",
	"sku_tier":                "Description.Resource.sku.tier",
	"subscription":            "Description.Assignment.Properties.Subscription",
	"title":                   "Description.Assignment.name",
	"type":                    "Description.Assignment.type",
}

func ListPolicyAssignment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPolicyAssignment")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListPolicyAssignment NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListPolicyAssignment NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListPolicyAssignment GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListPolicyAssignment GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListPolicyAssignment GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewPolicyAssignmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, listPolicyAssignmentFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListPolicyAssignment NewPolicyAssignmentPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListPolicyAssignment paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getPolicyAssignmentFilters = map[string]string{
	"description":             "Description.Assignment.properties.description",
	"display_name":            "Description.Assignment.properties.displayName",
	"enforcement_mode":        "Description.Assignment.properties.enforcementMode",
	"id":                      "Description.Assignment.id",
	"identity":                "Description.Assignment.Identity",
	"metadata":                "Description.Assignment.Properties.Metadata",
	"name":                    "description.Assignment.name",
	"not_scopes":              "Description.Assignment.Properties.NotScopes",
	"parameters":              "Description.Assignment.Properties.Parameters",
	"platform_integration_id": "IntegrationID",
	"policy_definition_id":    "Description.Assignment.properties.policyDefinitionId",
	"scope":                   "Description.Assignment.properties.scope",
	"sku_name":                "Description.Resource.sku.name",
	"sku_tier":                "Description.Resource.sku.tier",
	"subscription":            "Description.Assignment.Properties.Subscription",
	"title":                   "Description.Assignment.name",
	"type":                    "Description.Assignment.type",
}

func GetPolicyAssignment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPolicyAssignment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewPolicyAssignmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, getPolicyAssignmentFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: PolicyAssignment =============================

// ==========================  START: RedisCache =============================

type RedisCache struct {
	ResourceID      string                      `json:"resource_id"`
	PlatformID      string                      `json:"platform_id"`
	Description     azure.RedisCacheDescription `json:"Description"`
	Metadata        azure.Metadata              `json:"metadata"`
	DescribedBy     string                      `json:"described_by"`
	ResourceType    string                      `json:"resource_type"`
	IntegrationType string                      `json:"integration_type"`
	IntegrationID   string                      `json:"integration_id"`
}

type RedisCacheHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  RedisCache    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RedisCacheHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []RedisCacheHit   `json:"hits"`
}

type RedisCacheSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  RedisCacheHits `json:"hits"`
}

type RedisCachePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRedisCachePaginator(filters []essdk.BoolFilter, limit *int64) (RedisCachePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_cache_redis", filters, limit)
	if err != nil {
		return RedisCachePaginator{}, err
	}

	p := RedisCachePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RedisCachePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RedisCachePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RedisCachePaginator) NextPage(ctx context.Context) ([]RedisCache, error) {
	var response RedisCacheSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RedisCache
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRedisCacheFilters = map[string]string{
	"access_keys":                  "Description.ResourceInfo.Properties.AccessKeys",
	"enable_non_ssl_port":          "Description.ResourceInfo.properties.enableNonSslPort",
	"host_name":                    "Description.ResourceInfo.properties.hostName",
	"id":                           "Description.ResourceInfo.id",
	"instances":                    "Description.ResourceInfo.Properties.Instances",
	"linked_servers":               "Description.ResourceInfo.Properties.LinkedServers",
	"name":                         "Description.ResourceInfo.name",
	"platform_integration_id":      "IntegrationID",
	"port":                         "Description.ResourceInfo.properties.port",
	"private_endpoint_connections": "Description.ResourceInfo.Properties.PrivateEndpointConnections",
	"provisioning_state":           "Description.ResourceInfo.properties.provisioningState",
	"public_network_access":        "Description.ResourceInfo.properties.publicNetworkAccess",
	"redis_configuration":          "Description.ResourceInfo.Properties.RedisConfiguration",
	"redis_version":                "Description.ResourceInfo.properties.redisVersion",
	"replicas_per_master":          "Description.ResourceInfo.properties.replicasPerMaster",
	"resource_group":               "Description.ResourceGroup",
	"shard_count":                  "Description.ResourceInfo.properties.shardCount",
	"sku_capacity":                 "Description.ResourceInfo.properties.sku.capacity",
	"sku_family":                   "Description.ResourceInfo.properties.sku.family",
	"sku_name":                     "Description.ResourceInfo.properties.sku.name",
	"ssl_port":                     "Description.ResourceInfo.properties.sslPort",
	"static_ip":                    "Description.ResourceInfo.properties.staticIP",
	"subnet_id":                    "Description.ResourceInfo.properties.subnetId",
	"subscription":                 "Description.ResourceInfo.Properties.Subscription",
	"tags":                         "Description.ResourceInfo.Tags",
	"tenant_settings":              "Description.ResourceInfo.Properties.TenantSettings",
	"title":                        "Description.ResourceInfo.name",
	"type":                         "Description.ResourceInfo.type",
	"zones":                        "Description.ResourceInfo.Zones",
}

func ListRedisCache(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRedisCache")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedisCache NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedisCache NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedisCache GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedisCache GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedisCache GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRedisCachePaginator(essdk.BuildFilter(ctx, d.QueryContext, listRedisCacheFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedisCache NewRedisCachePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRedisCache paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRedisCacheFilters = map[string]string{
	"access_keys":                  "Description.ResourceInfo.Properties.AccessKeys",
	"enable_non_ssl_port":          "Description.ResourceInfo.properties.enableNonSslPort",
	"host_name":                    "Description.ResourceInfo.properties.hostName",
	"id":                           "Description.ResourceInfo.id",
	"instances":                    "Description.ResourceInfo.Properties.Instances",
	"linked_servers":               "Description.ResourceInfo.Properties.LinkedServers",
	"name":                         "description.ResourceType.name",
	"platform_integration_id":      "IntegrationID",
	"port":                         "Description.ResourceInfo.properties.port",
	"private_endpoint_connections": "Description.ResourceInfo.Properties.PrivateEndpointConnections",
	"provisioning_state":           "Description.ResourceInfo.properties.provisioningState",
	"public_network_access":        "Description.ResourceInfo.properties.publicNetworkAccess",
	"redis_configuration":          "Description.ResourceInfo.Properties.RedisConfiguration",
	"redis_version":                "Description.ResourceInfo.properties.redisVersion",
	"replicas_per_master":          "Description.ResourceInfo.properties.replicasPerMaster",
	"resource_group":               "description.ResourceGroup",
	"shard_count":                  "Description.ResourceInfo.properties.shardCount",
	"sku_capacity":                 "Description.ResourceInfo.properties.sku.capacity",
	"sku_family":                   "Description.ResourceInfo.properties.sku.family",
	"sku_name":                     "Description.ResourceInfo.properties.sku.name",
	"ssl_port":                     "Description.ResourceInfo.properties.sslPort",
	"static_ip":                    "Description.ResourceInfo.properties.staticIP",
	"subnet_id":                    "Description.ResourceInfo.properties.subnetId",
	"subscription":                 "Description.ResourceInfo.Properties.Subscription",
	"tags":                         "Description.ResourceInfo.Tags",
	"tenant_settings":              "Description.ResourceInfo.Properties.TenantSettings",
	"title":                        "Description.ResourceInfo.name",
	"type":                         "Description.ResourceInfo.type",
	"zones":                        "Description.ResourceInfo.Zones",
}

func GetRedisCache(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRedisCache")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRedisCachePaginator(essdk.BuildFilter(ctx, d.QueryContext, getRedisCacheFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RedisCache =============================

// ==========================  START: RedisEnterpriseCache =============================

type RedisEnterpriseCache struct {
	ResourceID      string                                `json:"resource_id"`
	PlatformID      string                                `json:"platform_id"`
	Description     azure.RedisEnterpriseCacheDescription `json:"Description"`
	Metadata        azure.Metadata                        `json:"metadata"`
	DescribedBy     string                                `json:"described_by"`
	ResourceType    string                                `json:"resource_type"`
	IntegrationType string                                `json:"integration_type"`
	IntegrationID   string                                `json:"integration_id"`
}

type RedisEnterpriseCacheHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  RedisEnterpriseCache `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type RedisEnterpriseCacheHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []RedisEnterpriseCacheHit `json:"hits"`
}

type RedisEnterpriseCacheSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  RedisEnterpriseCacheHits `json:"hits"`
}

type RedisEnterpriseCachePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRedisEnterpriseCachePaginator(filters []essdk.BoolFilter, limit *int64) (RedisEnterpriseCachePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_cache_redisenterprise", filters, limit)
	if err != nil {
		return RedisEnterpriseCachePaginator{}, err
	}

	p := RedisEnterpriseCachePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RedisEnterpriseCachePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RedisEnterpriseCachePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RedisEnterpriseCachePaginator) NextPage(ctx context.Context) ([]RedisEnterpriseCache, error) {
	var response RedisEnterpriseCacheSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RedisEnterpriseCache
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRedisEnterpriseCacheFilters = map[string]string{
	"id":                      "Description.RedisEnterprise.id",
	"name":                    "Description.RedisEnterprise.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.RedisEnterprise.Properties.Subscription",
	"tags":                    "Description.RedisEnterprise.Tags",
	"title":                   "Description.RedisEnterprise.name",
}

func ListRedisEnterpriseCache(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRedisEnterpriseCache")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedisEnterpriseCache NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedisEnterpriseCache NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedisEnterpriseCache GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedisEnterpriseCache GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedisEnterpriseCache GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRedisEnterpriseCachePaginator(essdk.BuildFilter(ctx, d.QueryContext, listRedisEnterpriseCacheFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRedisEnterpriseCache NewRedisEnterpriseCachePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRedisEnterpriseCache paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRedisEnterpriseCacheFilters = map[string]string{
	"id":                      "Description.RedisEnterprise.id",
	"name":                    "Description.RedisEnterprise.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.RedisEnterprise.Properties.Subscription",
	"tags":                    "Description.RedisEnterprise.Tags",
	"title":                   "Description.RedisEnterprise.name",
}

func GetRedisEnterpriseCache(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRedisEnterpriseCache")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRedisEnterpriseCachePaginator(essdk.BuildFilter(ctx, d.QueryContext, getRedisEnterpriseCacheFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RedisEnterpriseCache =============================

// ==========================  START: ResourceLink =============================

type ResourceLink struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     azure.ResourceLinkDescription `json:"Description"`
	Metadata        azure.Metadata                `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type ResourceLinkHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ResourceLink  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ResourceLinkHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ResourceLinkHit `json:"hits"`
}

type ResourceLinkSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  ResourceLinkHits `json:"hits"`
}

type ResourceLinkPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewResourceLinkPaginator(filters []essdk.BoolFilter, limit *int64) (ResourceLinkPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_resources_links", filters, limit)
	if err != nil {
		return ResourceLinkPaginator{}, err
	}

	p := ResourceLinkPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ResourceLinkPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ResourceLinkPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ResourceLinkPaginator) NextPage(ctx context.Context) ([]ResourceLink, error) {
	var response ResourceLinkSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ResourceLink
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listResourceLinkFilters = map[string]string{
	"id":                      "Description.ResourceLink.id",
	"name":                    "Description.ResourceLink.name",
	"notes":                   "Description.ResourceLink.properties.notes",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "Description.ResourceLink.properties.sourceId",
	"source_id":               "Description.ResourceLink.properties.sourceId",
	"subscription":            "Description.ResourceLink.Properties.Subscription",
	"target_id":               "Description.ResourceLink.properties.targetId",
	"title":                   "Description.ResourceLink.name",
	"type":                    "Description.ResourceLink.Type",
}

func ListResourceLink(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListResourceLink")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceLink NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceLink NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceLink GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceLink GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceLink GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewResourceLinkPaginator(essdk.BuildFilter(ctx, d.QueryContext, listResourceLinkFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceLink NewResourceLinkPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListResourceLink paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getResourceLinkFilters = map[string]string{
	"id":                      "description.ResourceLink.id",
	"name":                    "Description.ResourceLink.name",
	"notes":                   "Description.ResourceLink.properties.notes",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "Description.ResourceLink.properties.sourceId",
	"source_id":               "Description.ResourceLink.properties.sourceId",
	"subscription":            "Description.ResourceLink.Properties.Subscription",
	"target_id":               "Description.ResourceLink.properties.targetId",
	"title":                   "Description.ResourceLink.name",
	"type":                    "Description.ResourceLink.Type",
}

func GetResourceLink(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetResourceLink")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewResourceLinkPaginator(essdk.BuildFilter(ctx, d.QueryContext, getResourceLinkFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ResourceLink =============================

// ==========================  START: RoleAssignment =============================

type RoleAssignment struct {
	ResourceID      string                          `json:"resource_id"`
	PlatformID      string                          `json:"platform_id"`
	Description     azure.RoleAssignmentDescription `json:"Description"`
	Metadata        azure.Metadata                  `json:"metadata"`
	DescribedBy     string                          `json:"described_by"`
	ResourceType    string                          `json:"resource_type"`
	IntegrationType string                          `json:"integration_type"`
	IntegrationID   string                          `json:"integration_id"`
}

type RoleAssignmentHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  RoleAssignment `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type RoleAssignmentHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []RoleAssignmentHit `json:"hits"`
}

type RoleAssignmentSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  RoleAssignmentHits `json:"hits"`
}

type RoleAssignmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRoleAssignmentPaginator(filters []essdk.BoolFilter, limit *int64) (RoleAssignmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_authorization_roleassignment", filters, limit)
	if err != nil {
		return RoleAssignmentPaginator{}, err
	}

	p := RoleAssignmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RoleAssignmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RoleAssignmentPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RoleAssignmentPaginator) NextPage(ctx context.Context) ([]RoleAssignment, error) {
	var response RoleAssignmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RoleAssignment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRoleAssignmentFilters = map[string]string{
	"created_on":              "Description.RoleAssignment.properties.createdOn",
	"id":                      "Description.RoleAssignment.id",
	"name":                    "Description.RoleAssignment.name",
	"platform_integration_id": "IntegrationID",
	"principal_id":            "Description.RoleAssignment.properties.principalId",
	"principal_type":          "Description.RoleAssignment.properties.principalType",
	"resource_type":           "Description.RoleAssignment.type",
	"role_definition_id":      "Description.RoleAssignment.properties.roleDefinitionId",
	"scope":                   "Description.RoleAssignment.properties.scope",
	"subscription":            "Description.Subscription",
	"title":                   "Description.RoleAssignment.name",
	"type":                    "Description.RoleAssignment.type",
	"updated_on":              "Description.RoleAssignment.properties.updatedOn",
}

func ListRoleAssignment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRoleAssignment")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoleAssignment NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoleAssignment NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoleAssignment GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoleAssignment GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoleAssignment GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRoleAssignmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRoleAssignmentFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoleAssignment NewRoleAssignmentPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRoleAssignment paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRoleAssignmentFilters = map[string]string{
	"created_on":              "Description.RoleAssignment.properties.createdOn",
	"id":                      "Description.RoleAssignment.id",
	"name":                    "Description.RoleAssignment.name",
	"platform_integration_id": "IntegrationID",
	"principal_id":            "Description.RoleAssignment.properties.principalId",
	"principal_type":          "Description.RoleAssignment.properties.principalType",
	"resource_type":           "Description.RoleAssignment.type",
	"role_definition_id":      "Description.RoleAssignment.properties.roleDefinitionId",
	"scope":                   "Description.RoleAssignment.properties.scope",
	"subscription":            "Description.Subscription",
	"title":                   "Description.RoleAssignment.name",
	"type":                    "Description.RoleAssignment.type",
	"updated_on":              "Description.RoleAssignment.properties.updatedOn",
}

func GetRoleAssignment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRoleAssignment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRoleAssignmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRoleAssignmentFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RoleAssignment =============================

// ==========================  START: RoleDefinition =============================

type RoleDefinition struct {
	ResourceID      string                          `json:"resource_id"`
	PlatformID      string                          `json:"platform_id"`
	Description     azure.RoleDefinitionDescription `json:"Description"`
	Metadata        azure.Metadata                  `json:"metadata"`
	DescribedBy     string                          `json:"described_by"`
	ResourceType    string                          `json:"resource_type"`
	IntegrationType string                          `json:"integration_type"`
	IntegrationID   string                          `json:"integration_id"`
}

type RoleDefinitionHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  RoleDefinition `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type RoleDefinitionHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []RoleDefinitionHit `json:"hits"`
}

type RoleDefinitionSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  RoleDefinitionHits `json:"hits"`
}

type RoleDefinitionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRoleDefinitionPaginator(filters []essdk.BoolFilter, limit *int64) (RoleDefinitionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_authorization_roledefinitions", filters, limit)
	if err != nil {
		return RoleDefinitionPaginator{}, err
	}

	p := RoleDefinitionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RoleDefinitionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RoleDefinitionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RoleDefinitionPaginator) NextPage(ctx context.Context) ([]RoleDefinition, error) {
	var response RoleDefinitionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RoleDefinition
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRoleDefinitionFilters = map[string]string{
	"assignable_scopes":       "Description.RoleDefinition.properties.assignableScopes",
	"description":             "Description.RoleDefinition.properties.description",
	"id":                      "Description.RoleDefinition.id",
	"name":                    "Description.RoleDefinition.name",
	"permissions":             "Description.RoleDefinition.properties.permissions",
	"platform_integration_id": "IntegrationID",
	"resource_type":           "Description.RoleDefinition.type",
	"role_name":               "Description.RoleDefinition.properties.roleName",
	"role_type":               "Description.RoleDefinition.properties.type",
	"short_id":                "Description.RoleDefinition.name",
	"title":                   "Description.RoleDefinition.name",
	"type":                    "Description.RoleDefinition.type",
}

func ListRoleDefinition(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRoleDefinition")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoleDefinition NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoleDefinition NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoleDefinition GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoleDefinition GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoleDefinition GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRoleDefinitionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRoleDefinitionFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoleDefinition NewRoleDefinitionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRoleDefinition paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRoleDefinitionFilters = map[string]string{
	"assignable_scopes":       "Description.RoleDefinition.properties.assignableScopes",
	"description":             "Description.RoleDefinition.properties.description",
	"id":                      "Description.RoleDefinition.id",
	"name":                    "Description.RoleDefinition.name",
	"permissions":             "Description.RoleDefinition.properties.permissions",
	"platform_integration_id": "IntegrationID",
	"resource_type":           "Description.RoleDefinition.type",
	"role_name":               "Description.RoleDefinition.properties.roleName",
	"role_type":               "Description.RoleDefinition.properties.type",
	"short_id":                "Description.RoleDefinition.name",
	"title":                   "Description.RoleDefinition.name",
	"type":                    "Description.RoleDefinition.type",
}

func GetRoleDefinition(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRoleDefinition")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRoleDefinitionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRoleDefinitionFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RoleDefinition =============================

// ==========================  START: PolicyDefinition =============================

type PolicyDefinition struct {
	ResourceID      string                            `json:"resource_id"`
	PlatformID      string                            `json:"platform_id"`
	Description     azure.PolicyDefinitionDescription `json:"Description"`
	Metadata        azure.Metadata                    `json:"metadata"`
	DescribedBy     string                            `json:"described_by"`
	ResourceType    string                            `json:"resource_type"`
	IntegrationType string                            `json:"integration_type"`
	IntegrationID   string                            `json:"integration_id"`
}

type PolicyDefinitionHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  PolicyDefinition `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type PolicyDefinitionHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []PolicyDefinitionHit `json:"hits"`
}

type PolicyDefinitionSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  PolicyDefinitionHits `json:"hits"`
}

type PolicyDefinitionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPolicyDefinitionPaginator(filters []essdk.BoolFilter, limit *int64) (PolicyDefinitionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_authorization_policydefinitions", filters, limit)
	if err != nil {
		return PolicyDefinitionPaginator{}, err
	}

	p := PolicyDefinitionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PolicyDefinitionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PolicyDefinitionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p PolicyDefinitionPaginator) NextPage(ctx context.Context) ([]PolicyDefinition, error) {
	var response PolicyDefinitionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PolicyDefinition
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPolicyDefinitionFilters = map[string]string{
	"akas":                    "Description.TurboData.Akas",
	"description":             "Description.Definition.properties.description",
	"display_name":            "Description.Definition.properties.displayName",
	"id":                      "ResourceID",
	"metadata":                "Description.Definition.Properties.Metadata",
	"mode":                    "Description.Definition.properties.mode",
	"name":                    "Description.Definition.name",
	"parameters":              "Description.Definition.Properties.Parameters",
	"platform_integration_id": "IntegrationID",
	"policy_rule":             "Description.Definition.Properties.PolicyRule",
	"policy_type":             "Description.Definition.properties.policyType",
	"subscription":            "Description.Definition.Properties.Subscription",
	"title":                   "Description.Definition.properties.displayName",
	"type":                    "Description.Definition.type",
}

func ListPolicyDefinition(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPolicyDefinition")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListPolicyDefinition NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListPolicyDefinition NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListPolicyDefinition GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListPolicyDefinition GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListPolicyDefinition GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewPolicyDefinitionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listPolicyDefinitionFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListPolicyDefinition NewPolicyDefinitionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListPolicyDefinition paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getPolicyDefinitionFilters = map[string]string{
	"akas":                    "Description.TurboData.Akas",
	"description":             "Description.Definition.properties.description",
	"display_name":            "Description.Definition.properties.displayName",
	"id":                      "ResourceID",
	"metadata":                "Description.Definition.Properties.Metadata",
	"mode":                    "Description.Definition.properties.mode",
	"name":                    "description.Definition.Name",
	"parameters":              "Description.Definition.Properties.Parameters",
	"platform_integration_id": "IntegrationID",
	"policy_rule":             "Description.Definition.Properties.PolicyRule",
	"policy_type":             "Description.Definition.properties.policyType",
	"subscription":            "Description.Definition.Properties.Subscription",
	"title":                   "Description.Definition.properties.displayName",
	"type":                    "Description.Definition.type",
}

func GetPolicyDefinition(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPolicyDefinition")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewPolicyDefinitionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getPolicyDefinitionFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: PolicyDefinition =============================

// ==========================  START: UserEffectiveAccess =============================

type UserEffectiveAccess struct {
	ResourceID      string                               `json:"resource_id"`
	PlatformID      string                               `json:"platform_id"`
	Description     azure.UserEffectiveAccessDescription `json:"Description"`
	Metadata        azure.Metadata                       `json:"metadata"`
	DescribedBy     string                               `json:"described_by"`
	ResourceType    string                               `json:"resource_type"`
	IntegrationType string                               `json:"integration_type"`
	IntegrationID   string                               `json:"integration_id"`
}

type UserEffectiveAccessHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  UserEffectiveAccess `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type UserEffectiveAccessHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []UserEffectiveAccessHit `json:"hits"`
}

type UserEffectiveAccessSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  UserEffectiveAccessHits `json:"hits"`
}

type UserEffectiveAccessPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewUserEffectiveAccessPaginator(filters []essdk.BoolFilter, limit *int64) (UserEffectiveAccessPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_authorization_usereffectiveaccess", filters, limit)
	if err != nil {
		return UserEffectiveAccessPaginator{}, err
	}

	p := UserEffectiveAccessPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p UserEffectiveAccessPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p UserEffectiveAccessPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p UserEffectiveAccessPaginator) NextPage(ctx context.Context) ([]UserEffectiveAccess, error) {
	var response UserEffectiveAccessSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []UserEffectiveAccess
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listUserEffectiveAccessFilters = map[string]string{
	"assignment_type":         "Description.AssignmentType",
	"id":                      "ResourceID",
	"parent_principal_id":     "Description.ParentPrincipalId",
	"platform_integration_id": "IntegrationID",
	"principal_id":            "Description.PrincipalId",
	"principal_name":          "Description.PrincipalName",
	"principal_type":          "Description.PrincipalType",
	"role_definition_id":      "Description.RoleAssignment.properties.roleDefinitionId",
	"scope":                   "Description.Scope",
	"scope_type":              "Description.ScopeType",
	"subscription":            "Description.Subscription",
}

func ListUserEffectiveAccess(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListUserEffectiveAccess")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListUserEffectiveAccess NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListUserEffectiveAccess NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListUserEffectiveAccess GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListUserEffectiveAccess GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListUserEffectiveAccess GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewUserEffectiveAccessPaginator(essdk.BuildFilter(ctx, d.QueryContext, listUserEffectiveAccessFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListUserEffectiveAccess NewUserEffectiveAccessPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListUserEffectiveAccess paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getUserEffectiveAccessFilters = map[string]string{
	"assignment_type":         "Description.AssignmentType",
	"id":                      "ResourceID",
	"parent_principal_id":     "Description.ParentPrincipalId",
	"platform_integration_id": "IntegrationID",
	"principal_id":            "Description.PrincipalId",
	"principal_name":          "Description.PrincipalName",
	"principal_type":          "Description.PrincipalType",
	"role_definition_id":      "Description.RoleAssignment.properties.roleDefinitionId",
	"scope":                   "Description.Scope",
	"scope_type":              "Description.ScopeType",
	"subscription":            "Description.Subscription",
}

func GetUserEffectiveAccess(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetUserEffectiveAccess")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewUserEffectiveAccessPaginator(essdk.BuildFilter(ctx, d.QueryContext, getUserEffectiveAccessFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: UserEffectiveAccess =============================

// ==========================  START: SecurityCenterAutoProvisioning =============================

type SecurityCenterAutoProvisioning struct {
	ResourceID      string                                          `json:"resource_id"`
	PlatformID      string                                          `json:"platform_id"`
	Description     azure.SecurityCenterAutoProvisioningDescription `json:"Description"`
	Metadata        azure.Metadata                                  `json:"metadata"`
	DescribedBy     string                                          `json:"described_by"`
	ResourceType    string                                          `json:"resource_type"`
	IntegrationType string                                          `json:"integration_type"`
	IntegrationID   string                                          `json:"integration_id"`
}

type SecurityCenterAutoProvisioningHit struct {
	ID      string                         `json:"_id"`
	Score   float64                        `json:"_score"`
	Index   string                         `json:"_index"`
	Type    string                         `json:"_type"`
	Version int64                          `json:"_version,omitempty"`
	Source  SecurityCenterAutoProvisioning `json:"_source"`
	Sort    []interface{}                  `json:"sort"`
}

type SecurityCenterAutoProvisioningHits struct {
	Total essdk.SearchTotal                   `json:"total"`
	Hits  []SecurityCenterAutoProvisioningHit `json:"hits"`
}

type SecurityCenterAutoProvisioningSearchResponse struct {
	PitID string                             `json:"pit_id"`
	Hits  SecurityCenterAutoProvisioningHits `json:"hits"`
}

type SecurityCenterAutoProvisioningPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityCenterAutoProvisioningPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityCenterAutoProvisioningPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_security_autoprovisioningsettings", filters, limit)
	if err != nil {
		return SecurityCenterAutoProvisioningPaginator{}, err
	}

	p := SecurityCenterAutoProvisioningPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityCenterAutoProvisioningPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityCenterAutoProvisioningPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SecurityCenterAutoProvisioningPaginator) NextPage(ctx context.Context) ([]SecurityCenterAutoProvisioning, error) {
	var response SecurityCenterAutoProvisioningSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityCenterAutoProvisioning
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityCenterAutoProvisioningFilters = map[string]string{
	"auto_provision":          "Description.AutoProvisioningSetting.properties.autoProvision",
	"id":                      "Description.AutoProvisioningSetting.id",
	"name":                    "Description.AutoProvisioningSetting.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.AutoProvisioningSetting.Properties.Subscription",
	"title":                   "Description.AutoProvisioningSetting.name",
	"type":                    "Description.AutoProvisioningSetting.type",
}

func ListSecurityCenterAutoProvisioning(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityCenterAutoProvisioning")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterAutoProvisioning NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterAutoProvisioning NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterAutoProvisioning GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterAutoProvisioning GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterAutoProvisioning GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSecurityCenterAutoProvisioningPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSecurityCenterAutoProvisioningFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterAutoProvisioning NewSecurityCenterAutoProvisioningPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSecurityCenterAutoProvisioning paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSecurityCenterAutoProvisioningFilters = map[string]string{
	"auto_provision":          "Description.AutoProvisioningSetting.properties.autoProvision",
	"id":                      "Description.AutoProvisioningSetting.id",
	"name":                    "description.AutoProvisioningSetting.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.AutoProvisioningSetting.Properties.Subscription",
	"title":                   "Description.AutoProvisioningSetting.name",
	"type":                    "Description.AutoProvisioningSetting.type",
}

func GetSecurityCenterAutoProvisioning(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityCenterAutoProvisioning")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSecurityCenterAutoProvisioningPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSecurityCenterAutoProvisioningFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SecurityCenterAutoProvisioning =============================

// ==========================  START: SecurityCenterContact =============================

type SecurityCenterContact struct {
	ResourceID      string                                 `json:"resource_id"`
	PlatformID      string                                 `json:"platform_id"`
	Description     azure.SecurityCenterContactDescription `json:"Description"`
	Metadata        azure.Metadata                         `json:"metadata"`
	DescribedBy     string                                 `json:"described_by"`
	ResourceType    string                                 `json:"resource_type"`
	IntegrationType string                                 `json:"integration_type"`
	IntegrationID   string                                 `json:"integration_id"`
}

type SecurityCenterContactHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  SecurityCenterContact `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type SecurityCenterContactHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []SecurityCenterContactHit `json:"hits"`
}

type SecurityCenterContactSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  SecurityCenterContactHits `json:"hits"`
}

type SecurityCenterContactPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityCenterContactPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityCenterContactPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_security_securitycontacts", filters, limit)
	if err != nil {
		return SecurityCenterContactPaginator{}, err
	}

	p := SecurityCenterContactPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityCenterContactPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityCenterContactPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SecurityCenterContactPaginator) NextPage(ctx context.Context) ([]SecurityCenterContact, error) {
	var response SecurityCenterContactSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityCenterContact
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityCenterContactFilters = map[string]string{
	"alert_notifications":     "Description.Contact.Properties.AlertNotifications",
	"alerts_to_admins":        "Description.Contact.Properties.AlertNotifications",
	"email":                   "Description.Contact.properties.emails",
	"id":                      "Description.Contact.id",
	"name":                    "Description.Contact.name",
	"phone":                   "Description.Contact.properties.phone",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Contact.Properties.Subscription",
	"title":                   "Description.Contact.name",
	"type":                    "Description.Contact.type",
}

func ListSecurityCenterContact(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityCenterContact")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterContact NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterContact NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterContact GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterContact GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterContact GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSecurityCenterContactPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSecurityCenterContactFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterContact NewSecurityCenterContactPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSecurityCenterContact paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSecurityCenterContactFilters = map[string]string{
	"alert_notifications":     "Description.Contact.Properties.AlertNotifications",
	"alerts_to_admins":        "Description.Contact.Properties.AlertNotifications",
	"email":                   "Description.Contact.properties.emails",
	"id":                      "Description.Contact.id",
	"name":                    "description.Contact.name",
	"phone":                   "Description.Contact.properties.phone",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Contact.Properties.Subscription",
	"title":                   "Description.Contact.name",
	"type":                    "Description.Contact.type",
}

func GetSecurityCenterContact(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityCenterContact")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSecurityCenterContactPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSecurityCenterContactFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SecurityCenterContact =============================

// ==========================  START: SecurityCenterJitNetworkAccessPolicy =============================

type SecurityCenterJitNetworkAccessPolicy struct {
	ResourceID      string                                                `json:"resource_id"`
	PlatformID      string                                                `json:"platform_id"`
	Description     azure.SecurityCenterJitNetworkAccessPolicyDescription `json:"Description"`
	Metadata        azure.Metadata                                        `json:"metadata"`
	DescribedBy     string                                                `json:"described_by"`
	ResourceType    string                                                `json:"resource_type"`
	IntegrationType string                                                `json:"integration_type"`
	IntegrationID   string                                                `json:"integration_id"`
}

type SecurityCenterJitNetworkAccessPolicyHit struct {
	ID      string                               `json:"_id"`
	Score   float64                              `json:"_score"`
	Index   string                               `json:"_index"`
	Type    string                               `json:"_type"`
	Version int64                                `json:"_version,omitempty"`
	Source  SecurityCenterJitNetworkAccessPolicy `json:"_source"`
	Sort    []interface{}                        `json:"sort"`
}

type SecurityCenterJitNetworkAccessPolicyHits struct {
	Total essdk.SearchTotal                         `json:"total"`
	Hits  []SecurityCenterJitNetworkAccessPolicyHit `json:"hits"`
}

type SecurityCenterJitNetworkAccessPolicySearchResponse struct {
	PitID string                                   `json:"pit_id"`
	Hits  SecurityCenterJitNetworkAccessPolicyHits `json:"hits"`
}

type SecurityCenterJitNetworkAccessPolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityCenterJitNetworkAccessPolicyPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityCenterJitNetworkAccessPolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_security_locations_jitnetworkaccesspolicies", filters, limit)
	if err != nil {
		return SecurityCenterJitNetworkAccessPolicyPaginator{}, err
	}

	p := SecurityCenterJitNetworkAccessPolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityCenterJitNetworkAccessPolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityCenterJitNetworkAccessPolicyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SecurityCenterJitNetworkAccessPolicyPaginator) NextPage(ctx context.Context) ([]SecurityCenterJitNetworkAccessPolicy, error) {
	var response SecurityCenterJitNetworkAccessPolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityCenterJitNetworkAccessPolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityCenterJitNetworkAccessPolicyFilters = map[string]string{
	"id":                      "Description.JitNetworkAccessPolicy.id",
	"kind":                    "Description.JitNetworkAccessPolicy.kind",
	"name":                    "Description.JitNetworkAccessPolicy.name",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.JitNetworkAccessPolicy.properties.provisioningState",
	"subscription":            "Description.JitNetworkAccessPolicy.Properties.Subscription",
	"title":                   "Description.JitNetworkAccessPolicy.name",
	"type":                    "Description.JitNetworkAccessPolicy.type",
	"virtual_machines":        "Description.JitNetworkAccessPolicy.Properties.VirtualMachines",
}

func ListSecurityCenterJitNetworkAccessPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityCenterJitNetworkAccessPolicy")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterJitNetworkAccessPolicy NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterJitNetworkAccessPolicy NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterJitNetworkAccessPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterJitNetworkAccessPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterJitNetworkAccessPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSecurityCenterJitNetworkAccessPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSecurityCenterJitNetworkAccessPolicyFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterJitNetworkAccessPolicy NewSecurityCenterJitNetworkAccessPolicyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSecurityCenterJitNetworkAccessPolicy paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSecurityCenterJitNetworkAccessPolicyFilters = map[string]string{
	"id":                      "Description.JitNetworkAccessPolicy.id",
	"kind":                    "Description.JitNetworkAccessPolicy.kind",
	"name":                    "Description.JitNetworkAccessPolicy.name",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.JitNetworkAccessPolicy.properties.provisioningState",
	"subscription":            "Description.JitNetworkAccessPolicy.Properties.Subscription",
	"title":                   "Description.JitNetworkAccessPolicy.name",
	"type":                    "Description.JitNetworkAccessPolicy.type",
	"virtual_machines":        "Description.JitNetworkAccessPolicy.Properties.VirtualMachines",
}

func GetSecurityCenterJitNetworkAccessPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityCenterJitNetworkAccessPolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSecurityCenterJitNetworkAccessPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSecurityCenterJitNetworkAccessPolicyFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SecurityCenterJitNetworkAccessPolicy =============================

// ==========================  START: SecurityCenterSetting =============================

type SecurityCenterSetting struct {
	ResourceID      string                                 `json:"resource_id"`
	PlatformID      string                                 `json:"platform_id"`
	Description     azure.SecurityCenterSettingDescription `json:"Description"`
	Metadata        azure.Metadata                         `json:"metadata"`
	DescribedBy     string                                 `json:"described_by"`
	ResourceType    string                                 `json:"resource_type"`
	IntegrationType string                                 `json:"integration_type"`
	IntegrationID   string                                 `json:"integration_id"`
}

type SecurityCenterSettingHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  SecurityCenterSetting `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type SecurityCenterSettingHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []SecurityCenterSettingHit `json:"hits"`
}

type SecurityCenterSettingSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  SecurityCenterSettingHits `json:"hits"`
}

type SecurityCenterSettingPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityCenterSettingPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityCenterSettingPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_security_settings", filters, limit)
	if err != nil {
		return SecurityCenterSettingPaginator{}, err
	}

	p := SecurityCenterSettingPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityCenterSettingPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityCenterSettingPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SecurityCenterSettingPaginator) NextPage(ctx context.Context) ([]SecurityCenterSetting, error) {
	var response SecurityCenterSettingSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityCenterSetting
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityCenterSettingFilters = map[string]string{
	"enabled":                 "Description.ExportSettingStatus",
	"id":                      "Description.Setting.id",
	"kind":                    "Description.Setting.kind",
	"name":                    "Description.Setting.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Setting.Properties.Subscription",
	"title":                   "Description.Setting.name",
	"type":                    "Description.Setting.type",
}

func ListSecurityCenterSetting(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityCenterSetting")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterSetting NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterSetting NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterSetting GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterSetting GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterSetting GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSecurityCenterSettingPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSecurityCenterSettingFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterSetting NewSecurityCenterSettingPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSecurityCenterSetting paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSecurityCenterSettingFilters = map[string]string{
	"enabled":                 "Description.ExportSettingStatus",
	"id":                      "Description.Setting.id",
	"kind":                    "Description.Setting.kind",
	"name":                    "description.Setting.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Setting.Properties.Subscription",
	"title":                   "Description.Setting.name",
	"type":                    "Description.Setting.type",
}

func GetSecurityCenterSetting(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityCenterSetting")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSecurityCenterSettingPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSecurityCenterSettingFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SecurityCenterSetting =============================

// ==========================  START: SecurityCenterAutomation =============================

type SecurityCenterAutomation struct {
	ResourceID      string                                    `json:"resource_id"`
	PlatformID      string                                    `json:"platform_id"`
	Description     azure.SecurityCenterAutomationDescription `json:"Description"`
	Metadata        azure.Metadata                            `json:"metadata"`
	DescribedBy     string                                    `json:"described_by"`
	ResourceType    string                                    `json:"resource_type"`
	IntegrationType string                                    `json:"integration_type"`
	IntegrationID   string                                    `json:"integration_id"`
}

type SecurityCenterAutomationHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  SecurityCenterAutomation `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type SecurityCenterAutomationHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []SecurityCenterAutomationHit `json:"hits"`
}

type SecurityCenterAutomationSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  SecurityCenterAutomationHits `json:"hits"`
}

type SecurityCenterAutomationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityCenterAutomationPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityCenterAutomationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_security_automations", filters, limit)
	if err != nil {
		return SecurityCenterAutomationPaginator{}, err
	}

	p := SecurityCenterAutomationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityCenterAutomationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityCenterAutomationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SecurityCenterAutomationPaginator) NextPage(ctx context.Context) ([]SecurityCenterAutomation, error) {
	var response SecurityCenterAutomationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityCenterAutomation
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityCenterAutomationFilters = map[string]string{
	"actions":                 "Description.Automation.Properties.Actions",
	"description":             "Description.Automation.properties.description",
	"etag":                    "Description.Automation.etag",
	"id":                      "Description.Automation.id",
	"is_enabled":              "Description.Automation.properties.isEnabled",
	"kind":                    "Description.Automation.kind",
	"name":                    "Description.Automation.name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "Description.ResourceGroup",
	"scopes":                  "Description.Automation.Properties.Scopes",
	"sources":                 "Description.Automation.Properties.Sources",
	"subscription":            "Description.Automation.Properties.Subscription",
	"tags":                    "Description.Automation.Tags",
	"title":                   "Description.Automation.name",
	"type":                    "Description.Automation.type",
}

func ListSecurityCenterAutomation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityCenterAutomation")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterAutomation NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterAutomation NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterAutomation GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterAutomation GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterAutomation GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSecurityCenterAutomationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSecurityCenterAutomationFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterAutomation NewSecurityCenterAutomationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSecurityCenterAutomation paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSecurityCenterAutomationFilters = map[string]string{
	"actions":                 "Description.Automation.Properties.Actions",
	"description":             "Description.Automation.properties.description",
	"etag":                    "Description.Automation.etag",
	"id":                      "Description.Automation.id",
	"is_enabled":              "Description.Automation.properties.isEnabled",
	"kind":                    "Description.Automation.kind",
	"name":                    "description.Automation.name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "description.ResourceGroup",
	"scopes":                  "Description.Automation.Properties.Scopes",
	"sources":                 "Description.Automation.Properties.Sources",
	"subscription":            "Description.Automation.Properties.Subscription",
	"tags":                    "Description.Automation.Tags",
	"title":                   "Description.Automation.name",
	"type":                    "Description.Automation.type",
}

func GetSecurityCenterAutomation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityCenterAutomation")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSecurityCenterAutomationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSecurityCenterAutomationFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SecurityCenterAutomation =============================

// ==========================  START: SecurityCenterSubAssessment =============================

type SecurityCenterSubAssessment struct {
	ResourceID      string                                       `json:"resource_id"`
	PlatformID      string                                       `json:"platform_id"`
	Description     azure.SecurityCenterSubAssessmentDescription `json:"Description"`
	Metadata        azure.Metadata                               `json:"metadata"`
	DescribedBy     string                                       `json:"described_by"`
	ResourceType    string                                       `json:"resource_type"`
	IntegrationType string                                       `json:"integration_type"`
	IntegrationID   string                                       `json:"integration_id"`
}

type SecurityCenterSubAssessmentHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  SecurityCenterSubAssessment `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type SecurityCenterSubAssessmentHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []SecurityCenterSubAssessmentHit `json:"hits"`
}

type SecurityCenterSubAssessmentSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  SecurityCenterSubAssessmentHits `json:"hits"`
}

type SecurityCenterSubAssessmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityCenterSubAssessmentPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityCenterSubAssessmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_security_subassessments", filters, limit)
	if err != nil {
		return SecurityCenterSubAssessmentPaginator{}, err
	}

	p := SecurityCenterSubAssessmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityCenterSubAssessmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityCenterSubAssessmentPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SecurityCenterSubAssessmentPaginator) NextPage(ctx context.Context) ([]SecurityCenterSubAssessment, error) {
	var response SecurityCenterSubAssessmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityCenterSubAssessment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityCenterSubAssessmentFilters = map[string]string{
	"category":                "Description.SubAssessment.properties.category",
	"description":             "Description.SubAssessment.properties.description",
	"display_name":            "Description.SubAssessment.properties.displayName",
	"id":                      "Description.SubAssessment.id",
	"impact":                  "Description.SubAssessment.properties.impact",
	"name":                    "Description.SubAssessment.name",
	"platform_integration_id": "IntegrationID",
	"remediation":             "Description.SubAssessment.properties.remediation",
	"resource_group":          "Description.ResourceGroup",
	"subscription":            "Description.SubAssessment.Properties.Subscription",
	"time_generated":          "Description.SubAssessment.Properties.TimeGenerated",
	"title":                   "Description.SubAssessment.name",
	"type":                    "Description.SubAssessment.type",
}

func ListSecurityCenterSubAssessment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityCenterSubAssessment")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterSubAssessment NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterSubAssessment NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterSubAssessment GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterSubAssessment GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterSubAssessment GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSecurityCenterSubAssessmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSecurityCenterSubAssessmentFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecurityCenterSubAssessment NewSecurityCenterSubAssessmentPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSecurityCenterSubAssessment paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSecurityCenterSubAssessmentFilters = map[string]string{
	"category":                "Description.SubAssessment.properties.category",
	"description":             "Description.SubAssessment.properties.description",
	"display_name":            "Description.SubAssessment.properties.displayName",
	"id":                      "Description.SubAssessment.id",
	"impact":                  "Description.SubAssessment.properties.impact",
	"name":                    "Description.SubAssessment.name",
	"platform_integration_id": "IntegrationID",
	"remediation":             "Description.SubAssessment.properties.remediation",
	"resource_group":          "Description.ResourceGroup",
	"subscription":            "Description.SubAssessment.Properties.Subscription",
	"time_generated":          "Description.SubAssessment.Properties.TimeGenerated",
	"title":                   "Description.SubAssessment.name",
	"type":                    "Description.SubAssessment.type",
}

func GetSecurityCenterSubAssessment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityCenterSubAssessment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSecurityCenterSubAssessmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSecurityCenterSubAssessmentFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SecurityCenterSubAssessment =============================

// ==========================  START: StorageContainer =============================

type StorageContainer struct {
	ResourceID      string                            `json:"resource_id"`
	PlatformID      string                            `json:"platform_id"`
	Description     azure.StorageContainerDescription `json:"Description"`
	Metadata        azure.Metadata                    `json:"metadata"`
	DescribedBy     string                            `json:"described_by"`
	ResourceType    string                            `json:"resource_type"`
	IntegrationType string                            `json:"integration_type"`
	IntegrationID   string                            `json:"integration_id"`
}

type StorageContainerHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  StorageContainer `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type StorageContainerHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []StorageContainerHit `json:"hits"`
}

type StorageContainerSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  StorageContainerHits `json:"hits"`
}

type StorageContainerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStorageContainerPaginator(filters []essdk.BoolFilter, limit *int64) (StorageContainerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_storage_storageaccounts_blobservices_containers", filters, limit)
	if err != nil {
		return StorageContainerPaginator{}, err
	}

	p := StorageContainerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StorageContainerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StorageContainerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p StorageContainerPaginator) NextPage(ctx context.Context) ([]StorageContainer, error) {
	var response StorageContainerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StorageContainer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStorageContainerFilters = map[string]string{
	"account_name":                   "Description.AccountName",
	"default_encryption_scope":       "Description.ListContainerItem.properties.defaultEncryptionScope",
	"deleted":                        "Description.ListContainerItem.properties.deleted",
	"deny_encryption_scope_override": "Description.ListContainerItem.properties.denyEncryptionScopeOverride",
	"has_immutability_policy":        "Description.ListContainerItem.properties.hasImmutabilityPolicy",
	"has_legal_hold":                 "Description.ListContainerItem.properties.hasLegalHold",
	"id":                             "Description.ListContainerItem.id",
	"immutability_policy":            "Description.ImmutabilityPolicy",
	"lease_duration":                 "Description.ListContainerItem.properties.leaseDuration",
	"lease_state":                    "Description.ListContainerItem.properties.leaseState",
	"lease_status":                   "Description.ListContainerItem.properties.leaseStatus",
	"legal_hold":                     "Description.ListContainerItem.Properties.LegalHold",
	"metadata":                       "Description.ListContainerItem.Properties.Metadata",
	"name":                           "Description.ListContainerItem.name",
	"platform_integration_id":        "IntegrationID",
	"public_access":                  "Description.ListContainerItem.properties.publicAccess",
	"remaining_retention_days":       "Description.ListContainerItem.properties.remainingRetentionDays",
	"resource_group":                 "Description.ResourceGroup",
	"subscription":                   "Description.ListContainerItem.Properties.Subscription",
	"title":                          "Description.ListContainerItem.name",
	"type":                           "Description.ListContainerItem.type",
	"version":                        "Description.ListContainerItem.properties.version",
}

func ListStorageContainer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStorageContainer")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageContainer NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageContainer NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageContainer GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageContainer GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageContainer GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewStorageContainerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listStorageContainerFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageContainer NewStorageContainerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListStorageContainer paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getStorageContainerFilters = map[string]string{
	"account_name":                   "description.AccountName",
	"default_encryption_scope":       "Description.ListContainerItem.properties.defaultEncryptionScope",
	"deleted":                        "Description.ListContainerItem.properties.deleted",
	"deny_encryption_scope_override": "Description.ListContainerItem.properties.denyEncryptionScopeOverride",
	"has_immutability_policy":        "Description.ListContainerItem.properties.hasImmutabilityPolicy",
	"has_legal_hold":                 "Description.ListContainerItem.properties.hasLegalHold",
	"id":                             "Description.ListContainerItem.id",
	"immutability_policy":            "Description.ImmutabilityPolicy",
	"lease_duration":                 "Description.ListContainerItem.properties.leaseDuration",
	"lease_state":                    "Description.ListContainerItem.properties.leaseState",
	"lease_status":                   "Description.ListContainerItem.properties.leaseStatus",
	"legal_hold":                     "Description.ListContainerItem.Properties.LegalHold",
	"metadata":                       "Description.ListContainerItem.Properties.Metadata",
	"name":                           "description.ListContainerItem.name",
	"platform_integration_id":        "IntegrationID",
	"public_access":                  "Description.ListContainerItem.properties.publicAccess",
	"remaining_retention_days":       "Description.ListContainerItem.properties.remainingRetentionDays",
	"resource_group":                 "description.ResourceGroup",
	"subscription":                   "Description.ListContainerItem.Properties.Subscription",
	"title":                          "Description.ListContainerItem.name",
	"type":                           "Description.ListContainerItem.type",
	"version":                        "Description.ListContainerItem.properties.version",
}

func GetStorageContainer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStorageContainer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewStorageContainerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getStorageContainerFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: StorageContainer =============================

// ==========================  START: StorageBlob =============================

type StorageBlob struct {
	ResourceID      string                       `json:"resource_id"`
	PlatformID      string                       `json:"platform_id"`
	Description     azure.StorageBlobDescription `json:"Description"`
	Metadata        azure.Metadata               `json:"metadata"`
	DescribedBy     string                       `json:"described_by"`
	ResourceType    string                       `json:"resource_type"`
	IntegrationType string                       `json:"integration_type"`
	IntegrationID   string                       `json:"integration_id"`
}

type StorageBlobHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  StorageBlob   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type StorageBlobHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []StorageBlobHit  `json:"hits"`
}

type StorageBlobSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  StorageBlobHits `json:"hits"`
}

type StorageBlobPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStorageBlobPaginator(filters []essdk.BoolFilter, limit *int64) (StorageBlobPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_storage_storageaccounts_blob", filters, limit)
	if err != nil {
		return StorageBlobPaginator{}, err
	}

	p := StorageBlobPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StorageBlobPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StorageBlobPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p StorageBlobPaginator) NextPage(ctx context.Context) ([]StorageBlob, error) {
	var response StorageBlobSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StorageBlob
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStorageBlobFilters = map[string]string{
	"access_tier":              "Description.Blob.Properties.AccessTier",
	"access_tier_change_time":  "Description.Blob.Properties.AccessTierChangeTime",
	"access_tier_inferred":     "Description.Blob.Properties.AccessTierInferred",
	"archive_status":           "Description.Blob.Properties.ArchiveStatus",
	"blob_sequence_number":     "Description.Blob.Properties.BlobSequenceNumber",
	"blob_tag_set":             "Description.Blob.BlobTags.BlobTagSet",
	"cache_control":            "Description.Blob.Properties.CacheControl",
	"container_name":           "Description.ContainerName",
	"content_disposition":      "Description.Blob.Properties.ContentDisposition",
	"content_encoding":         "Description.Blob.Properties.ContentEncoding",
	"content_language":         "Description.Blob.Properties.ContentLanguage",
	"content_length":           "Description.Blob.Properties.ContentLength",
	"content_md5":              "Description.Blob.Properties.ContentMD5",
	"content_type":             "Description.Blob.Properties.ContentType",
	"copy_completion_time":     "Description.Blob.Properties.CopyCompletionTime",
	"copy_id":                  "Description.Blob.Properties.CopyID",
	"copy_progress":            "Description.Blob.Properties.CopyProgress",
	"copy_source":              "Description.Blob.Properties.CopySource",
	"copy_status":              "Description.Blob.Properties.CopyStatus",
	"copy_status_description":  "Description.Blob.Properties.CopyStatusDescription",
	"creation_time":            "Description.Blob.Properties.CreationTime",
	"deleted":                  "Description.Blob.Deleted",
	"deleted_time":             "Description.Blob.Properties.DeletedTime",
	"destination_snapshot":     "Description.Blob.Properties.DestinationSnapshot",
	"encryption_key_sha256":    "Description.Blob.Properties.CustomerProvidedKeySha256",
	"encryption_scope":         "Description.Blob.Properties.EncryptionScope",
	"etag":                     "Description.Blob.Properties.Etag",
	"incremental_copy":         "Description.Blob.Properties.IncrementalCopy",
	"is_current_version":       "Description.Blob.IsCurrentVersion",
	"is_sealed":                "Description.Blob.Properties.IsSealed",
	"is_snapshot":              "Description.IsSnapshot",
	"last_modified":            "Description.Blob.Properties.LastModified",
	"lease_duration":           "Description.Blob.Properties.LeaseDuration",
	"lease_state":              "Description.Blob.Properties.LeaseState",
	"lease_status":             "Description.Blob.Properties.LeaseStatus",
	"metadata":                 "Description.Blob.Metadata",
	"name":                     "Description.Blob.Name",
	"platform_integration_id":  "IntegrationID",
	"remaining_retention_days": "Description.Blob.Properties.RemainingRetentionDays",
	"resource_group":           "description.ResourceGroup",
	"server_encrypted":         "Description.Blob.Properties.ServerEncrypted",
	"snapshot":                 "Description.Blob.Snapshot",
	"storage_account_name":     "description.AccountName",
	"subscription":             "Description.Blob.Properties.Subscription",
	"title":                    "Description.Blob.Name",
	"type":                     "Description.Blob.Properties.BlobType",
	"version_id":               "Description.Blob.VersionID",
}

func ListStorageBlob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStorageBlob")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageBlob NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageBlob NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageBlob GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageBlob GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageBlob GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewStorageBlobPaginator(essdk.BuildFilter(ctx, d.QueryContext, listStorageBlobFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageBlob NewStorageBlobPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListStorageBlob paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getStorageBlobFilters = map[string]string{
	"access_tier":              "Description.Blob.Properties.AccessTier",
	"access_tier_change_time":  "Description.Blob.Properties.AccessTierChangeTime",
	"access_tier_inferred":     "Description.Blob.Properties.AccessTierInferred",
	"archive_status":           "Description.Blob.Properties.ArchiveStatus",
	"blob_sequence_number":     "Description.Blob.Properties.BlobSequenceNumber",
	"blob_tag_set":             "Description.Blob.BlobTags.BlobTagSet",
	"cache_control":            "Description.Blob.Properties.CacheControl",
	"container_name":           "Description.ContainerName",
	"content_disposition":      "Description.Blob.Properties.ContentDisposition",
	"content_encoding":         "Description.Blob.Properties.ContentEncoding",
	"content_language":         "Description.Blob.Properties.ContentLanguage",
	"content_length":           "Description.Blob.Properties.ContentLength",
	"content_md5":              "Description.Blob.Properties.ContentMD5",
	"content_type":             "Description.Blob.Properties.ContentType",
	"copy_completion_time":     "Description.Blob.Properties.CopyCompletionTime",
	"copy_id":                  "Description.Blob.Properties.CopyID",
	"copy_progress":            "Description.Blob.Properties.CopyProgress",
	"copy_source":              "Description.Blob.Properties.CopySource",
	"copy_status":              "Description.Blob.Properties.CopyStatus",
	"copy_status_description":  "Description.Blob.Properties.CopyStatusDescription",
	"creation_time":            "Description.Blob.Properties.CreationTime",
	"deleted":                  "Description.Blob.Deleted",
	"deleted_time":             "Description.Blob.Properties.DeletedTime",
	"destination_snapshot":     "Description.Blob.Properties.DestinationSnapshot",
	"encryption_key_sha256":    "Description.Blob.Properties.CustomerProvidedKeySha256",
	"encryption_scope":         "Description.Blob.Properties.EncryptionScope",
	"etag":                     "Description.Blob.Properties.Etag",
	"incremental_copy":         "Description.Blob.Properties.IncrementalCopy",
	"is_current_version":       "Description.Blob.IsCurrentVersion",
	"is_sealed":                "Description.Blob.Properties.IsSealed",
	"is_snapshot":              "Description.IsSnapshot",
	"last_modified":            "Description.Blob.Properties.LastModified",
	"lease_duration":           "Description.Blob.Properties.LeaseDuration",
	"lease_state":              "Description.Blob.Properties.LeaseState",
	"lease_status":             "Description.Blob.Properties.LeaseStatus",
	"metadata":                 "Description.Blob.Metadata",
	"name":                     "Description.Blob.Name",
	"platform_integration_id":  "IntegrationID",
	"remaining_retention_days": "Description.Blob.Properties.RemainingRetentionDays",
	"server_encrypted":         "Description.Blob.Properties.ServerEncrypted",
	"snapshot":                 "Description.Blob.Snapshot",
	"storage_account_name":     "Description.AccountName",
	"subscription":             "Description.Blob.Properties.Subscription",
	"title":                    "Description.Blob.Name",
	"type":                     "Description.Blob.Properties.BlobType",
	"version_id":               "Description.Blob.VersionID",
}

func GetStorageBlob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStorageBlob")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewStorageBlobPaginator(essdk.BuildFilter(ctx, d.QueryContext, getStorageBlobFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: StorageBlob =============================

// ==========================  START: StorageBlobService =============================

type StorageBlobService struct {
	ResourceID      string                              `json:"resource_id"`
	PlatformID      string                              `json:"platform_id"`
	Description     azure.StorageBlobServiceDescription `json:"Description"`
	Metadata        azure.Metadata                      `json:"metadata"`
	DescribedBy     string                              `json:"described_by"`
	ResourceType    string                              `json:"resource_type"`
	IntegrationType string                              `json:"integration_type"`
	IntegrationID   string                              `json:"integration_id"`
}

type StorageBlobServiceHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  StorageBlobService `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type StorageBlobServiceHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []StorageBlobServiceHit `json:"hits"`
}

type StorageBlobServiceSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  StorageBlobServiceHits `json:"hits"`
}

type StorageBlobServicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStorageBlobServicePaginator(filters []essdk.BoolFilter, limit *int64) (StorageBlobServicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_storage_storageaccounts_blobservices", filters, limit)
	if err != nil {
		return StorageBlobServicePaginator{}, err
	}

	p := StorageBlobServicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StorageBlobServicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StorageBlobServicePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p StorageBlobServicePaginator) NextPage(ctx context.Context) ([]StorageBlobService, error) {
	var response StorageBlobServiceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StorageBlobService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStorageBlobServiceFilters = map[string]string{
	"automatic_snapshot_policy_enabled": "Description.BlobService.properties.automaticSnapshotPolicyEnabled",
	"change_feed_enabled":               "Description.BlobService.properties.changeFeed.enabled",
	"container_delete_retention_policy": "Description.BlobService.BlobServiceProperties.ContainerDeleteRetentionPolicy",
	"cors_rules":                        "Description.BlobService.BlobServiceProperties.Cors.CorsRules",
	"default_service_version":           "Description.BlobService.properties.defaultServiceVersion",
	"delete_retention_policy":           "Description.BlobService.BlobServiceProperties.ContainerDeleteRetentionPolicy",
	"id":                                "Description.BlobService.id",
	"is_versioning_enabled":             "Description.BlobService.properties.isVersioningEnabled",
	"name":                              "Description.BlobService.name",
	"platform_integration_id":           "IntegrationID",
	"resource_group":                    "description.ResourceGroup",
	"restore_policy":                    "Description.BlobService.BlobServiceProperties.RestorePolicy",
	"sku_name":                          "Description.BlobService.sku.name",
	"sku_tier":                          "Description.BlobService.sku.tier",
	"storage_account_name":              "description.AccountName",
	"subscription":                      "Description.BlobService.Properties.Subscription",
	"title":                             "Description.BlobService.name",
	"type":                              "Description.BlobService.type",
}

func ListStorageBlobService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStorageBlobService")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageBlobService NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageBlobService NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageBlobService GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageBlobService GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageBlobService GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewStorageBlobServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, listStorageBlobServiceFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageBlobService NewStorageBlobServicePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListStorageBlobService paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getStorageBlobServiceFilters = map[string]string{
	"automatic_snapshot_policy_enabled": "Description.BlobService.properties.automaticSnapshotPolicyEnabled",
	"change_feed_enabled":               "Description.BlobService.properties.changeFeed.enabled",
	"container_delete_retention_policy": "Description.BlobService.BlobServiceProperties.ContainerDeleteRetentionPolicy",
	"cors_rules":                        "Description.BlobService.BlobServiceProperties.Cors.CorsRules",
	"default_service_version":           "Description.BlobService.properties.defaultServiceVersion",
	"delete_retention_policy":           "Description.BlobService.BlobServiceProperties.ContainerDeleteRetentionPolicy",
	"id":                                "Description.BlobService.id",
	"is_versioning_enabled":             "Description.BlobService.properties.isVersioningEnabled",
	"name":                              "Description.BlobService.name",
	"platform_integration_id":           "IntegrationID",
	"resource_group":                    "Description.ResourceGroup",
	"restore_policy":                    "Description.BlobService.BlobServiceProperties.RestorePolicy",
	"sku_name":                          "Description.BlobService.sku.name",
	"sku_tier":                          "Description.BlobService.sku.tier",
	"storage_account_name":              "Description.AccountName",
	"subscription":                      "Description.BlobService.Properties.Subscription",
	"title":                             "Description.BlobService.name",
	"type":                              "Description.BlobService.type",
}

func GetStorageBlobService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStorageBlobService")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewStorageBlobServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, getStorageBlobServiceFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: StorageBlobService =============================

// ==========================  START: StorageQueue =============================

type StorageQueue struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     azure.StorageQueueDescription `json:"Description"`
	Metadata        azure.Metadata                `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type StorageQueueHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  StorageQueue  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type StorageQueueHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []StorageQueueHit `json:"hits"`
}

type StorageQueueSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  StorageQueueHits `json:"hits"`
}

type StorageQueuePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStorageQueuePaginator(filters []essdk.BoolFilter, limit *int64) (StorageQueuePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_storage_storageaccounts_queueservices", filters, limit)
	if err != nil {
		return StorageQueuePaginator{}, err
	}

	p := StorageQueuePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StorageQueuePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StorageQueuePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p StorageQueuePaginator) NextPage(ctx context.Context) ([]StorageQueue, error) {
	var response StorageQueueSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StorageQueue
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStorageQueueFilters = map[string]string{
	"id":                      "Description.Queue.id",
	"metadata":                "Description.Queue.QueueProperties.Metadata",
	"name":                    "description.Queue.Name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "description.ResourceGroup",
	"storage_account_name":    "description.AccountName",
	"subscription":            "Description.Queue.Properties.Subscription",
	"title":                   "Description.Queue.name",
	"type":                    "Description.Queue.type",
}

func ListStorageQueue(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStorageQueue")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageQueue NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageQueue NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageQueue GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageQueue GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageQueue GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewStorageQueuePaginator(essdk.BuildFilter(ctx, d.QueryContext, listStorageQueueFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageQueue NewStorageQueuePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListStorageQueue paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getStorageQueueFilters = map[string]string{
	"id":                      "Description.Queue.id",
	"metadata":                "Description.Queue.QueueProperties.Metadata",
	"name":                    "Description.Queue.name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "Description.ResourceGroup",
	"storage_account_name":    "Description.AccountName",
	"subscription":            "Description.Queue.Properties.Subscription",
	"title":                   "Description.Queue.name",
	"type":                    "Description.Queue.type",
}

func GetStorageQueue(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStorageQueue")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewStorageQueuePaginator(essdk.BuildFilter(ctx, d.QueryContext, getStorageQueueFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: StorageQueue =============================

// ==========================  START: StorageFileShare =============================

type StorageFileShare struct {
	ResourceID      string                            `json:"resource_id"`
	PlatformID      string                            `json:"platform_id"`
	Description     azure.StorageFileShareDescription `json:"Description"`
	Metadata        azure.Metadata                    `json:"metadata"`
	DescribedBy     string                            `json:"described_by"`
	ResourceType    string                            `json:"resource_type"`
	IntegrationType string                            `json:"integration_type"`
	IntegrationID   string                            `json:"integration_id"`
}

type StorageFileShareHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  StorageFileShare `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type StorageFileShareHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []StorageFileShareHit `json:"hits"`
}

type StorageFileShareSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  StorageFileShareHits `json:"hits"`
}

type StorageFileSharePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStorageFileSharePaginator(filters []essdk.BoolFilter, limit *int64) (StorageFileSharePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_storage_storageaccounts_largefilesharesstate", filters, limit)
	if err != nil {
		return StorageFileSharePaginator{}, err
	}

	p := StorageFileSharePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StorageFileSharePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StorageFileSharePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p StorageFileSharePaginator) NextPage(ctx context.Context) ([]StorageFileShare, error) {
	var response StorageFileShareSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StorageFileShare
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStorageFileShareFilters = map[string]string{
	"access_tier":              "Description.FileShare.properties.accessTier",
	"access_tier_status":       "Description.FileShare.properties.accessTierStatus",
	"deleted":                  "Description.FileShare.properties.deleted",
	"enabled_protocols":        "Description.FileShare.properties.enabledProtocols",
	"id":                       "Description.FileShare.id",
	"metadata":                 "Description.FileShare.Properties.Metadata",
	"name":                     "description.FileShare.Name",
	"platform_integration_id":  "IntegrationID",
	"remaining_retention_days": "Description.FileShare.properties.remainingRetentionDays",
	"resource_group":           "description.ResourceGroup",
	"root_squash":              "Description.FileShare.properties.rootSquash",
	"share_quota":              "Description.FileShare.properties.shareQuota",
	"share_usage_bytes":        "Description.FileShare.properties.shareUsageBytes",
	"storage_account_name":     "description.AccountName",
	"subscription":             "Description.FileShare.Properties.Subscription",
	"title":                    "Description.FileShare.name",
	"type":                     "Description.FileShare.type",
	"version":                  "Description.FileShare.properties.version",
}

func ListStorageFileShare(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStorageFileShare")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageFileShare NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageFileShare NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageFileShare GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageFileShare GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageFileShare GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewStorageFileSharePaginator(essdk.BuildFilter(ctx, d.QueryContext, listStorageFileShareFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageFileShare NewStorageFileSharePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListStorageFileShare paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getStorageFileShareFilters = map[string]string{
	"access_tier":              "Description.FileShare.properties.accessTier",
	"access_tier_status":       "Description.FileShare.properties.accessTierStatus",
	"deleted":                  "Description.FileShare.properties.deleted",
	"enabled_protocols":        "Description.FileShare.properties.enabledProtocols",
	"id":                       "Description.FileShare.id",
	"metadata":                 "Description.FileShare.Properties.Metadata",
	"name":                     "Description.FileShare.name",
	"platform_integration_id":  "IntegrationID",
	"remaining_retention_days": "Description.FileShare.properties.remainingRetentionDays",
	"root_squash":              "Description.FileShare.properties.rootSquash",
	"share_quota":              "Description.FileShare.properties.shareQuota",
	"share_usage_bytes":        "Description.FileShare.properties.shareUsageBytes",
	"storage_account_name":     "Description.AccountName",
	"subscription":             "Description.FileShare.Properties.Subscription",
	"title":                    "Description.FileShare.name",
	"type":                     "Description.FileShare.type",
	"version":                  "Description.FileShare.properties.version",
}

func GetStorageFileShare(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStorageFileShare")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewStorageFileSharePaginator(essdk.BuildFilter(ctx, d.QueryContext, getStorageFileShareFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: StorageFileShare =============================

// ==========================  START: StorageTable =============================

type StorageTable struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     azure.StorageTableDescription `json:"Description"`
	Metadata        azure.Metadata                `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type StorageTableHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  StorageTable  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type StorageTableHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []StorageTableHit `json:"hits"`
}

type StorageTableSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  StorageTableHits `json:"hits"`
}

type StorageTablePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStorageTablePaginator(filters []essdk.BoolFilter, limit *int64) (StorageTablePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_storage_storageaccounts_tableservices_tables", filters, limit)
	if err != nil {
		return StorageTablePaginator{}, err
	}

	p := StorageTablePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StorageTablePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StorageTablePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p StorageTablePaginator) NextPage(ctx context.Context) ([]StorageTable, error) {
	var response StorageTableSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StorageTable
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStorageTableFilters = map[string]string{
	"id":                      "Description.Table.id",
	"name":                    "description.Table.Name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "description.ResourceGroup",
	"storage_account_name":    "description.AccountName",
	"subscription":            "Description.Table.Properties.Subscription",
	"title":                   "Description.Table.name",
	"type":                    "Description.Table.type",
}

func ListStorageTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStorageTable")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageTable NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageTable NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageTable GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageTable GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageTable GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewStorageTablePaginator(essdk.BuildFilter(ctx, d.QueryContext, listStorageTableFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageTable NewStorageTablePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListStorageTable paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getStorageTableFilters = map[string]string{
	"id":                      "Description.Table.id",
	"name":                    "Description.Table.name",
	"platform_integration_id": "IntegrationID",
	"storage_account_name":    "Description.AccountName",
	"subscription":            "Description.Table.Properties.Subscription",
	"title":                   "Description.Table.name",
	"type":                    "Description.Table.type",
}

func GetStorageTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStorageTable")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewStorageTablePaginator(essdk.BuildFilter(ctx, d.QueryContext, getStorageTableFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: StorageTable =============================

// ==========================  START: StorageTableService =============================

type StorageTableService struct {
	ResourceID      string                               `json:"resource_id"`
	PlatformID      string                               `json:"platform_id"`
	Description     azure.StorageTableServiceDescription `json:"Description"`
	Metadata        azure.Metadata                       `json:"metadata"`
	DescribedBy     string                               `json:"described_by"`
	ResourceType    string                               `json:"resource_type"`
	IntegrationType string                               `json:"integration_type"`
	IntegrationID   string                               `json:"integration_id"`
}

type StorageTableServiceHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  StorageTableService `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type StorageTableServiceHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []StorageTableServiceHit `json:"hits"`
}

type StorageTableServiceSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  StorageTableServiceHits `json:"hits"`
}

type StorageTableServicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStorageTableServicePaginator(filters []essdk.BoolFilter, limit *int64) (StorageTableServicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_storage_storageaccounts_tableservices", filters, limit)
	if err != nil {
		return StorageTableServicePaginator{}, err
	}

	p := StorageTableServicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StorageTableServicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StorageTableServicePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p StorageTableServicePaginator) NextPage(ctx context.Context) ([]StorageTableService, error) {
	var response StorageTableServiceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StorageTableService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStorageTableServiceFilters = map[string]string{
	"cors_rules":              "Description.TableService.TableServiceProperties.Cors.CorsRules",
	"id":                      "Description.TableService.id",
	"name":                    "description.TableService.Name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "description.ResourceGroup",
	"storage_account_name":    "description.AccountName",
	"subscription":            "Description.TableService.Properties.Subscription",
	"title":                   "Description.TableService.name",
	"type":                    "Description.TableService.type",
}

func ListStorageTableService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStorageTableService")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageTableService NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageTableService NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageTableService GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageTableService GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageTableService GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewStorageTableServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, listStorageTableServiceFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageTableService NewStorageTableServicePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListStorageTableService paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getStorageTableServiceFilters = map[string]string{
	"cors_rules":              "Description.TableService.TableServiceProperties.Cors.CorsRules",
	"id":                      "Description.TableService.id",
	"name":                    "Description.TableService.name",
	"platform_integration_id": "IntegrationID",
	"storage_account_name":    "Description.AccountName",
	"subscription":            "Description.TableService.Properties.Subscription",
	"title":                   "Description.TableService.name",
	"type":                    "Description.TableService.type",
}

func GetStorageTableService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStorageTableService")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewStorageTableServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, getStorageTableServiceFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: StorageTableService =============================

// ==========================  START: Subnet =============================

type Subnet struct {
	ResourceID      string                  `json:"resource_id"`
	PlatformID      string                  `json:"platform_id"`
	Description     azure.SubnetDescription `json:"Description"`
	Metadata        azure.Metadata          `json:"metadata"`
	DescribedBy     string                  `json:"described_by"`
	ResourceType    string                  `json:"resource_type"`
	IntegrationType string                  `json:"integration_type"`
	IntegrationID   string                  `json:"integration_id"`
}

type SubnetHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Subnet        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SubnetHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SubnetHit       `json:"hits"`
}

type SubnetSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  SubnetHits `json:"hits"`
}

type SubnetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSubnetPaginator(filters []essdk.BoolFilter, limit *int64) (SubnetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_virtualnetworks_subnets", filters, limit)
	if err != nil {
		return SubnetPaginator{}, err
	}

	p := SubnetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SubnetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SubnetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SubnetPaginator) NextPage(ctx context.Context) ([]Subnet, error) {
	var response SubnetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Subnet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSubnetFilters = map[string]string{
	"address_prefix":                        "Description.Subnet.properties.addressPrefix",
	"delegations":                           "Description.Subnet.Properties.Delegations",
	"etag":                                  "Description.Subnet.etag",
	"id":                                    "Description.Subnet.id",
	"ip_configurations":                     "Description.Subnet.Properties.IPConfigurations",
	"name":                                  "Description.Subnet.name",
	"nat_gateway_id":                        "Description.Subnet.properties.natGateway.id",
	"network_security_group_id":             "Description.Subnet.properties.networkSecurityGroup.id",
	"platform_integration_id":               "IntegrationID",
	"private_endpoint_network_policies":     "Description.Subnet.properties.privateEndpointNetworkPolicies",
	"private_link_service_network_policies": "Description.Subnet.properties.privateLinkServiceNetworkPolicies",
	"provisioning_state":                    "Description.Subnet.properties.provisioningState",
	"route_table_id":                        "Description.Subnet.properties.routeTable.id",
	"service_endpoint_policies":             "Description.Subnet.Properties.ServiceEndpointPolicies",
	"service_endpoints":                     "Description.Subnet.Properties.ServiceEndpoints",
	"subscription":                          "Description.Subnet.Properties.Subscription",
	"title":                                 "Description.Subnet.name",
	"type":                                  "Description.Subnet.properties.routeTable.type",
	"virtual_network_name":                  "Description.VirtualNetworkName",
}

func ListSubnet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSubnet")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSubnet NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSubnet NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSubnet GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSubnet GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSubnet GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSubnetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSubnetFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSubnet NewSubnetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSubnet paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSubnetFilters = map[string]string{
	"address_prefix":                        "Description.Subnet.properties.addressPrefix",
	"delegations":                           "Description.Subnet.Properties.Delegations",
	"etag":                                  "Description.Subnet.etag",
	"id":                                    "Description.Subnet.id",
	"ip_configurations":                     "Description.Subnet.Properties.IPConfigurations",
	"name":                                  "description.Subnet.name",
	"nat_gateway_id":                        "Description.Subnet.properties.natGateway.id",
	"network_security_group_id":             "Description.Subnet.properties.networkSecurityGroup.id",
	"platform_integration_id":               "IntegrationID",
	"private_endpoint_network_policies":     "Description.Subnet.properties.privateEndpointNetworkPolicies",
	"private_link_service_network_policies": "Description.Subnet.properties.privateLinkServiceNetworkPolicies",
	"provisioning_state":                    "Description.Subnet.properties.provisioningState",
	"resource_group":                        "description.ResourceGroup",
	"route_table_id":                        "Description.Subnet.properties.routeTable.id",
	"service_endpoint_policies":             "Description.Subnet.Properties.ServiceEndpointPolicies",
	"service_endpoints":                     "Description.Subnet.Properties.ServiceEndpoints",
	"subscription":                          "Description.Subnet.Properties.Subscription",
	"title":                                 "Description.Subnet.name",
	"type":                                  "Description.Subnet.properties.routeTable.type",
	"virtual_network_name":                  "description.VirtualNetworkName",
}

func GetSubnet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSubnet")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSubnetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSubnetFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Subnet =============================

// ==========================  START: VirtualNetwork =============================

type VirtualNetwork struct {
	ResourceID      string                          `json:"resource_id"`
	PlatformID      string                          `json:"platform_id"`
	Description     azure.VirtualNetworkDescription `json:"Description"`
	Metadata        azure.Metadata                  `json:"metadata"`
	DescribedBy     string                          `json:"described_by"`
	ResourceType    string                          `json:"resource_type"`
	IntegrationType string                          `json:"integration_type"`
	IntegrationID   string                          `json:"integration_id"`
}

type VirtualNetworkHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  VirtualNetwork `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type VirtualNetworkHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []VirtualNetworkHit `json:"hits"`
}

type VirtualNetworkSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  VirtualNetworkHits `json:"hits"`
}

type VirtualNetworkPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewVirtualNetworkPaginator(filters []essdk.BoolFilter, limit *int64) (VirtualNetworkPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_virtualnetworks", filters, limit)
	if err != nil {
		return VirtualNetworkPaginator{}, err
	}

	p := VirtualNetworkPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p VirtualNetworkPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p VirtualNetworkPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p VirtualNetworkPaginator) NextPage(ctx context.Context) ([]VirtualNetwork, error) {
	var response VirtualNetworkSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []VirtualNetwork
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listVirtualNetworkFilters = map[string]string{
	"address_prefixes":        "Description.VirtualNetwork.Properties.AddressSpace.AddressPrefixes",
	"enable_ddos_protection":  "Description.VirtualNetwork.properties.enableDdosProtection",
	"enable_vm_protection":    "Description.VirtualNetwork.properties.enableVmProtection",
	"etag":                    "Description.VirtualNetwork.etag",
	"id":                      "Description.VirtualNetwork.id",
	"name":                    "Description.VirtualNetwork.name",
	"network_peerings":        "Description.VirtualNetwork.Properties.VirtualNetworkPeerings",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.VirtualNetwork.properties.provisioningState",
	"resource_group":          "Description.ResourceGroup",
	"resource_guid":           "Description.VirtualNetwork.properties.resourceGuid",
	"subnets":                 "Description.VirtualNetwork.Properties.Subnets",
	"subscription":            "Description.VirtualNetwork.Properties.Subscription",
	"tags":                    "Description.VirtualNetwork.Tags",
	"title":                   "Description.VirtualNetwork.name",
	"type":                    "Description.VirtualNetwork.type",
}

func ListVirtualNetwork(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListVirtualNetwork")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualNetwork NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualNetwork NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualNetwork GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualNetwork GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualNetwork GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewVirtualNetworkPaginator(essdk.BuildFilter(ctx, d.QueryContext, listVirtualNetworkFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualNetwork NewVirtualNetworkPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListVirtualNetwork paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getVirtualNetworkFilters = map[string]string{
	"address_prefixes":        "Description.VirtualNetwork.Properties.AddressSpace.AddressPrefixes",
	"enable_ddos_protection":  "Description.VirtualNetwork.properties.enableDdosProtection",
	"enable_vm_protection":    "Description.VirtualNetwork.properties.enableVmProtection",
	"etag":                    "Description.VirtualNetwork.etag",
	"id":                      "Description.VirtualNetwork.id",
	"name":                    "description.VirtualNetwork.name",
	"network_peerings":        "Description.VirtualNetwork.Properties.VirtualNetworkPeerings",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.VirtualNetwork.properties.provisioningState",
	"resource_group":          "description.ResourceGroup",
	"resource_guid":           "Description.VirtualNetwork.properties.resourceGuid",
	"subnets":                 "Description.VirtualNetwork.Properties.Subnets",
	"subscription":            "Description.VirtualNetwork.Properties.Subscription",
	"tags":                    "Description.VirtualNetwork.Tags",
	"title":                   "Description.VirtualNetwork.name",
	"type":                    "Description.VirtualNetwork.type",
}

func GetVirtualNetwork(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetVirtualNetwork")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewVirtualNetworkPaginator(essdk.BuildFilter(ctx, d.QueryContext, getVirtualNetworkFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: VirtualNetwork =============================

// ==========================  START: Tenant =============================

type Tenant struct {
	ResourceID      string                  `json:"resource_id"`
	PlatformID      string                  `json:"platform_id"`
	Description     azure.TenantDescription `json:"Description"`
	Metadata        azure.Metadata          `json:"metadata"`
	DescribedBy     string                  `json:"described_by"`
	ResourceType    string                  `json:"resource_type"`
	IntegrationType string                  `json:"integration_type"`
	IntegrationID   string                  `json:"integration_id"`
}

type TenantHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Tenant        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type TenantHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []TenantHit       `json:"hits"`
}

type TenantSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  TenantHits `json:"hits"`
}

type TenantPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewTenantPaginator(filters []essdk.BoolFilter, limit *int64) (TenantPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_resources_tenants", filters, limit)
	if err != nil {
		return TenantPaginator{}, err
	}

	p := TenantPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p TenantPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p TenantPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p TenantPaginator) NextPage(ctx context.Context) ([]Tenant, error) {
	var response TenantSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Tenant
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listTenantFilters = map[string]string{
	"display_name":            "Description.TenantIDDescription.Name",
	"id":                      "Description.TenantIDDescription.id",
	"name":                    "Description.TenantIDDescription.Name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.TenantIDDescription.Properties.Subscription",
	"tenant_category":         "TenantCategory",
	"tenant_id":               "Description.TenantIDDescription.tenantId",
	"title":                   "Description.TenantIDDescription.Name",
}

func ListTenant(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListTenant")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListTenant NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListTenant NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListTenant GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListTenant GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListTenant GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewTenantPaginator(essdk.BuildFilter(ctx, d.QueryContext, listTenantFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListTenant NewTenantPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListTenant paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getTenantFilters = map[string]string{
	"display_name":            "Description.TenantIDDescription.Name",
	"id":                      "Description.TenantIDDescription.id",
	"name":                    "Description.TenantIDDescription.Name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.TenantIDDescription.Properties.Subscription",
	"tenant_category":         "TenantCategory",
	"tenant_id":               "Description.TenantIDDescription.tenantId",
	"title":                   "Description.TenantIDDescription.Name",
}

func GetTenant(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetTenant")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewTenantPaginator(essdk.BuildFilter(ctx, d.QueryContext, getTenantFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Tenant =============================

// ==========================  START: Subscription =============================

type Subscription struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     azure.SubscriptionDescription `json:"Description"`
	Metadata        azure.Metadata                `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type SubscriptionHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Subscription  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SubscriptionHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SubscriptionHit `json:"hits"`
}

type SubscriptionSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  SubscriptionHits `json:"hits"`
}

type SubscriptionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSubscriptionPaginator(filters []essdk.BoolFilter, limit *int64) (SubscriptionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_resources_subscriptions", filters, limit)
	if err != nil {
		return SubscriptionPaginator{}, err
	}

	p := SubscriptionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SubscriptionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SubscriptionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SubscriptionPaginator) NextPage(ctx context.Context) ([]Subscription, error) {
	var response SubscriptionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Subscription
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSubscriptionFilters = map[string]string{
	"authorization_source":      "Description.Subscription.authorizationSource",
	"display_name":              "Description.Subscription.displayName",
	"id":                        "Description.Subscription.id",
	"platform_integration_id":   "IntegrationID",
	"qualified_subscription_id": "Description.Subscription.id",
	"state":                     "Description.Subscription.state",
	"subscription_id":           "Description.Subscription.subscriptionId",
	"subscription_policies":     "Description.Subscription.subscriptionPolicies",
	"tags":                      "Description.Tags",
	"tenant_id":                 "TenantID",
	"title":                     "Description.Subscription.displayName",
}

func ListSubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSubscription")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSubscription NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSubscription NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSubscription GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSubscription GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSubscription GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSubscriptionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSubscriptionFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSubscription NewSubscriptionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSubscription paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSubscriptionFilters = map[string]string{
	"authorization_source":      "Description.Subscription.authorizationSource",
	"display_name":              "Description.Subscription.displayName",
	"id":                        "Description.Subscription.id",
	"platform_integration_id":   "IntegrationID",
	"qualified_subscription_id": "Description.Subscription.id",
	"state":                     "Description.Subscription.state",
	"subscription_id":           "Description.Subscription.subscriptionId",
	"subscription_policies":     "Description.Subscription.subscriptionPolicies",
	"tags":                      "Description.Tags",
	"tenant_id":                 "TenantID",
	"title":                     "Description.Subscription.displayName",
}

func GetSubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSubscription")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSubscriptionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSubscriptionFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Subscription =============================

// ==========================  START: ApplicationGateway =============================

type ApplicationGateway struct {
	ResourceID      string                              `json:"resource_id"`
	PlatformID      string                              `json:"platform_id"`
	Description     azure.ApplicationGatewayDescription `json:"Description"`
	Metadata        azure.Metadata                      `json:"metadata"`
	DescribedBy     string                              `json:"described_by"`
	ResourceType    string                              `json:"resource_type"`
	IntegrationType string                              `json:"integration_type"`
	IntegrationID   string                              `json:"integration_id"`
}

type ApplicationGatewayHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  ApplicationGateway `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type ApplicationGatewayHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []ApplicationGatewayHit `json:"hits"`
}

type ApplicationGatewaySearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  ApplicationGatewayHits `json:"hits"`
}

type ApplicationGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApplicationGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (ApplicationGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_applicationgateways", filters, limit)
	if err != nil {
		return ApplicationGatewayPaginator{}, err
	}

	p := ApplicationGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApplicationGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApplicationGatewayPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ApplicationGatewayPaginator) NextPage(ctx context.Context) ([]ApplicationGateway, error) {
	var response ApplicationGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApplicationGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApplicationGatewayFilters = map[string]string{
	"autoscale_configuration":                "Description.ApplicationGateway.Properties.AutoscaleConfiguration",
	"custom_error_configurations":            "Description.ApplicationGateway.Properties.CustomErrorConfigurations",
	"diagnostic_settings":                    "Description.DiagnosticSettingsResources",
	"enable_fips":                            "Description.ApplicationGateway.properties.enableFips",
	"enable_http2":                           "Description.ApplicationGateway.properties.enableHttp2",
	"etag":                                   "Description.ApplicationGateway.etag",
	"firewall_policy":                        "Description.ApplicationGateway.Properties.FirewallPolicy",
	"force_firewall_policy_association":      "Description.ApplicationGateway.properties.forceFirewallPolicyAssociation",
	"id":                                     "Description.ApplicationGateway.id",
	"identity":                               "Description.ApplicationGateway.Identity",
	"name":                                   "Description.ApplicationGateway.name",
	"operational_state":                      "Description.ApplicationGateway.properties.operationalState",
	"platform_integration_id":                "IntegrationID",
	"provisioning_state":                     "Description.ApplicationGateway.properties.provisioningState",
	"redirect_configurations":                "Description.ApplicationGateway.Properties.RedirectConfigurations",
	"resource_group":                         "Description.ResourceGroup",
	"resource_guid":                          "Description.ApplicationGateway.properties.resourceGuid",
	"sku":                                    "Description.ApplicationGateway.Properties.SKU",
	"ssl_policy":                             "Description.ApplicationGateway.Properties.SSLPolicy",
	"subscription":                           "Description.ApplicationGateway.Properties.Subscription",
	"tags":                                   "Description.ApplicationGateway.Tags",
	"title":                                  "Description.ApplicationGateway.name",
	"type":                                   "Description.ApplicationGateway.type",
	"web_application_firewall_configuration": "Description.ApplicationGateway.Properties.WebApplicationFirewallConfiguration",
	"zones":                                  "Description.ApplicationGateway.Zones",
}

func ListApplicationGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApplicationGateway")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListApplicationGateway NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListApplicationGateway NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListApplicationGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListApplicationGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListApplicationGateway GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewApplicationGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, listApplicationGatewayFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListApplicationGateway NewApplicationGatewayPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListApplicationGateway paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getApplicationGatewayFilters = map[string]string{
	"autoscale_configuration":                "Description.ApplicationGateway.Properties.AutoscaleConfiguration",
	"custom_error_configurations":            "Description.ApplicationGateway.Properties.CustomErrorConfigurations",
	"diagnostic_settings":                    "Description.DiagnosticSettingsResources",
	"enable_fips":                            "Description.ApplicationGateway.properties.enableFips",
	"enable_http2":                           "Description.ApplicationGateway.properties.enableHttp2",
	"etag":                                   "Description.ApplicationGateway.etag",
	"firewall_policy":                        "Description.ApplicationGateway.Properties.FirewallPolicy",
	"force_firewall_policy_association":      "Description.ApplicationGateway.properties.forceFirewallPolicyAssociation",
	"id":                                     "Description.ApplicationGateway.id",
	"identity":                               "Description.ApplicationGateway.Identity",
	"name":                                   "description.ApplicationGateway.name",
	"operational_state":                      "Description.ApplicationGateway.properties.operationalState",
	"platform_integration_id":                "IntegrationID",
	"provisioning_state":                     "Description.ApplicationGateway.properties.provisioningState",
	"redirect_configurations":                "Description.ApplicationGateway.Properties.RedirectConfigurations",
	"resource_group":                         "description.ResourceGroup",
	"resource_guid":                          "Description.ApplicationGateway.properties.resourceGuid",
	"sku":                                    "Description.ApplicationGateway.Properties.SKU",
	"ssl_policy":                             "Description.ApplicationGateway.Properties.SSLPolicy",
	"subscription":                           "Description.ApplicationGateway.Properties.Subscription",
	"tags":                                   "Description.ApplicationGateway.Tags",
	"title":                                  "Description.ApplicationGateway.name",
	"type":                                   "Description.ApplicationGateway.type",
	"web_application_firewall_configuration": "Description.ApplicationGateway.Properties.WebApplicationFirewallConfiguration",
	"zones":                                  "Description.ApplicationGateway.Zones",
}

func GetApplicationGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApplicationGateway")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewApplicationGatewayPaginator(essdk.BuildFilter(ctx, d.QueryContext, getApplicationGatewayFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ApplicationGateway =============================

// ==========================  START: BatchAccount =============================

type BatchAccount struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     azure.BatchAccountDescription `json:"Description"`
	Metadata        azure.Metadata                `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type BatchAccountHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  BatchAccount  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type BatchAccountHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []BatchAccountHit `json:"hits"`
}

type BatchAccountSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  BatchAccountHits `json:"hits"`
}

type BatchAccountPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBatchAccountPaginator(filters []essdk.BoolFilter, limit *int64) (BatchAccountPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_batch_batchaccounts", filters, limit)
	if err != nil {
		return BatchAccountPaginator{}, err
	}

	p := BatchAccountPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BatchAccountPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BatchAccountPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BatchAccountPaginator) NextPage(ctx context.Context) ([]BatchAccount, error) {
	var response BatchAccountSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BatchAccount
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBatchAccountFilters = map[string]string{
	"account_endpoint":                            "Description.Account.properties.accountEndpoint",
	"active_job_and_job_schedule_quota":           "Description.Account.properties.activeJobAndJobScheduleQuota",
	"auto_storage":                                "Description.Account.Properties.AutoStorage",
	"dedicated_core_quota":                        "Description.Account.properties.dedicatedCoreQuota",
	"dedicated_core_quota_per_vm_family":          "Description.Account.Properties.DedicatedCoreQuotaPerVMFamily",
	"dedicated_core_quota_per_vm_family_enforced": "Description.Account.properties.dedicatedCoreQuotaPerVMFamilyEnforced",
	"diagnostic_settings":                         "Description.DiagnosticSettingsResources",
	"encryption":                                  "Description.Account.Properties.Encryption",
	"id":                                          "Description.Account.id",
	"identity":                                    "Description.Account.Identity",
	"key_vault_reference":                         "Description.Account.Properties.KeyVaultReference",
	"low_priority_core_quota":                     "Description.Account.properties.lowPriorityCoreQuota",
	"name":                                        "Description.Account.name",
	"platform_integration_id":                     "IntegrationID",
	"pool_allocation_mode":                        "Description.Account.properties.poolAllocationMode",
	"pool_quota":                                  "Description.Account.properties.poolQuota",
	"private_endpoint_connections":                "Description.Account.Properties.PrivateEndpointConnections",
	"provisioning_state":                          "Description.Account.properties.provisioningState",
	"public_network_access":                       "Description.Account.properties.publicNetworkAccess",
	"resource_group":                              "Description.ResourceGroup",
	"subscription":                                "Description.Account.Properties.Subscription",
	"tags":                                        "Description.Account.Tags",
	"title":                                       "Description.Account.name",
	"type":                                        "Description.Account.type",
}

func ListBatchAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBatchAccount")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBatchAccount NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBatchAccount NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBatchAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBatchAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBatchAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBatchAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, listBatchAccountFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBatchAccount NewBatchAccountPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBatchAccount paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBatchAccountFilters = map[string]string{
	"account_endpoint":                            "Description.Account.properties.accountEndpoint",
	"active_job_and_job_schedule_quota":           "Description.Account.properties.activeJobAndJobScheduleQuota",
	"auto_storage":                                "Description.Account.Properties.AutoStorage",
	"dedicated_core_quota":                        "Description.Account.properties.dedicatedCoreQuota",
	"dedicated_core_quota_per_vm_family":          "Description.Account.Properties.DedicatedCoreQuotaPerVMFamily",
	"dedicated_core_quota_per_vm_family_enforced": "Description.Account.properties.dedicatedCoreQuotaPerVMFamilyEnforced",
	"diagnostic_settings":                         "Description.DiagnosticSettingsResources",
	"encryption":                                  "Description.Account.Properties.Encryption",
	"id":                                          "Description.Account.id",
	"identity":                                    "Description.Account.Identity",
	"key_vault_reference":                         "Description.Account.Properties.KeyVaultReference",
	"low_priority_core_quota":                     "Description.Account.properties.lowPriorityCoreQuota",
	"name":                                        "description.Account.name",
	"platform_integration_id":                     "IntegrationID",
	"pool_allocation_mode":                        "Description.Account.properties.poolAllocationMode",
	"pool_quota":                                  "Description.Account.properties.poolQuota",
	"private_endpoint_connections":                "Description.Account.Properties.PrivateEndpointConnections",
	"provisioning_state":                          "Description.Account.properties.provisioningState",
	"public_network_access":                       "Description.Account.properties.publicNetworkAccess",
	"resource_group":                              "description.ResourceGroup",
	"subscription":                                "Description.Account.Properties.Subscription",
	"tags":                                        "Description.Account.Tags",
	"title":                                       "Description.Account.name",
	"type":                                        "Description.Account.type",
}

func GetBatchAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBatchAccount")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBatchAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, getBatchAccountFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: BatchAccount =============================

// ==========================  START: CognitiveAccount =============================

type CognitiveAccount struct {
	ResourceID      string                            `json:"resource_id"`
	PlatformID      string                            `json:"platform_id"`
	Description     azure.CognitiveAccountDescription `json:"Description"`
	Metadata        azure.Metadata                    `json:"metadata"`
	DescribedBy     string                            `json:"described_by"`
	ResourceType    string                            `json:"resource_type"`
	IntegrationType string                            `json:"integration_type"`
	IntegrationID   string                            `json:"integration_id"`
}

type CognitiveAccountHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  CognitiveAccount `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type CognitiveAccountHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []CognitiveAccountHit `json:"hits"`
}

type CognitiveAccountSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  CognitiveAccountHits `json:"hits"`
}

type CognitiveAccountPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCognitiveAccountPaginator(filters []essdk.BoolFilter, limit *int64) (CognitiveAccountPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_cognitiveservices_accounts", filters, limit)
	if err != nil {
		return CognitiveAccountPaginator{}, err
	}

	p := CognitiveAccountPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CognitiveAccountPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CognitiveAccountPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CognitiveAccountPaginator) NextPage(ctx context.Context) ([]CognitiveAccount, error) {
	var response CognitiveAccountSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CognitiveAccount
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCognitiveAccountFilters = map[string]string{
	"allowed_fqdn_list":                "Description.Account.Properties.AllowedFqdnList",
	"api_properties":                   "Description.Account.Properties.APIProperties",
	"call_rate_limit":                  "Description.Account.Properties.CallRateLimit",
	"capabilities":                     "Description.Account.Properties.Capabilities",
	"custom_sub_domain_name":           "Description.Account.properties.customSubDomainName",
	"date_created":                     "Description.Account.properties.dateCreated",
	"diagnostic_settings":              "Description.DiagnosticSettingsResources",
	"disable_local_auth":               "Description.Account.properties.disableLocalAuth",
	"encryption":                       "Description.Account.Properties.Encryption",
	"endpoint":                         "Description.Account.properties.endpoint",
	"endpoints":                        "Description.Account.Properties.Endpoints",
	"etag":                             "Description.Account.etag",
	"id":                               "Description.Account.id",
	"identity":                         "Description.Account.Identity",
	"is_migrated":                      "Description.Account.properties.isMigrated",
	"kind":                             "Description.Account.kind",
	"migration_token":                  "Description.Account.properties.migrationToken",
	"name":                             "Description.Account.name",
	"network_acls":                     "Description.Account.Properties.NetworkACLs",
	"platform_integration_id":          "IntegrationID",
	"provisioning_state":               "Description.Account.properties.provisioningState",
	"public_network_access":            "Description.Account.properties.publicNetworkAccess",
	"quota_limit":                      "Description.Account.Properties.QuotaLimit",
	"resource_group":                   "Description.ResourceGroup",
	"restore":                          "Description.Account.properties.restore",
	"restrict_outbound_network_access": "Description.Account.properties.restrictOutboundNetworkAccess",
	"sku":                              "Description.Account.SKU",
	"sku_change_info":                  "Description.Account.Properties.SKUChangeInfo",
	"subscription":                     "Description.Account.Properties.Subscription",
	"system_data":                      "Description.Account.SystemData",
	"tags":                             "Description.Account.Tags",
	"title":                            "Description.Account.name",
	"type":                             "Description.Account.type",
	"user_owned_storage":               "Description.Account.Properties.UserOwnedStorage",
}

func ListCognitiveAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCognitiveAccount")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCognitiveAccount NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCognitiveAccount NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCognitiveAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCognitiveAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCognitiveAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCognitiveAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCognitiveAccountFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCognitiveAccount NewCognitiveAccountPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCognitiveAccount paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCognitiveAccountFilters = map[string]string{
	"allowed_fqdn_list":                "Description.Account.Properties.AllowedFqdnList",
	"api_properties":                   "Description.Account.Properties.APIProperties",
	"call_rate_limit":                  "Description.Account.Properties.CallRateLimit",
	"capabilities":                     "Description.Account.Properties.Capabilities",
	"custom_sub_domain_name":           "Description.Account.properties.customSubDomainName",
	"date_created":                     "Description.Account.properties.dateCreated",
	"diagnostic_settings":              "Description.DiagnosticSettingsResources",
	"disable_local_auth":               "Description.Account.properties.disableLocalAuth",
	"encryption":                       "Description.Account.Properties.Encryption",
	"endpoint":                         "Description.Account.properties.endpoint",
	"endpoints":                        "Description.Account.Properties.Endpoints",
	"etag":                             "Description.Account.etag",
	"id":                               "Description.Account.id",
	"identity":                         "Description.Account.Identity",
	"is_migrated":                      "Description.Account.properties.isMigrated",
	"kind":                             "Description.Account.kind",
	"migration_token":                  "Description.Account.properties.migrationToken",
	"name":                             "description.Account.name",
	"network_acls":                     "Description.Account.Properties.NetworkACLs",
	"platform_integration_id":          "IntegrationID",
	"provisioning_state":               "Description.Account.properties.provisioningState",
	"public_network_access":            "Description.Account.properties.publicNetworkAccess",
	"quota_limit":                      "Description.Account.Properties.QuotaLimit",
	"resource_group":                   "description.ResourceGroup",
	"restore":                          "Description.Account.properties.restore",
	"restrict_outbound_network_access": "Description.Account.properties.restrictOutboundNetworkAccess",
	"sku":                              "Description.Account.SKU",
	"sku_change_info":                  "Description.Account.Properties.SKUChangeInfo",
	"subscription":                     "Description.Account.Properties.Subscription",
	"system_data":                      "Description.Account.SystemData",
	"tags":                             "Description.Account.Tags",
	"title":                            "Description.Account.name",
	"type":                             "Description.Account.type",
	"user_owned_storage":               "Description.Account.Properties.UserOwnedStorage",
}

func GetCognitiveAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCognitiveAccount")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCognitiveAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCognitiveAccountFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CognitiveAccount =============================

// ==========================  START: ComputeVirtualMachine =============================

type ComputeVirtualMachine struct {
	ResourceID      string                                 `json:"resource_id"`
	PlatformID      string                                 `json:"platform_id"`
	Description     azure.ComputeVirtualMachineDescription `json:"Description"`
	Metadata        azure.Metadata                         `json:"metadata"`
	DescribedBy     string                                 `json:"described_by"`
	ResourceType    string                                 `json:"resource_type"`
	IntegrationType string                                 `json:"integration_type"`
	IntegrationID   string                                 `json:"integration_id"`
}

type ComputeVirtualMachineHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  ComputeVirtualMachine `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type ComputeVirtualMachineHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []ComputeVirtualMachineHit `json:"hits"`
}

type ComputeVirtualMachineSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  ComputeVirtualMachineHits `json:"hits"`
}

type ComputeVirtualMachinePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeVirtualMachinePaginator(filters []essdk.BoolFilter, limit *int64) (ComputeVirtualMachinePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_virtualmachines", filters, limit)
	if err != nil {
		return ComputeVirtualMachinePaginator{}, err
	}

	p := ComputeVirtualMachinePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeVirtualMachinePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeVirtualMachinePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ComputeVirtualMachinePaginator) NextPage(ctx context.Context) ([]ComputeVirtualMachine, error) {
	var response ComputeVirtualMachineSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeVirtualMachine
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeVirtualMachineFilters = map[string]string{
	"additional_unattend_content":         "Description.VirtualMachine.Properties.OSProfile.WindowsConfiguration.AdditionalUnattendContent",
	"admin_user_name":                     "Description.VirtualMachine.properties.osProfile.adminUsername",
	"allow_extension_operations":          "Description.VirtualMachine.properties.osProfile.allowExtensionOperations",
	"availability_set_id":                 "Description.VirtualMachine.properties.availabilitySet.id",
	"billing_profile_max_price":           "Description.VirtualMachine.properties.billingProfile.maxPrice",
	"boot_diagnostics_enabled":            "Description.VirtualMachine.properties.diagnosticsProfile.bootDiagnostics.enabled",
	"boot_diagnostics_storage_uri":        "Description.VirtualMachine.properties.diagnosticsProfile.bootDiagnostics.storageUri",
	"computer_name":                       "Description.VirtualMachine.properties.osProfile.computerName",
	"data_disks":                          "Description.VirtualMachine.Properties.StorageProfile.DataDisks",
	"disable_password_authentication":     "Description.VirtualMachine.properties.osProfile.linuxConfiguration.disablePasswordAuthentication",
	"enable_automatic_updates":            "Description.VirtualMachine.properties.osProfile.windowsConfiguration.enableAutomaticUpdates",
	"eviction_policy":                     "Description.VirtualMachine.properties.evictionPolicy",
	"extensions":                          "Description.VirtualMachineExtension",
	"extensions_settings":                 "Description.ExtensionsSettings",
	"guest_configuration_assignments":     "Description.Assignments",
	"id":                                  "Description.VirtualMachine.id",
	"identity":                            "Description.VirtualMachine.Identity",
	"image_exact_version":                 "Description.VirtualMachine.properties.storageProfile.imageReference.exactVersion",
	"image_id":                            "Description.VirtualMachine.properties.storageProfile.imageReference.id",
	"image_offer":                         "Description.VirtualMachine.properties.storageProfile.imageReference.offer",
	"image_publisher":                     "Description.VirtualMachine.properties.storageProfile.imageReference.publisher",
	"image_sku":                           "Description.VirtualMachine.properties.storageProfile.imageReference.sku",
	"image_version":                       "Description.VirtualMachine.properties.storageProfile.imageReference.version",
	"linux_configuration_ssh_public_keys": "Description.VirtualMachine.Properties.OSProfile.LinuxConfiguration.SSH.PublicKeys",
	"managed_disk_id":                     "Description.VirtualMachine.properties.storageProfile.osDisk.managedDisk.id",
	"name":                                "Description.VirtualMachine.name",
	"network_interfaces":                  "Description.VirtualMachine.Properties.NetworkProfile.NetworkInterfaces",
	"os_disk_caching":                     "Description.VirtualMachine.properties.storageProfile.osDisk.caching",
	"os_disk_create_option":               "Description.VirtualMachine.properties.storageProfile.osDisk.createOption",
	"os_disk_name":                        "Description.VirtualMachine.properties.storageProfile.osDisk.name",
	"os_disk_vhd_uri":                     "Description.VirtualMachine.properties.storageProfile.osDisk.vhd.uri",
	"os_name":                             "Description.VirtualMachineInstanceView.osName",
	"os_type":                             "Description.VirtualMachine.properties.storageProfile.osDisk.osType",
	"os_version":                          "Description.VirtualMachineInstanceView.osVersion",
	"patch_settings":                      "Description.VirtualMachine.Properties.OSProfile.WindowsConfiguration.PatchSettings",
	"platform_integration_id":             "IntegrationID",
	"priority":                            "Description.VirtualMachine.properties.priority",
	"provision_vm_agent":                  "Description.VirtualMachine.properties.osProfile.linuxConfiguration.provisionVMAgent",
	"provision_vm_agent_windows":          "Description.VirtualMachine.properties.osProfile.windowsConfiguration.provisionVMAgent",
	"provisioning_state":                  "Description.VirtualMachine.properties.provisioningState",
	"public_ips":                          "Description.PublicIPs",
	"require_guest_provision_signal":      "Description.VirtualMachine.properties.osProfile.requireGuestProvisionSignal",
	"resource_group":                      "Description.ResourceGroup",
	"secrets":                             "Description.VirtualMachine.Properties.OSProfile.Secrets",
	"security_profile":                    "Description.VirtualMachine.Properties.SecurityProfile",
	"size":                                "Description.VirtualMachine.properties.hardwareProfile.vmSize",
	"statuses":                            "Description.VirtualMachineInstanceView.Statuses",
	"subscription":                        "Description.VirtualMachine.Properties.Subscription",
	"tags":                                "Description.VirtualMachine.Tags",
	"time_zone":                           "Description.VirtualMachine.properties.osProfile.windowsConfiguration.timeZone",
	"title":                               "Description.VirtualMachine.name",
	"type":                                "Description.VirtualMachine.type",
	"ultra_ssd_enabled":                   "Description.VirtualMachine.properties.additionalCapabilities.ultraSSDEnabled",
	"vm_id":                               "Description.VirtualMachine.properties.vmId",
	"win_rm":                              "Description.VirtualMachine.Properties.OSProfile.WindowsConfiguration.WinRM",
	"zones":                               "Description.VirtualMachine.Zones",
}

func ListComputeVirtualMachine(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeVirtualMachine")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeVirtualMachine NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeVirtualMachine NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeVirtualMachine GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeVirtualMachine GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeVirtualMachine GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewComputeVirtualMachinePaginator(essdk.BuildFilter(ctx, d.QueryContext, listComputeVirtualMachineFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeVirtualMachine NewComputeVirtualMachinePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListComputeVirtualMachine paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getComputeVirtualMachineFilters = map[string]string{
	"additional_unattend_content":         "Description.VirtualMachine.Properties.OSProfile.WindowsConfiguration.AdditionalUnattendContent",
	"admin_user_name":                     "Description.VirtualMachine.properties.osProfile.adminUsername",
	"allow_extension_operations":          "Description.VirtualMachine.properties.osProfile.allowExtensionOperations",
	"availability_set_id":                 "Description.VirtualMachine.properties.availabilitySet.id",
	"billing_profile_max_price":           "Description.VirtualMachine.properties.billingProfile.maxPrice",
	"boot_diagnostics_enabled":            "Description.VirtualMachine.properties.diagnosticsProfile.bootDiagnostics.enabled",
	"boot_diagnostics_storage_uri":        "Description.VirtualMachine.properties.diagnosticsProfile.bootDiagnostics.storageUri",
	"computer_name":                       "Description.VirtualMachine.properties.osProfile.computerName",
	"data_disks":                          "Description.VirtualMachine.Properties.StorageProfile.DataDisks",
	"disable_password_authentication":     "Description.VirtualMachine.properties.osProfile.linuxConfiguration.disablePasswordAuthentication",
	"enable_automatic_updates":            "Description.VirtualMachine.properties.osProfile.windowsConfiguration.enableAutomaticUpdates",
	"eviction_policy":                     "Description.VirtualMachine.properties.evictionPolicy",
	"extensions":                          "Description.VirtualMachineExtension",
	"extensions_settings":                 "Description.ExtensionsSettings",
	"guest_configuration_assignments":     "Description.Assignments",
	"id":                                  "Description.VirtualMachine.id",
	"identity":                            "Description.VirtualMachine.Identity",
	"image_exact_version":                 "Description.VirtualMachine.properties.storageProfile.imageReference.exactVersion",
	"image_id":                            "Description.VirtualMachine.properties.storageProfile.imageReference.id",
	"image_offer":                         "Description.VirtualMachine.properties.storageProfile.imageReference.offer",
	"image_publisher":                     "Description.VirtualMachine.properties.storageProfile.imageReference.publisher",
	"image_sku":                           "Description.VirtualMachine.properties.storageProfile.imageReference.sku",
	"image_version":                       "Description.VirtualMachine.properties.storageProfile.imageReference.version",
	"linux_configuration_ssh_public_keys": "Description.VirtualMachine.Properties.OSProfile.LinuxConfiguration.SSH.PublicKeys",
	"managed_disk_id":                     "Description.VirtualMachine.properties.storageProfile.osDisk.managedDisk.id",
	"name":                                "description.VirtualMachine.name",
	"network_interfaces":                  "Description.VirtualMachine.Properties.NetworkProfile.NetworkInterfaces",
	"os_disk_caching":                     "Description.VirtualMachine.properties.storageProfile.osDisk.caching",
	"os_disk_create_option":               "Description.VirtualMachine.properties.storageProfile.osDisk.createOption",
	"os_disk_name":                        "Description.VirtualMachine.properties.storageProfile.osDisk.name",
	"os_disk_vhd_uri":                     "Description.VirtualMachine.properties.storageProfile.osDisk.vhd.uri",
	"os_name":                             "Description.VirtualMachineInstanceView.osName",
	"os_type":                             "Description.VirtualMachine.properties.storageProfile.osDisk.osType",
	"os_version":                          "Description.VirtualMachineInstanceView.osVersion",
	"patch_settings":                      "Description.VirtualMachine.Properties.OSProfile.WindowsConfiguration.PatchSettings",
	"platform_integration_id":             "IntegrationID",
	"priority":                            "Description.VirtualMachine.properties.priority",
	"provision_vm_agent":                  "Description.VirtualMachine.properties.osProfile.linuxConfiguration.provisionVMAgent",
	"provision_vm_agent_windows":          "Description.VirtualMachine.properties.osProfile.windowsConfiguration.provisionVMAgent",
	"provisioning_state":                  "Description.VirtualMachine.properties.provisioningState",
	"public_ips":                          "Description.PublicIPs",
	"require_guest_provision_signal":      "Description.VirtualMachine.properties.osProfile.requireGuestProvisionSignal",
	"resource_group":                      "description.ResourceGroup",
	"secrets":                             "Description.VirtualMachine.Properties.OSProfile.Secrets",
	"security_profile":                    "Description.VirtualMachine.Properties.SecurityProfile",
	"size":                                "Description.VirtualMachine.properties.hardwareProfile.vmSize",
	"statuses":                            "Description.VirtualMachineInstanceView.Statuses",
	"subscription":                        "Description.VirtualMachine.Properties.Subscription",
	"tags":                                "Description.VirtualMachine.Tags",
	"time_zone":                           "Description.VirtualMachine.properties.osProfile.windowsConfiguration.timeZone",
	"title":                               "Description.VirtualMachine.name",
	"type":                                "Description.VirtualMachine.type",
	"ultra_ssd_enabled":                   "Description.VirtualMachine.properties.additionalCapabilities.ultraSSDEnabled",
	"vm_id":                               "Description.VirtualMachine.properties.vmId",
	"win_rm":                              "Description.VirtualMachine.Properties.OSProfile.WindowsConfiguration.WinRM",
	"zones":                               "Description.VirtualMachine.Zones",
}

func GetComputeVirtualMachine(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeVirtualMachine")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewComputeVirtualMachinePaginator(essdk.BuildFilter(ctx, d.QueryContext, getComputeVirtualMachineFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ComputeVirtualMachine =============================

// ==========================  START: ComputeCloudService =============================

type ComputeCloudService struct {
	ResourceID      string                               `json:"resource_id"`
	PlatformID      string                               `json:"platform_id"`
	Description     azure.ComputeCloudServiceDescription `json:"Description"`
	Metadata        azure.Metadata                       `json:"metadata"`
	DescribedBy     string                               `json:"described_by"`
	ResourceType    string                               `json:"resource_type"`
	IntegrationType string                               `json:"integration_type"`
	IntegrationID   string                               `json:"integration_id"`
}

type ComputeCloudServiceHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  ComputeCloudService `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type ComputeCloudServiceHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []ComputeCloudServiceHit `json:"hits"`
}

type ComputeCloudServiceSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  ComputeCloudServiceHits `json:"hits"`
}

type ComputeCloudServicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeCloudServicePaginator(filters []essdk.BoolFilter, limit *int64) (ComputeCloudServicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_cloudservices", filters, limit)
	if err != nil {
		return ComputeCloudServicePaginator{}, err
	}

	p := ComputeCloudServicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeCloudServicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeCloudServicePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ComputeCloudServicePaginator) NextPage(ctx context.Context) ([]ComputeCloudService, error) {
	var response ComputeCloudServiceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeCloudService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeCloudServiceFilters = map[string]string{
	"id":                      "Description.CloudServices.ID",
	"name":                    "Description.CloudService.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.CloudServices.Properties.Subscription",
	"tags":                    "Description.CloudService.Tags",
	"title":                   "Description.CloudService.name",
}

func ListComputeCloudService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeCloudService")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeCloudService NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeCloudService NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeCloudService GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeCloudService GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeCloudService GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewComputeCloudServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, listComputeCloudServiceFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListComputeCloudService NewComputeCloudServicePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListComputeCloudService paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getComputeCloudServiceFilters = map[string]string{
	"id":                      "Description.CloudServices.ID",
	"name":                    "Description.CloudService.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.CloudServices.Properties.Subscription",
	"tags":                    "Description.CloudService.Tags",
	"title":                   "Description.CloudService.name",
}

func GetComputeCloudService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeCloudService")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewComputeCloudServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, getComputeCloudServiceFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ComputeCloudService =============================

// ==========================  START: ContainerRegistry =============================

type ContainerRegistry struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     azure.ContainerRegistryDescription `json:"Description"`
	Metadata        azure.Metadata                     `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type ContainerRegistryHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  ContainerRegistry `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type ContainerRegistryHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []ContainerRegistryHit `json:"hits"`
}

type ContainerRegistrySearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  ContainerRegistryHits `json:"hits"`
}

type ContainerRegistryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewContainerRegistryPaginator(filters []essdk.BoolFilter, limit *int64) (ContainerRegistryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_containerregistry_registries", filters, limit)
	if err != nil {
		return ContainerRegistryPaginator{}, err
	}

	p := ContainerRegistryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ContainerRegistryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ContainerRegistryPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ContainerRegistryPaginator) NextPage(ctx context.Context) ([]ContainerRegistry, error) {
	var response ContainerRegistrySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ContainerRegistry
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listContainerRegistryFilters = map[string]string{
	"admin_user_enabled":           "Description.Registry.properties.adminUserEnabled",
	"data_endpoint_enabled":        "Description.Registry.properties.dataEndpointEnabled",
	"data_endpoint_host_names":     "Description.Registry.Properties.DataEndpointHostNames",
	"encryption":                   "Description.Registry.Properties.Encryption",
	"id":                           "Description.Registry.id",
	"identity":                     "Description.Registry.Identity",
	"login_credentials":            "Description.RegistryListCredentialsResult",
	"login_server":                 "Description.Registry.properties.loginServer",
	"name":                         "Description.Registry.name",
	"network_rule_bypass_options":  "Description.Registry.properties.networkRuleBypassOptions",
	"network_rule_set":             "Description.Registry.Properties.NetworkRuleSet",
	"platform_integration_id":      "IntegrationID",
	"policies":                     "Description.Registry.Properties.Policies",
	"private_endpoint_connections": "Description.Registry.Properties.PrivateEndpointConnections",
	"provisioning_state":           "Description.Registry.properties.provisioningState",
	"public_network_access":        "Description.Registry.properties.publicNetworkAccess",
	"resource_group":               "Description.ResourceGroup",
	"sku_name":                     "Description.Registry.sku.name",
	"sku_tier":                     "Description.Registry.sku.tier",
	"status":                       "Description.Registry.properties.status.displayStatus",
	"status_message":               "Description.Registry.properties.status.message",
	"storage_account_id":           "RegistryProperties.StorageAccount.ID",
	"subscription":                 "Description.Registry.Properties.Subscription",
	"system_data":                  "Description.Registry.SystemData",
	"tags":                         "Description.Registry.Tags",
	"title":                        "Description.Registry.name",
	"type":                         "Description.Registry.type",
	"usages":                       "Description.RegistryUsages",
	"webhooks":                     "Description.Webhooks",
	"zone_redundancy":              "Description.Registry.properties.zoneRedundancy",
}

func ListContainerRegistry(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListContainerRegistry")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListContainerRegistry NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListContainerRegistry NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListContainerRegistry GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListContainerRegistry GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListContainerRegistry GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewContainerRegistryPaginator(essdk.BuildFilter(ctx, d.QueryContext, listContainerRegistryFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListContainerRegistry NewContainerRegistryPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListContainerRegistry paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getContainerRegistryFilters = map[string]string{
	"admin_user_enabled":           "Description.Registry.properties.adminUserEnabled",
	"data_endpoint_enabled":        "Description.Registry.properties.dataEndpointEnabled",
	"data_endpoint_host_names":     "Description.Registry.Properties.DataEndpointHostNames",
	"encryption":                   "Description.Registry.Properties.Encryption",
	"id":                           "Description.Registry.id",
	"identity":                     "Description.Registry.Identity",
	"login_credentials":            "Description.RegistryListCredentialsResult",
	"login_server":                 "Description.Registry.properties.loginServer",
	"name":                         "description.Registry.name",
	"network_rule_bypass_options":  "Description.Registry.properties.networkRuleBypassOptions",
	"network_rule_set":             "Description.Registry.Properties.NetworkRuleSet",
	"platform_integration_id":      "IntegrationID",
	"policies":                     "Description.Registry.Properties.Policies",
	"private_endpoint_connections": "Description.Registry.Properties.PrivateEndpointConnections",
	"provisioning_state":           "Description.Registry.properties.provisioningState",
	"public_network_access":        "Description.Registry.properties.publicNetworkAccess",
	"resource_group":               "description.ResourceGroup",
	"sku_name":                     "Description.Registry.sku.name",
	"sku_tier":                     "Description.Registry.sku.tier",
	"status":                       "Description.Registry.properties.status.displayStatus",
	"status_message":               "Description.Registry.properties.status.message",
	"storage_account_id":           "RegistryProperties.StorageAccount.ID",
	"subscription":                 "Description.Registry.Properties.Subscription",
	"system_data":                  "Description.Registry.SystemData",
	"tags":                         "Description.Registry.Tags",
	"title":                        "Description.Registry.name",
	"type":                         "Description.Registry.type",
	"usages":                       "Description.RegistryUsages",
	"webhooks":                     "Description.Webhooks",
	"zone_redundancy":              "Description.Registry.properties.zoneRedundancy",
}

func GetContainerRegistry(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetContainerRegistry")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewContainerRegistryPaginator(essdk.BuildFilter(ctx, d.QueryContext, getContainerRegistryFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ContainerRegistry =============================

// ==========================  START: CosmosdbAccount =============================

type CosmosdbAccount struct {
	ResourceID      string                           `json:"resource_id"`
	PlatformID      string                           `json:"platform_id"`
	Description     azure.CosmosdbAccountDescription `json:"Description"`
	Metadata        azure.Metadata                   `json:"metadata"`
	DescribedBy     string                           `json:"described_by"`
	ResourceType    string                           `json:"resource_type"`
	IntegrationType string                           `json:"integration_type"`
	IntegrationID   string                           `json:"integration_id"`
}

type CosmosdbAccountHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  CosmosdbAccount `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type CosmosdbAccountHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []CosmosdbAccountHit `json:"hits"`
}

type CosmosdbAccountSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  CosmosdbAccountHits `json:"hits"`
}

type CosmosdbAccountPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCosmosdbAccountPaginator(filters []essdk.BoolFilter, limit *int64) (CosmosdbAccountPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_documentdb_databaseaccounts", filters, limit)
	if err != nil {
		return CosmosdbAccountPaginator{}, err
	}

	p := CosmosdbAccountPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CosmosdbAccountPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CosmosdbAccountPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CosmosdbAccountPaginator) NextPage(ctx context.Context) ([]CosmosdbAccount, error) {
	var response CosmosdbAccountSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CosmosdbAccount
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCosmosdbAccountFilters = map[string]string{
	"backup_policy":                           "Description.DatabaseAccountGetResults.Properties.BackupPolicy",
	"capabilities":                            "Description.DatabaseAccountGetResults.Properties.Capabilities",
	"connector_offer":                         "Description.DatabaseAccountGetResults.properties.connectorOffer",
	"consistency_policy_max_interval":         "Description.DatabaseAccountGetResults.properties.consistencyPolicy.maxIntervalInSeconds",
	"consistency_policy_max_staleness_prefix": "Description.DatabaseAccountGetResults.properties.consistencyPolicy.maxStalenessPrefix",
	"cors":                                    "Description.DatabaseAccountGetResults.Properties.Cors",
	"database_account_offer_type":             "Description.DatabaseAccountGetResults.Properties.DatabaseAccountOfferType",
	"default_consistency_level":               "Description.DatabaseAccountGetResults.properties.consistencyPolicy.defaultConsistencyLevel",
	"disable_key_based_metadata_write_access": "Description.DatabaseAccountGetResults.properties.disableKeyBasedMetadataWriteAccess",
	"disable_local_auth":                      "Description.DatabaseAccountGetResults.properties.disableLocalAuth",
	"document_endpoint":                       "Description.DatabaseAccountGetResults.properties.documentEndpoint",
	"enable_analytical_storage":               "Description.DatabaseAccountGetResults.properties.enableAnalyticalStorage",
	"enable_automatic_failover":               "Description.DatabaseAccountGetResults.properties.enableAutomaticFailover",
	"enable_cassandra_connector":              "Description.DatabaseAccountGetResults.properties.enableCassandraConnector",
	"enable_free_tier":                        "Description.DatabaseAccountGetResults.properties.enableFreeTier",
	"enable_multiple_write_locations":         "Description.DatabaseAccountGetResults.properties.enableMultipleWriteLocations",
	"failover_policies":                       "Description.DatabaseAccountGetResults.Properties.FailoverPolicies",
	"id":                                      "Description.DatabaseAccountGetResults.id",
	"ip_rules":                                "Description.DatabaseAccountGetResults.Properties.IPRules",
	"is_virtual_network_filter_enabled":       "Description.DatabaseAccountGetResults.properties.isVirtualNetworkFilterEnabled",
	"key_vault_key_uri":                       "Description.DatabaseAccountGetResults.properties.keyVaultKeyUri",
	"kind":                                    "Description.DatabaseAccountGetResults.kind",
	"locations":                               "Description.DatabaseAccountGetResults.Properties.Locations",
	"name":                                    "Description.DatabaseAccountGetResults.name",
	"platform_integration_id":                 "IntegrationID",
	"private_endpoint_connections":            "Description.DatabaseAccountGetResults.Properties.PrivateEndpointConnections",
	"provisioning_state":                      "Description.DatabaseAccountGetResults.properties.provisioningState",
	"public_network_access":                   "Description.DatabaseAccountGetResults.properties.publicNetworkAccess",
	"read_locations":                          "Description.DatabaseAccountGetResults.Properties.ReadLocations",
	"restore_parameters":                      "Description.DatabaseAccountGetResults.Properties.RestoreParameters",
	"server_version":                          "Description.DatabaseAccountGetResults.properties.apiProperties.serverVersion",
	"subscription":                            "Description.DatabaseAccountGetResults.Properties.Subscription",
	"tags":                                    "Description.DatabaseAccountGetResults.Tags",
	"title":                                   "Description.DatabaseAccountGetResults.name",
	"type":                                    "Description.DatabaseAccountGetResults.type",
	"virtual_network_rules":                   "Description.DatabaseAccountGetResults.Properties.VirtualNetworkRules",
	"write_locations":                         "Description.DatabaseAccountGetResults.Properties.WriteLocations",
}

func ListCosmosdbAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCosmosdbAccount")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbAccount NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbAccount NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCosmosdbAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCosmosdbAccountFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbAccount NewCosmosdbAccountPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCosmosdbAccount paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCosmosdbAccountFilters = map[string]string{
	"backup_policy":                           "Description.DatabaseAccountGetResults.Properties.BackupPolicy",
	"capabilities":                            "Description.DatabaseAccountGetResults.Properties.Capabilities",
	"connector_offer":                         "Description.DatabaseAccountGetResults.properties.connectorOffer",
	"consistency_policy_max_interval":         "Description.DatabaseAccountGetResults.properties.consistencyPolicy.maxIntervalInSeconds",
	"consistency_policy_max_staleness_prefix": "Description.DatabaseAccountGetResults.properties.consistencyPolicy.maxStalenessPrefix",
	"cors":                                    "Description.DatabaseAccountGetResults.Properties.Cors",
	"database_account_offer_type":             "Description.DatabaseAccountGetResults.Properties.DatabaseAccountOfferType",
	"default_consistency_level":               "Description.DatabaseAccountGetResults.properties.consistencyPolicy.defaultConsistencyLevel",
	"disable_key_based_metadata_write_access": "Description.DatabaseAccountGetResults.properties.disableKeyBasedMetadataWriteAccess",
	"disable_local_auth":                      "Description.DatabaseAccountGetResults.properties.disableLocalAuth",
	"document_endpoint":                       "Description.DatabaseAccountGetResults.properties.documentEndpoint",
	"enable_analytical_storage":               "Description.DatabaseAccountGetResults.properties.enableAnalyticalStorage",
	"enable_automatic_failover":               "Description.DatabaseAccountGetResults.properties.enableAutomaticFailover",
	"enable_cassandra_connector":              "Description.DatabaseAccountGetResults.properties.enableCassandraConnector",
	"enable_free_tier":                        "Description.DatabaseAccountGetResults.properties.enableFreeTier",
	"enable_multiple_write_locations":         "Description.DatabaseAccountGetResults.properties.enableMultipleWriteLocations",
	"failover_policies":                       "Description.DatabaseAccountGetResults.Properties.FailoverPolicies",
	"id":                                      "Description.DatabaseAccountGetResults.id",
	"ip_rules":                                "Description.DatabaseAccountGetResults.Properties.IPRules",
	"is_virtual_network_filter_enabled":       "Description.DatabaseAccountGetResults.properties.isVirtualNetworkFilterEnabled",
	"key_vault_key_uri":                       "Description.DatabaseAccountGetResults.properties.keyVaultKeyUri",
	"kind":                                    "Description.DatabaseAccountGetResults.kind",
	"locations":                               "Description.DatabaseAccountGetResults.Properties.Locations",
	"name":                                    "description.DatabaseAccountGetResults.name",
	"platform_integration_id":                 "IntegrationID",
	"private_endpoint_connections":            "Description.DatabaseAccountGetResults.Properties.PrivateEndpointConnections",
	"provisioning_state":                      "Description.DatabaseAccountGetResults.properties.provisioningState",
	"public_network_access":                   "Description.DatabaseAccountGetResults.properties.publicNetworkAccess",
	"read_locations":                          "Description.DatabaseAccountGetResults.Properties.ReadLocations",
	"resource_group":                          "description.ResourceGroup",
	"restore_parameters":                      "Description.DatabaseAccountGetResults.Properties.RestoreParameters",
	"server_version":                          "Description.DatabaseAccountGetResults.properties.apiProperties.serverVersion",
	"subscription":                            "Description.DatabaseAccountGetResults.Properties.Subscription",
	"tags":                                    "Description.DatabaseAccountGetResults.Tags",
	"title":                                   "Description.DatabaseAccountGetResults.name",
	"type":                                    "Description.DatabaseAccountGetResults.type",
	"virtual_network_rules":                   "Description.DatabaseAccountGetResults.Properties.VirtualNetworkRules",
	"write_locations":                         "Description.DatabaseAccountGetResults.Properties.WriteLocations",
}

func GetCosmosdbAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCosmosdbAccount")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCosmosdbAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCosmosdbAccountFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CosmosdbAccount =============================

// ==========================  START: CosmosdbRestorableDatabaseAccount =============================

type CosmosdbRestorableDatabaseAccount struct {
	ResourceID      string                                             `json:"resource_id"`
	PlatformID      string                                             `json:"platform_id"`
	Description     azure.CosmosdbRestorableDatabaseAccountDescription `json:"Description"`
	Metadata        azure.Metadata                                     `json:"metadata"`
	DescribedBy     string                                             `json:"described_by"`
	ResourceType    string                                             `json:"resource_type"`
	IntegrationType string                                             `json:"integration_type"`
	IntegrationID   string                                             `json:"integration_id"`
}

type CosmosdbRestorableDatabaseAccountHit struct {
	ID      string                            `json:"_id"`
	Score   float64                           `json:"_score"`
	Index   string                            `json:"_index"`
	Type    string                            `json:"_type"`
	Version int64                             `json:"_version,omitempty"`
	Source  CosmosdbRestorableDatabaseAccount `json:"_source"`
	Sort    []interface{}                     `json:"sort"`
}

type CosmosdbRestorableDatabaseAccountHits struct {
	Total essdk.SearchTotal                      `json:"total"`
	Hits  []CosmosdbRestorableDatabaseAccountHit `json:"hits"`
}

type CosmosdbRestorableDatabaseAccountSearchResponse struct {
	PitID string                                `json:"pit_id"`
	Hits  CosmosdbRestorableDatabaseAccountHits `json:"hits"`
}

type CosmosdbRestorableDatabaseAccountPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCosmosdbRestorableDatabaseAccountPaginator(filters []essdk.BoolFilter, limit *int64) (CosmosdbRestorableDatabaseAccountPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_documentdb_restorabledatabaseaccounts", filters, limit)
	if err != nil {
		return CosmosdbRestorableDatabaseAccountPaginator{}, err
	}

	p := CosmosdbRestorableDatabaseAccountPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CosmosdbRestorableDatabaseAccountPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CosmosdbRestorableDatabaseAccountPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CosmosdbRestorableDatabaseAccountPaginator) NextPage(ctx context.Context) ([]CosmosdbRestorableDatabaseAccount, error) {
	var response CosmosdbRestorableDatabaseAccountSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CosmosdbRestorableDatabaseAccount
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCosmosdbRestorableDatabaseAccountFilters = map[string]string{
	"account_name":            "Description.Account.properties.accountName",
	"api_type":                "Description.Account.properties.apiType",
	"creation_time":           "Description.Account.Properties.CreationTime",
	"deletion_time":           "Description.Account.Properties.DeletionTime",
	"id":                      "Description.Account.id",
	"name":                    "Description.Account.name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "Description.ResourceGroup",
	"restorable_locations":    "Description.Account.Properties.RestorableLocations",
	"subscription":            "Description.Account.Properties.Subscription",
	"title":                   "Description.Account.name",
	"type":                    "Description.Account.type",
}

func ListCosmosdbRestorableDatabaseAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCosmosdbRestorableDatabaseAccount")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbRestorableDatabaseAccount NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbRestorableDatabaseAccount NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbRestorableDatabaseAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbRestorableDatabaseAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbRestorableDatabaseAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCosmosdbRestorableDatabaseAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCosmosdbRestorableDatabaseAccountFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbRestorableDatabaseAccount NewCosmosdbRestorableDatabaseAccountPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCosmosdbRestorableDatabaseAccount paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCosmosdbRestorableDatabaseAccountFilters = map[string]string{
	"account_name":            "Description.Account.properties.accountName",
	"api_type":                "Description.Account.properties.apiType",
	"creation_time":           "Description.Account.Properties.CreationTime",
	"deletion_time":           "Description.Account.Properties.DeletionTime",
	"id":                      "Description.Account.id",
	"name":                    "description.Account.Name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "description.ResourceGroup",
	"restorable_locations":    "Description.Account.Properties.RestorableLocations",
	"subscription":            "Description.Account.Properties.Subscription",
	"title":                   "Description.Account.name",
	"type":                    "Description.Account.type",
}

func GetCosmosdbRestorableDatabaseAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCosmosdbRestorableDatabaseAccount")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCosmosdbRestorableDatabaseAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCosmosdbRestorableDatabaseAccountFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CosmosdbRestorableDatabaseAccount =============================

// ==========================  START: CosmosdbMongoDatabase =============================

type CosmosdbMongoDatabase struct {
	ResourceID      string                                 `json:"resource_id"`
	PlatformID      string                                 `json:"platform_id"`
	Description     azure.CosmosdbMongoDatabaseDescription `json:"Description"`
	Metadata        azure.Metadata                         `json:"metadata"`
	DescribedBy     string                                 `json:"described_by"`
	ResourceType    string                                 `json:"resource_type"`
	IntegrationType string                                 `json:"integration_type"`
	IntegrationID   string                                 `json:"integration_id"`
}

type CosmosdbMongoDatabaseHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  CosmosdbMongoDatabase `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type CosmosdbMongoDatabaseHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []CosmosdbMongoDatabaseHit `json:"hits"`
}

type CosmosdbMongoDatabaseSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  CosmosdbMongoDatabaseHits `json:"hits"`
}

type CosmosdbMongoDatabasePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCosmosdbMongoDatabasePaginator(filters []essdk.BoolFilter, limit *int64) (CosmosdbMongoDatabasePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_documentdb_databaseaccounts_mongodbdatabases", filters, limit)
	if err != nil {
		return CosmosdbMongoDatabasePaginator{}, err
	}

	p := CosmosdbMongoDatabasePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CosmosdbMongoDatabasePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CosmosdbMongoDatabasePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CosmosdbMongoDatabasePaginator) NextPage(ctx context.Context) ([]CosmosdbMongoDatabase, error) {
	var response CosmosdbMongoDatabaseSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CosmosdbMongoDatabase
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCosmosdbMongoDatabaseFilters = map[string]string{
	"account_name":                      "Description.Account.name",
	"autoscale_settings_max_throughput": "Description.MongoDatabase.properties.options.autoscaleSettings.maxThroughput",
	"database_etag":                     "Description.MongoDatabase.properties.resource._etag",
	"database_id":                       "Description.MongoDatabase.properties.resource.id",
	"database_rid":                      "Description.MongoDatabase.properties.resource._rid",
	"id":                                "Description.MongoDatabase.id",
	"name":                              "Description.MongoDatabase.name",
	"platform_integration_id":           "IntegrationID",
	"subscription":                      "Description.MongoDatabase.Properties.Subscription",
	"tags":                              "Description.MongoDatabase.Tags",
	"throughput":                        "Description.MongoDatabase.properties.options.throughput",
	"throughput_settings":               "Description.MongoDatabase.properties.options.throughput",
	"title":                             "Description.MongoDatabase.name",
	"type":                              "Description.MongoDatabase.type",
}

func ListCosmosdbMongoDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCosmosdbMongoDatabase")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbMongoDatabase NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbMongoDatabase NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbMongoDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbMongoDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbMongoDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCosmosdbMongoDatabasePaginator(essdk.BuildFilter(ctx, d.QueryContext, listCosmosdbMongoDatabaseFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbMongoDatabase NewCosmosdbMongoDatabasePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCosmosdbMongoDatabase paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCosmosdbMongoDatabaseFilters = map[string]string{
	"account_name":                      "description.Account.name",
	"autoscale_settings_max_throughput": "Description.MongoDatabase.properties.options.autoscaleSettings.maxThroughput",
	"database_etag":                     "Description.MongoDatabase.properties.resource._etag",
	"database_id":                       "Description.MongoDatabase.properties.resource.id",
	"database_rid":                      "Description.MongoDatabase.properties.resource._rid",
	"id":                                "Description.MongoDatabase.id",
	"name":                              "description.MongoDatabase.name",
	"platform_integration_id":           "IntegrationID",
	"resource_group":                    "description.ResourceGroup",
	"subscription":                      "Description.MongoDatabase.Properties.Subscription",
	"tags":                              "Description.MongoDatabase.Tags",
	"throughput":                        "Description.MongoDatabase.properties.options.throughput",
	"throughput_settings":               "Description.MongoDatabase.properties.options.throughput",
	"title":                             "Description.MongoDatabase.name",
	"type":                              "Description.MongoDatabase.type",
}

func GetCosmosdbMongoDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCosmosdbMongoDatabase")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCosmosdbMongoDatabasePaginator(essdk.BuildFilter(ctx, d.QueryContext, getCosmosdbMongoDatabaseFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CosmosdbMongoDatabase =============================

// ==========================  START: CosmosdbMongoCollection =============================

type CosmosdbMongoCollection struct {
	ResourceID      string                                   `json:"resource_id"`
	PlatformID      string                                   `json:"platform_id"`
	Description     azure.CosmosdbMongoCollectionDescription `json:"Description"`
	Metadata        azure.Metadata                           `json:"metadata"`
	DescribedBy     string                                   `json:"described_by"`
	ResourceType    string                                   `json:"resource_type"`
	IntegrationType string                                   `json:"integration_type"`
	IntegrationID   string                                   `json:"integration_id"`
}

type CosmosdbMongoCollectionHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  CosmosdbMongoCollection `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type CosmosdbMongoCollectionHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []CosmosdbMongoCollectionHit `json:"hits"`
}

type CosmosdbMongoCollectionSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  CosmosdbMongoCollectionHits `json:"hits"`
}

type CosmosdbMongoCollectionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCosmosdbMongoCollectionPaginator(filters []essdk.BoolFilter, limit *int64) (CosmosdbMongoCollectionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_documentdb_databaseaccounts_mongodbdatabases_collections", filters, limit)
	if err != nil {
		return CosmosdbMongoCollectionPaginator{}, err
	}

	p := CosmosdbMongoCollectionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CosmosdbMongoCollectionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CosmosdbMongoCollectionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CosmosdbMongoCollectionPaginator) NextPage(ctx context.Context) ([]CosmosdbMongoCollection, error) {
	var response CosmosdbMongoCollectionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CosmosdbMongoCollection
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCosmosdbMongoCollectionFilters = map[string]string{
	"account_name":                      "Description.Account.name",
	"analytical_storage_ttl":            "Description.MongoCollection.properties.resource.analyticalStorageTtl",
	"autoscale_settings_max_throughput": "Description.MongoCollection.Properties.AutoscaleSettings.MaxThroughput",
	"collection_etag":                   "Description.MongoCollection.properties.resource._etag",
	"collection_id":                     "Description.MongoCollection.properties.resource.id",
	"collection_rid":                    "Description.MongoCollection.properties.resource._rid",
	"database_name":                     "Description.MongoDatabase.name",
	"id":                                "Description.MongoCollection.id",
	"indexes":                           "Description.MongoCollection.Properties.Resource.Indexes",
	"name":                              "Description.MongoCollection.name",
	"platform_integration_id":           "IntegrationID",
	"resource_group":                    "Description.ResourceGroup",
	"shard_key":                         "Description.MongoCollection.Properties.Resource.ShardKey",
	"subscription":                      "Description.MongoCollection.Properties.Subscription",
	"tags":                              "Description.MongoCollection.Tags",
	"throughput":                        "Description.MongoCollection.properties.options.throughput",
	"throughput_settings":               "Description.Throughput",
	"title":                             "Description.MongoCollection.name",
	"type":                              "Description.MongoCollection.type",
}

func ListCosmosdbMongoCollection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCosmosdbMongoCollection")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbMongoCollection NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbMongoCollection NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbMongoCollection GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbMongoCollection GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbMongoCollection GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCosmosdbMongoCollectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCosmosdbMongoCollectionFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbMongoCollection NewCosmosdbMongoCollectionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCosmosdbMongoCollection paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCosmosdbMongoCollectionFilters = map[string]string{
	"account_name":                      "description.Account.name",
	"analytical_storage_ttl":            "Description.MongoCollection.properties.resource.analyticalStorageTtl",
	"autoscale_settings_max_throughput": "Description.MongoCollection.Properties.AutoscaleSettings.MaxThroughput",
	"collection_etag":                   "Description.MongoCollection.properties.resource._etag",
	"collection_id":                     "Description.MongoCollection.properties.resource.id",
	"collection_rid":                    "Description.MongoCollection.properties.resource._rid",
	"database_name":                     "Description.MongoDatabase.name",
	"id":                                "Description.MongoCollection.id",
	"indexes":                           "Description.MongoCollection.Properties.Resource.Indexes",
	"name":                              "description.MongoCollection.name",
	"platform_integration_id":           "IntegrationID",
	"resource_group":                    "description.ResourceGroup",
	"shard_key":                         "Description.MongoCollection.Properties.Resource.ShardKey",
	"subscription":                      "Description.MongoCollection.Properties.Subscription",
	"tags":                              "Description.MongoCollection.Tags",
	"throughput":                        "Description.MongoCollection.properties.options.throughput",
	"throughput_settings":               "Description.Throughput",
	"title":                             "Description.MongoCollection.name",
	"type":                              "Description.MongoCollection.type",
}

func GetCosmosdbMongoCollection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCosmosdbMongoCollection")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCosmosdbMongoCollectionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCosmosdbMongoCollectionFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CosmosdbMongoCollection =============================

// ==========================  START: CosmosdbSqlDatabase =============================

type CosmosdbSqlDatabase struct {
	ResourceID      string                               `json:"resource_id"`
	PlatformID      string                               `json:"platform_id"`
	Description     azure.CosmosdbSqlDatabaseDescription `json:"Description"`
	Metadata        azure.Metadata                       `json:"metadata"`
	DescribedBy     string                               `json:"described_by"`
	ResourceType    string                               `json:"resource_type"`
	IntegrationType string                               `json:"integration_type"`
	IntegrationID   string                               `json:"integration_id"`
}

type CosmosdbSqlDatabaseHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  CosmosdbSqlDatabase `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type CosmosdbSqlDatabaseHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []CosmosdbSqlDatabaseHit `json:"hits"`
}

type CosmosdbSqlDatabaseSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  CosmosdbSqlDatabaseHits `json:"hits"`
}

type CosmosdbSqlDatabasePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCosmosdbSqlDatabasePaginator(filters []essdk.BoolFilter, limit *int64) (CosmosdbSqlDatabasePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_documentdb_databaseaccounts_sqldatabases", filters, limit)
	if err != nil {
		return CosmosdbSqlDatabasePaginator{}, err
	}

	p := CosmosdbSqlDatabasePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CosmosdbSqlDatabasePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CosmosdbSqlDatabasePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CosmosdbSqlDatabasePaginator) NextPage(ctx context.Context) ([]CosmosdbSqlDatabase, error) {
	var response CosmosdbSqlDatabaseSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CosmosdbSqlDatabase
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCosmosdbSqlDatabaseFilters = map[string]string{
	"account_name":                      "Description.Account.name",
	"autoscale_settings_max_throughput": "Description.SqlDatabase.properties.options.autoscaleSettings.maxThroughput",
	"database_colls":                    "Description.SqlDatabase.properties.resource._colls",
	"database_etag":                     "Description.SqlDatabase.properties.resource._etag",
	"database_id":                       "Description.SqlDatabase.properties.resource.id",
	"database_rid":                      "Description.SqlDatabase.properties.resource._rid",
	"database_users":                    "Description.SqlDatabase.properties.resource._users",
	"id":                                "Description.SqlDatabase.id",
	"name":                              "Description.SqlDatabase.name",
	"platform_integration_id":           "IntegrationID",
	"subscription":                      "Description.SqlDatabase.Properties.Subscription",
	"tags":                              "Description.SqlDatabase.Tags",
	"throughput":                        "Description.SqlDatabase.properties.options.throughput",
	"title":                             "Description.SqlDatabase.name",
	"type":                              "Description.SqlDatabase.type",
}

func ListCosmosdbSqlDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCosmosdbSqlDatabase")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbSqlDatabase NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbSqlDatabase NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbSqlDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbSqlDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbSqlDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCosmosdbSqlDatabasePaginator(essdk.BuildFilter(ctx, d.QueryContext, listCosmosdbSqlDatabaseFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbSqlDatabase NewCosmosdbSqlDatabasePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCosmosdbSqlDatabase paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCosmosdbSqlDatabaseFilters = map[string]string{
	"account_name":                      "description.Account.name",
	"autoscale_settings_max_throughput": "Description.SqlDatabase.properties.options.autoscaleSettings.maxThroughput",
	"database_colls":                    "Description.SqlDatabase.properties.resource._colls",
	"database_etag":                     "Description.SqlDatabase.properties.resource._etag",
	"database_id":                       "Description.SqlDatabase.properties.resource.id",
	"database_rid":                      "Description.SqlDatabase.properties.resource._rid",
	"database_users":                    "Description.SqlDatabase.properties.resource._users",
	"id":                                "Description.SqlDatabase.id",
	"name":                              "description.SqlDatabase.name",
	"platform_integration_id":           "IntegrationID",
	"resource_group":                    "description.ResourceGroup",
	"subscription":                      "Description.SqlDatabase.Properties.Subscription",
	"tags":                              "Description.SqlDatabase.Tags",
	"throughput":                        "Description.SqlDatabase.properties.options.throughput",
	"title":                             "Description.SqlDatabase.name",
	"type":                              "Description.SqlDatabase.type",
}

func GetCosmosdbSqlDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCosmosdbSqlDatabase")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCosmosdbSqlDatabasePaginator(essdk.BuildFilter(ctx, d.QueryContext, getCosmosdbSqlDatabaseFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CosmosdbSqlDatabase =============================

// ==========================  START: CosmosdbCassandraCluster =============================

type CosmosdbCassandraCluster struct {
	ResourceID      string                                    `json:"resource_id"`
	PlatformID      string                                    `json:"platform_id"`
	Description     azure.CosmosdbCassandraClusterDescription `json:"Description"`
	Metadata        azure.Metadata                            `json:"metadata"`
	DescribedBy     string                                    `json:"described_by"`
	ResourceType    string                                    `json:"resource_type"`
	IntegrationType string                                    `json:"integration_type"`
	IntegrationID   string                                    `json:"integration_id"`
}

type CosmosdbCassandraClusterHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  CosmosdbCassandraCluster `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type CosmosdbCassandraClusterHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []CosmosdbCassandraClusterHit `json:"hits"`
}

type CosmosdbCassandraClusterSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  CosmosdbCassandraClusterHits `json:"hits"`
}

type CosmosdbCassandraClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCosmosdbCassandraClusterPaginator(filters []essdk.BoolFilter, limit *int64) (CosmosdbCassandraClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_documentdb_cassandraclusters", filters, limit)
	if err != nil {
		return CosmosdbCassandraClusterPaginator{}, err
	}

	p := CosmosdbCassandraClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CosmosdbCassandraClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CosmosdbCassandraClusterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CosmosdbCassandraClusterPaginator) NextPage(ctx context.Context) ([]CosmosdbCassandraCluster, error) {
	var response CosmosdbCassandraClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CosmosdbCassandraCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCosmosdbCassandraClusterFilters = map[string]string{
	"id":           "Description.CassandraCluster.id",
	"name":         "Description.CassandraCluster.name",
	"subscription": "Description.CassandraCluster.Properties.Subscription",
	"tags":         "Description.CassandraCluster.Tags",
	"title":        "Description.CassandraCluster.name",
}

func ListCosmosdbCassandraCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCosmosdbCassandraCluster")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbCassandraCluster NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbCassandraCluster NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbCassandraCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbCassandraCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbCassandraCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCosmosdbCassandraClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCosmosdbCassandraClusterFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCosmosdbCassandraCluster NewCosmosdbCassandraClusterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCosmosdbCassandraCluster paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCosmosdbCassandraClusterFilters = map[string]string{
	"id":           "Description.CassandraCluster.id",
	"name":         "Description.CassandraCluster.name",
	"subscription": "Description.CassandraCluster.Properties.Subscription",
	"tags":         "Description.CassandraCluster.Tags",
	"title":        "Description.CassandraCluster.name",
}

func GetCosmosdbCassandraCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCosmosdbCassandraCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCosmosdbCassandraClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCosmosdbCassandraClusterFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CosmosdbCassandraCluster =============================

// ==========================  START: DatabricksWorkspace =============================

type DatabricksWorkspace struct {
	ResourceID      string                               `json:"resource_id"`
	PlatformID      string                               `json:"platform_id"`
	Description     azure.DatabricksWorkspaceDescription `json:"Description"`
	Metadata        azure.Metadata                       `json:"metadata"`
	DescribedBy     string                               `json:"described_by"`
	ResourceType    string                               `json:"resource_type"`
	IntegrationType string                               `json:"integration_type"`
	IntegrationID   string                               `json:"integration_id"`
}

type DatabricksWorkspaceHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  DatabricksWorkspace `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type DatabricksWorkspaceHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []DatabricksWorkspaceHit `json:"hits"`
}

type DatabricksWorkspaceSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  DatabricksWorkspaceHits `json:"hits"`
}

type DatabricksWorkspacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDatabricksWorkspacePaginator(filters []essdk.BoolFilter, limit *int64) (DatabricksWorkspacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_databricks_workspaces", filters, limit)
	if err != nil {
		return DatabricksWorkspacePaginator{}, err
	}

	p := DatabricksWorkspacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DatabricksWorkspacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DatabricksWorkspacePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DatabricksWorkspacePaginator) NextPage(ctx context.Context) ([]DatabricksWorkspace, error) {
	var response DatabricksWorkspaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DatabricksWorkspace
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDatabricksWorkspaceFilters = map[string]string{
	"authorizations":            "Description.Workspace.Properties.Authorizations",
	"created_by":                "Description.Workspace.Properties.CreatedBy",
	"id":                        "Description.Workspace.id",
	"location":                  "Description.Workspace.location",
	"managed_resource_group_id": "Description.Workspace.properties.managedResourceGroupId",
	"name":                      "Description.Workspace.name",
	"parameters":                "Description.Workspace.Properties.Parameters",
	"platform_integration_id":   "IntegrationID",
	"provisioning_state":        "Description.Workspace.properties.provisioningState",
	"resource_group":            "Description.ResourceGroup",
	"sku":                       "Description.Workspace.SKU",
	"storage_account_identity":  "Description.Workspace.Properties.StorageAccountIdentity",
	"subscription":              "Description.Workspace.Properties.Subscription",
	"tags":                      "Description.Workspace.Tags",
	"title":                     "Description.Workspace.name",
	"type":                      "Description.Workspace.type",
	"ui_definition_uri":         "Description.Workspace.properties.uiDefinitionUri",
	"updated_by":                "Description.Workspace.Properties.UpdatedBy",
	"workspace_id":              "Description.Workspace.properties.workspaceId",
	"workspace_url":             "Description.Workspace.properties.workspaceUrl",
}

func ListDatabricksWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDatabricksWorkspace")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDatabricksWorkspace NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDatabricksWorkspace NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDatabricksWorkspace GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDatabricksWorkspace GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDatabricksWorkspace GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDatabricksWorkspacePaginator(essdk.BuildFilter(ctx, d.QueryContext, listDatabricksWorkspaceFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDatabricksWorkspace NewDatabricksWorkspacePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDatabricksWorkspace paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDatabricksWorkspaceFilters = map[string]string{
	"authorizations":            "Description.Workspace.Properties.Authorizations",
	"created_by":                "Description.Workspace.Properties.CreatedBy",
	"id":                        "Description.Workspace.id",
	"location":                  "Description.Workspace.location",
	"managed_resource_group_id": "Description.Workspace.properties.managedResourceGroupId",
	"name":                      "Description.Workspace.name",
	"parameters":                "Description.Workspace.Properties.Parameters",
	"platform_integration_id":   "IntegrationID",
	"provisioning_state":        "Description.Workspace.properties.provisioningState",
	"resource_group":            "Description.ResourceGroup",
	"sku":                       "Description.Workspace.SKU",
	"storage_account_identity":  "Description.Workspace.Properties.StorageAccountIdentity",
	"subscription":              "Description.Workspace.Properties.Subscription",
	"tags":                      "Description.Workspace.Tags",
	"title":                     "Description.Workspace.name",
	"type":                      "Description.Workspace.type",
	"ui_definition_uri":         "Description.Workspace.properties.uiDefinitionUri",
	"updated_by":                "Description.Workspace.Properties.UpdatedBy",
	"workspace_id":              "Description.Workspace.properties.workspaceId",
	"workspace_url":             "Description.Workspace.properties.workspaceUrl",
}

func GetDatabricksWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDatabricksWorkspace")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDatabricksWorkspacePaginator(essdk.BuildFilter(ctx, d.QueryContext, getDatabricksWorkspaceFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DatabricksWorkspace =============================

// ==========================  START: DataMigrationService =============================

type DataMigrationService struct {
	ResourceID      string                                `json:"resource_id"`
	PlatformID      string                                `json:"platform_id"`
	Description     azure.DataMigrationServiceDescription `json:"Description"`
	Metadata        azure.Metadata                        `json:"metadata"`
	DescribedBy     string                                `json:"described_by"`
	ResourceType    string                                `json:"resource_type"`
	IntegrationType string                                `json:"integration_type"`
	IntegrationID   string                                `json:"integration_id"`
}

type DataMigrationServiceHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  DataMigrationService `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type DataMigrationServiceHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []DataMigrationServiceHit `json:"hits"`
}

type DataMigrationServiceSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  DataMigrationServiceHits `json:"hits"`
}

type DataMigrationServicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDataMigrationServicePaginator(filters []essdk.BoolFilter, limit *int64) (DataMigrationServicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_datamigration_services", filters, limit)
	if err != nil {
		return DataMigrationServicePaginator{}, err
	}

	p := DataMigrationServicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DataMigrationServicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DataMigrationServicePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DataMigrationServicePaginator) NextPage(ctx context.Context) ([]DataMigrationService, error) {
	var response DataMigrationServiceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DataMigrationService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDataMigrationServiceFilters = map[string]string{
	"id":                      "Description.Service.id",
	"name":                    "Description.Service.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Service.Properties.Subscription",
	"tags":                    "Description.Service.Tags",
	"title":                   "Description.Service.name",
}

func ListDataMigrationService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDataMigrationService")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataMigrationService NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataMigrationService NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataMigrationService GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataMigrationService GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataMigrationService GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDataMigrationServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, listDataMigrationServiceFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataMigrationService NewDataMigrationServicePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDataMigrationService paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDataMigrationServiceFilters = map[string]string{
	"id":                      "Description.Service.id",
	"name":                    "Description.Service.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Service.Properties.Subscription",
	"tags":                    "Description.Service.Tags",
	"title":                   "Description.Service.name",
}

func GetDataMigrationService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDataMigrationService")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDataMigrationServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, getDataMigrationServiceFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DataMigrationService =============================

// ==========================  START: DataProtectionBackupVaults =============================

type DataProtectionBackupVaults struct {
	ResourceID      string                                      `json:"resource_id"`
	PlatformID      string                                      `json:"platform_id"`
	Description     azure.DataProtectionBackupVaultsDescription `json:"Description"`
	Metadata        azure.Metadata                              `json:"metadata"`
	DescribedBy     string                                      `json:"described_by"`
	ResourceType    string                                      `json:"resource_type"`
	IntegrationType string                                      `json:"integration_type"`
	IntegrationID   string                                      `json:"integration_id"`
}

type DataProtectionBackupVaultsHit struct {
	ID      string                     `json:"_id"`
	Score   float64                    `json:"_score"`
	Index   string                     `json:"_index"`
	Type    string                     `json:"_type"`
	Version int64                      `json:"_version,omitempty"`
	Source  DataProtectionBackupVaults `json:"_source"`
	Sort    []interface{}              `json:"sort"`
}

type DataProtectionBackupVaultsHits struct {
	Total essdk.SearchTotal               `json:"total"`
	Hits  []DataProtectionBackupVaultsHit `json:"hits"`
}

type DataProtectionBackupVaultsSearchResponse struct {
	PitID string                         `json:"pit_id"`
	Hits  DataProtectionBackupVaultsHits `json:"hits"`
}

type DataProtectionBackupVaultsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDataProtectionBackupVaultsPaginator(filters []essdk.BoolFilter, limit *int64) (DataProtectionBackupVaultsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_dataprotection_backupvaults", filters, limit)
	if err != nil {
		return DataProtectionBackupVaultsPaginator{}, err
	}

	p := DataProtectionBackupVaultsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DataProtectionBackupVaultsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DataProtectionBackupVaultsPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DataProtectionBackupVaultsPaginator) NextPage(ctx context.Context) ([]DataProtectionBackupVaults, error) {
	var response DataProtectionBackupVaultsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DataProtectionBackupVaults
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDataProtectionBackupVaultsFilters = map[string]string{
	"id":                      "Description.BackupVaults.id",
	"identity":                "Description.BackupVaults.Identity",
	"monitoring_settings":     "Description.BackupVaults.Properties.MonitoringSettings",
	"name":                    "Description.BackupVaults.name",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.BackupVaults.properties.provisioningState",
	"resource_move_state":     "Description.BackupVaults.properties.resourceMoveState",
	"storage_settings":        "Description.BackupVaults.Properties.StorageSettings",
	"subscription":            "Description.BackupVaults.Properties.Subscription",
	"system_data":             "Description.BackupVaults.SystemData",
	"tags":                    "Description.BackupVaults.Tags",
	"title":                   "Description.BackupVaults.name",
	"type":                    "Description.BackupVaults.type",
}

func ListDataProtectionBackupVaults(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDataProtectionBackupVaults")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataProtectionBackupVaults NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataProtectionBackupVaults NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataProtectionBackupVaults GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataProtectionBackupVaults GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataProtectionBackupVaults GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDataProtectionBackupVaultsPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDataProtectionBackupVaultsFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataProtectionBackupVaults NewDataProtectionBackupVaultsPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDataProtectionBackupVaults paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDataProtectionBackupVaultsFilters = map[string]string{
	"id":                      "Description.BackupVaults.id",
	"identity":                "Description.BackupVaults.Identity",
	"monitoring_settings":     "Description.BackupVaults.Properties.MonitoringSettings",
	"name":                    "Description.BackupVaults.name",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.BackupVaults.properties.provisioningState",
	"resource_move_state":     "Description.BackupVaults.properties.resourceMoveState",
	"storage_settings":        "Description.BackupVaults.Properties.StorageSettings",
	"subscription":            "Description.BackupVaults.Properties.Subscription",
	"system_data":             "Description.BackupVaults.SystemData",
	"tags":                    "Description.BackupVaults.Tags",
	"title":                   "Description.BackupVaults.name",
	"type":                    "Description.BackupVaults.type",
}

func GetDataProtectionBackupVaults(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDataProtectionBackupVaults")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDataProtectionBackupVaultsPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDataProtectionBackupVaultsFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DataProtectionBackupVaults =============================

// ==========================  START: DataProtectionBackupVaultsBackupPolicies =============================

type DataProtectionBackupVaultsBackupPolicies struct {
	ResourceID      string                                                    `json:"resource_id"`
	PlatformID      string                                                    `json:"platform_id"`
	Description     azure.DataProtectionBackupVaultsBackupPoliciesDescription `json:"Description"`
	Metadata        azure.Metadata                                            `json:"metadata"`
	DescribedBy     string                                                    `json:"described_by"`
	ResourceType    string                                                    `json:"resource_type"`
	IntegrationType string                                                    `json:"integration_type"`
	IntegrationID   string                                                    `json:"integration_id"`
}

type DataProtectionBackupVaultsBackupPoliciesHit struct {
	ID      string                                   `json:"_id"`
	Score   float64                                  `json:"_score"`
	Index   string                                   `json:"_index"`
	Type    string                                   `json:"_type"`
	Version int64                                    `json:"_version,omitempty"`
	Source  DataProtectionBackupVaultsBackupPolicies `json:"_source"`
	Sort    []interface{}                            `json:"sort"`
}

type DataProtectionBackupVaultsBackupPoliciesHits struct {
	Total essdk.SearchTotal                             `json:"total"`
	Hits  []DataProtectionBackupVaultsBackupPoliciesHit `json:"hits"`
}

type DataProtectionBackupVaultsBackupPoliciesSearchResponse struct {
	PitID string                                       `json:"pit_id"`
	Hits  DataProtectionBackupVaultsBackupPoliciesHits `json:"hits"`
}

type DataProtectionBackupVaultsBackupPoliciesPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDataProtectionBackupVaultsBackupPoliciesPaginator(filters []essdk.BoolFilter, limit *int64) (DataProtectionBackupVaultsBackupPoliciesPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_dataprotection_backupvaults_backuppolicies", filters, limit)
	if err != nil {
		return DataProtectionBackupVaultsBackupPoliciesPaginator{}, err
	}

	p := DataProtectionBackupVaultsBackupPoliciesPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DataProtectionBackupVaultsBackupPoliciesPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DataProtectionBackupVaultsBackupPoliciesPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DataProtectionBackupVaultsBackupPoliciesPaginator) NextPage(ctx context.Context) ([]DataProtectionBackupVaultsBackupPolicies, error) {
	var response DataProtectionBackupVaultsBackupPoliciesSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DataProtectionBackupVaultsBackupPolicies
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDataProtectionBackupVaultsBackupPoliciesFilters = map[string]string{
	"id":                      "Description.BackupPolicies.id",
	"name":                    "Description.BackupPolicies.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.BackupPolicies.Properties.Subscription",
	"title":                   "Description.BackupPolicies.name",
}

func ListDataProtectionBackupVaultsBackupPolicies(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDataProtectionBackupVaultsBackupPolicies")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataProtectionBackupVaultsBackupPolicies NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataProtectionBackupVaultsBackupPolicies NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataProtectionBackupVaultsBackupPolicies GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataProtectionBackupVaultsBackupPolicies GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataProtectionBackupVaultsBackupPolicies GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDataProtectionBackupVaultsBackupPoliciesPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDataProtectionBackupVaultsBackupPoliciesFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataProtectionBackupVaultsBackupPolicies NewDataProtectionBackupVaultsBackupPoliciesPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDataProtectionBackupVaultsBackupPolicies paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDataProtectionBackupVaultsBackupPoliciesFilters = map[string]string{
	"id":                      "Description.BackupPolicies.id",
	"name":                    "Description.BackupPolicies.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.BackupPolicies.Properties.Subscription",
	"title":                   "Description.BackupPolicies.name",
}

func GetDataProtectionBackupVaultsBackupPolicies(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDataProtectionBackupVaultsBackupPolicies")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDataProtectionBackupVaultsBackupPoliciesPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDataProtectionBackupVaultsBackupPoliciesFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DataProtectionBackupVaultsBackupPolicies =============================

// ==========================  START: DataProtectionJob =============================

type DataProtectionJob struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     azure.DataProtectionJobDescription `json:"Description"`
	Metadata        azure.Metadata                     `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type DataProtectionJobHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  DataProtectionJob `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type DataProtectionJobHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []DataProtectionJobHit `json:"hits"`
}

type DataProtectionJobSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  DataProtectionJobHits `json:"hits"`
}

type DataProtectionJobPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDataProtectionJobPaginator(filters []essdk.BoolFilter, limit *int64) (DataProtectionJobPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_dataprotection_backupjobs", filters, limit)
	if err != nil {
		return DataProtectionJobPaginator{}, err
	}

	p := DataProtectionJobPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DataProtectionJobPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DataProtectionJobPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DataProtectionJobPaginator) NextPage(ctx context.Context) ([]DataProtectionJob, error) {
	var response DataProtectionJobSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DataProtectionJob
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDataProtectionJobFilters = map[string]string{
	"activity_id":                   "Description.DataProtectionJob.properties.activityID",
	"backup_instance_friendly_name": "Description.DataProtectionJob.properties.backupInstanceFriendlyName",
	"backup_instance_id":            "Description.DataProtectionJob.properties.backupInstanceId",
	"data_source_id":                "Description.DataProtectionJob.properties.dataSourceId",
	"data_source_location":          "Description.DataProtectionJob.properties.dataSourceLocation",
	"data_source_name":              "Description.DataProtectionJob.properties.dataSourceName",
	"data_source_set_name":          "Description.DataProtectionJob.properties.dataSourceSetName",
	"data_source_type":              "Description.DataProtectionJob.properties.dataSourceType",
	"destination_data_store_name":   "Description.DataProtectionJob.properties.destinationDataStoreName",
	"duration":                      "Description.DataProtectionJob.properties.duration",
	"error_details":                 "Description.DataProtectionJob.Properties.ErrorDetails",
	"etag":                          "Description.DataProtectionJob.properties.etag",
	"extended_info":                 "Description.DataProtectionJob.Properties.ExtendedInfo",
	"id":                            "Description.DataProtectionJob.id",
	"is_user_triggered":             "Description.DataProtectionJob.properties.isUserTriggered",
	"name":                          "Description.DataProtectionJob.name",
	"operation":                     "Description.DataProtectionJob.properties.operation",
	"operation_category":            "Description.DataProtectionJob.properties.operationCategory",
	"policy_id":                     "Description.DataProtectionJob.properties.policyId",
	"policy_name":                   "Description.DataProtectionJob.properties.policyName",
	"progress_enabled":              "Description.DataProtectionJob.properties.progressEnabled",
	"progress_url":                  "Description.DataProtectionJob.properties.progressUrl",
	"resource_group":                "Description.ResourceGroup",
	"restore_type":                  "Description.DataProtectionJob.properties.restoreType",
	"source_data_store_name":        "Description.DataProtectionJob.properties.sourceDataStoreName",
	"source_resource_group":         "Description.DataProtectionJob.properties.sourceResourceGroup",
	"source_subscription_id":        "Description.DataProtectionJob.properties.sourceSubscriptionID",
	"start_time":                    "Description.DataProtectionJob.Properties.StartTime",
	"status":                        "Description.DataProtectionJob.properties.status",
	"subscription":                  "Description.DataProtectionJob.Properties.Subscription",
	"supported_actions":             "Description.DataProtectionJob.Properties.SupportedActions",
	"title":                         "Description.DataProtectionJob.name",
	"type":                          "Description.DataProtectionJob.type",
	"vault_name":                    "Description.VaultName",
}

func ListDataProtectionJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDataProtectionJob")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataProtectionJob NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataProtectionJob NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataProtectionJob GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataProtectionJob GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataProtectionJob GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDataProtectionJobPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDataProtectionJobFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataProtectionJob NewDataProtectionJobPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDataProtectionJob paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDataProtectionJobFilters = map[string]string{
	"activity_id":                   "Description.DataProtectionJob.properties.activityID",
	"backup_instance_friendly_name": "Description.DataProtectionJob.properties.backupInstanceFriendlyName",
	"backup_instance_id":            "Description.DataProtectionJob.properties.backupInstanceId",
	"data_source_id":                "Description.DataProtectionJob.properties.dataSourceId",
	"data_source_location":          "Description.DataProtectionJob.properties.dataSourceLocation",
	"data_source_name":              "Description.DataProtectionJob.properties.dataSourceName",
	"data_source_set_name":          "Description.DataProtectionJob.properties.dataSourceSetName",
	"data_source_type":              "Description.DataProtectionJob.properties.dataSourceType",
	"destination_data_store_name":   "Description.DataProtectionJob.properties.destinationDataStoreName",
	"duration":                      "Description.DataProtectionJob.properties.duration",
	"error_details":                 "Description.DataProtectionJob.Properties.ErrorDetails",
	"etag":                          "Description.DataProtectionJob.properties.etag",
	"extended_info":                 "Description.DataProtectionJob.Properties.ExtendedInfo",
	"id":                            "Description.DataProtectionJob.id",
	"is_user_triggered":             "Description.DataProtectionJob.properties.isUserTriggered",
	"name":                          "Description.DataProtectionJob.name",
	"operation":                     "Description.DataProtectionJob.properties.operation",
	"operation_category":            "Description.DataProtectionJob.properties.operationCategory",
	"policy_id":                     "Description.DataProtectionJob.properties.policyId",
	"policy_name":                   "Description.DataProtectionJob.properties.policyName",
	"progress_enabled":              "Description.DataProtectionJob.properties.progressEnabled",
	"progress_url":                  "Description.DataProtectionJob.properties.progressUrl",
	"resource_group":                "Description.ResourceGroup",
	"restore_type":                  "Description.DataProtectionJob.properties.restoreType",
	"source_data_store_name":        "Description.DataProtectionJob.properties.sourceDataStoreName",
	"source_resource_group":         "Description.DataProtectionJob.properties.sourceResourceGroup",
	"source_subscription_id":        "Description.DataProtectionJob.properties.sourceSubscriptionID",
	"start_time":                    "Description.DataProtectionJob.Properties.StartTime",
	"status":                        "Description.DataProtectionJob.properties.status",
	"subscription":                  "Description.DataProtectionJob.Properties.Subscription",
	"supported_actions":             "Description.DataProtectionJob.Properties.SupportedActions",
	"title":                         "Description.DataProtectionJob.name",
	"type":                          "Description.DataProtectionJob.type",
	"vault_name":                    "Description.VaultName",
}

func GetDataProtectionJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDataProtectionJob")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDataProtectionJobPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDataProtectionJobFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DataProtectionJob =============================

// ==========================  START: DataFactory =============================

type DataFactory struct {
	ResourceID      string                       `json:"resource_id"`
	PlatformID      string                       `json:"platform_id"`
	Description     azure.DataFactoryDescription `json:"Description"`
	Metadata        azure.Metadata               `json:"metadata"`
	DescribedBy     string                       `json:"described_by"`
	ResourceType    string                       `json:"resource_type"`
	IntegrationType string                       `json:"integration_type"`
	IntegrationID   string                       `json:"integration_id"`
}

type DataFactoryHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  DataFactory   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DataFactoryHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []DataFactoryHit  `json:"hits"`
}

type DataFactorySearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  DataFactoryHits `json:"hits"`
}

type DataFactoryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDataFactoryPaginator(filters []essdk.BoolFilter, limit *int64) (DataFactoryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_datafactory_factories", filters, limit)
	if err != nil {
		return DataFactoryPaginator{}, err
	}

	p := DataFactoryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DataFactoryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DataFactoryPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DataFactoryPaginator) NextPage(ctx context.Context) ([]DataFactory, error) {
	var response DataFactorySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DataFactory
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDataFactoryFilters = map[string]string{
	"additional_properties":        "Description.Factory.AdditionalProperties",
	"encryption":                   "Description.Factory.Properties.Encryption",
	"etag":                         "Description.Factory.eTag",
	"global_parameters":            "Description.Factory.Properties.GlobalParameters",
	"id":                           "Description.Factory.id",
	"identity":                     "Description.Factory.Identity",
	"name":                         "Description.Factory.name",
	"platform_integration_id":      "IntegrationID",
	"private_endpoint_connections": "Description.PrivateEndPointConnections",
	"provisioning_state":           "Description.Factory.properties.provisioningState",
	"public_network_access":        "Description.Factory.properties.publicNetworkAccess",
	"repo_configuration":           "Description.Factory.Properties.RepoConfiguration",
	"resource_group":               "Description.ResourceGroup",
	"subscription":                 "Description.Factory.Properties.Subscription",
	"tags":                         "Description.Factory.Tags",
	"title":                        "Description.Factory.name",
	"type":                         "Description.Factory.type",
	"version":                      "Description.Factory.properties.version",
}

func ListDataFactory(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDataFactory")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataFactory NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataFactory NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataFactory GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataFactory GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataFactory GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDataFactoryPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDataFactoryFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataFactory NewDataFactoryPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDataFactory paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDataFactoryFilters = map[string]string{
	"additional_properties":        "Description.Factory.AdditionalProperties",
	"encryption":                   "Description.Factory.Properties.Encryption",
	"etag":                         "Description.Factory.eTag",
	"global_parameters":            "Description.Factory.Properties.GlobalParameters",
	"id":                           "Description.Factory.id",
	"identity":                     "Description.Factory.Identity",
	"name":                         "description.Factory.name",
	"platform_integration_id":      "IntegrationID",
	"private_endpoint_connections": "Description.PrivateEndPointConnections",
	"provisioning_state":           "Description.Factory.properties.provisioningState",
	"public_network_access":        "Description.Factory.properties.publicNetworkAccess",
	"repo_configuration":           "Description.Factory.Properties.RepoConfiguration",
	"resource_group":               "description.ResourceGroup",
	"subscription":                 "Description.Factory.Properties.Subscription",
	"tags":                         "Description.Factory.Tags",
	"title":                        "Description.Factory.name",
	"type":                         "Description.Factory.type",
	"version":                      "Description.Factory.properties.version",
}

func GetDataFactory(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDataFactory")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDataFactoryPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDataFactoryFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DataFactory =============================

// ==========================  START: DataFactoryDataset =============================

type DataFactoryDataset struct {
	ResourceID      string                              `json:"resource_id"`
	PlatformID      string                              `json:"platform_id"`
	Description     azure.DataFactoryDatasetDescription `json:"Description"`
	Metadata        azure.Metadata                      `json:"metadata"`
	DescribedBy     string                              `json:"described_by"`
	ResourceType    string                              `json:"resource_type"`
	IntegrationType string                              `json:"integration_type"`
	IntegrationID   string                              `json:"integration_id"`
}

type DataFactoryDatasetHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  DataFactoryDataset `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type DataFactoryDatasetHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []DataFactoryDatasetHit `json:"hits"`
}

type DataFactoryDatasetSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  DataFactoryDatasetHits `json:"hits"`
}

type DataFactoryDatasetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDataFactoryDatasetPaginator(filters []essdk.BoolFilter, limit *int64) (DataFactoryDatasetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_datafactory_factories_datasets", filters, limit)
	if err != nil {
		return DataFactoryDatasetPaginator{}, err
	}

	p := DataFactoryDatasetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DataFactoryDatasetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DataFactoryDatasetPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DataFactoryDatasetPaginator) NextPage(ctx context.Context) ([]DataFactoryDataset, error) {
	var response DataFactoryDatasetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DataFactoryDataset
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDataFactoryDatasetFilters = map[string]string{
	"etag":                    "Description.Dataset.etag",
	"factory_name":            "Description.Factory.name",
	"id":                      "Description.Dataset.id",
	"name":                    "Description.Dataset.name",
	"platform_integration_id": "IntegrationID",
	"properties":              "Description.Dataset.Properties",
	"resource_group":          "Description.ResourceGroup",
	"subscription":            "Description.Dataset.Properties.Subscription",
	"title":                   "Description.Dataset.name",
	"type":                    "Description.Dataset.type",
}

func ListDataFactoryDataset(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDataFactoryDataset")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataFactoryDataset NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataFactoryDataset NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataFactoryDataset GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataFactoryDataset GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataFactoryDataset GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDataFactoryDatasetPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDataFactoryDatasetFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataFactoryDataset NewDataFactoryDatasetPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDataFactoryDataset paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDataFactoryDatasetFilters = map[string]string{
	"etag":                    "Description.Dataset.etag",
	"factory_name":            "description.Factory.name",
	"id":                      "Description.Dataset.id",
	"name":                    "description.Dataset.name",
	"platform_integration_id": "IntegrationID",
	"properties":              "Description.Dataset.Properties",
	"resource_group":          "description.ResourceGroup",
	"subscription":            "Description.Dataset.Properties.Subscription",
	"title":                   "Description.Dataset.name",
	"type":                    "Description.Dataset.type",
}

func GetDataFactoryDataset(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDataFactoryDataset")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDataFactoryDatasetPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDataFactoryDatasetFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DataFactoryDataset =============================

// ==========================  START: DataFactoryPipeline =============================

type DataFactoryPipeline struct {
	ResourceID      string                               `json:"resource_id"`
	PlatformID      string                               `json:"platform_id"`
	Description     azure.DataFactoryPipelineDescription `json:"Description"`
	Metadata        azure.Metadata                       `json:"metadata"`
	DescribedBy     string                               `json:"described_by"`
	ResourceType    string                               `json:"resource_type"`
	IntegrationType string                               `json:"integration_type"`
	IntegrationID   string                               `json:"integration_id"`
}

type DataFactoryPipelineHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  DataFactoryPipeline `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type DataFactoryPipelineHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []DataFactoryPipelineHit `json:"hits"`
}

type DataFactoryPipelineSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  DataFactoryPipelineHits `json:"hits"`
}

type DataFactoryPipelinePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDataFactoryPipelinePaginator(filters []essdk.BoolFilter, limit *int64) (DataFactoryPipelinePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_datafactory_factories_pipelines", filters, limit)
	if err != nil {
		return DataFactoryPipelinePaginator{}, err
	}

	p := DataFactoryPipelinePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DataFactoryPipelinePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DataFactoryPipelinePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DataFactoryPipelinePaginator) NextPage(ctx context.Context) ([]DataFactoryPipeline, error) {
	var response DataFactoryPipelineSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DataFactoryPipeline
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDataFactoryPipelineFilters = map[string]string{
	"activities":              "Description.Pipeline.Properties.Activities",
	"annotations":             "Description.Pipeline.Properties.Annotations",
	"concurrency":             "Description.Pipeline.properties.concurrency",
	"description":             "Description.Pipeline.properties.description",
	"etag":                    "Description.Pipeline.etag",
	"factory_name":            "Description.Factory.name",
	"id":                      "Description.Pipeline.id",
	"name":                    "Description.Pipeline.name",
	"parameters":              "Description.Pipeline.Properties.Parameters",
	"pipeline_folder":         "Description.Pipeline.properties.folder.name",
	"pipeline_policy":         "Description.Pipeline.Properties.Policy",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "Description.ResourceGroup",
	"run_dimensions":          "Description.Pipeline.Properties.RunDimensions",
	"subscription":            "Description.Pipeline.Properties.Subscription",
	"title":                   "Description.Pipeline.name",
	"type":                    "Description.Pipeline.type",
	"variables":               "Description.Pipeline.Properties.Variables",
}

func ListDataFactoryPipeline(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDataFactoryPipeline")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataFactoryPipeline NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataFactoryPipeline NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataFactoryPipeline GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataFactoryPipeline GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataFactoryPipeline GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDataFactoryPipelinePaginator(essdk.BuildFilter(ctx, d.QueryContext, listDataFactoryPipelineFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataFactoryPipeline NewDataFactoryPipelinePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDataFactoryPipeline paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDataFactoryPipelineFilters = map[string]string{
	"activities":              "Description.Pipeline.Properties.Activities",
	"annotations":             "Description.Pipeline.Properties.Annotations",
	"concurrency":             "Description.Pipeline.properties.concurrency",
	"description":             "Description.Pipeline.properties.description",
	"etag":                    "Description.Pipeline.etag",
	"factory_name":            "description.Factory.name",
	"id":                      "Description.Pipeline.id",
	"name":                    "description.Pipeline.name",
	"parameters":              "Description.Pipeline.Properties.Parameters",
	"pipeline_folder":         "Description.Pipeline.properties.folder.name",
	"pipeline_policy":         "Description.Pipeline.Properties.Policy",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "description.ResourceGroup",
	"run_dimensions":          "Description.Pipeline.Properties.RunDimensions",
	"subscription":            "Description.Pipeline.Properties.Subscription",
	"title":                   "Description.Pipeline.name",
	"type":                    "Description.Pipeline.type",
	"variables":               "Description.Pipeline.Properties.Variables",
}

func GetDataFactoryPipeline(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDataFactoryPipeline")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDataFactoryPipelinePaginator(essdk.BuildFilter(ctx, d.QueryContext, getDataFactoryPipelineFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DataFactoryPipeline =============================

// ==========================  START: DataLakeAnalyticsAccount =============================

type DataLakeAnalyticsAccount struct {
	ResourceID      string                                    `json:"resource_id"`
	PlatformID      string                                    `json:"platform_id"`
	Description     azure.DataLakeAnalyticsAccountDescription `json:"Description"`
	Metadata        azure.Metadata                            `json:"metadata"`
	DescribedBy     string                                    `json:"described_by"`
	ResourceType    string                                    `json:"resource_type"`
	IntegrationType string                                    `json:"integration_type"`
	IntegrationID   string                                    `json:"integration_id"`
}

type DataLakeAnalyticsAccountHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  DataLakeAnalyticsAccount `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type DataLakeAnalyticsAccountHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []DataLakeAnalyticsAccountHit `json:"hits"`
}

type DataLakeAnalyticsAccountSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  DataLakeAnalyticsAccountHits `json:"hits"`
}

type DataLakeAnalyticsAccountPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDataLakeAnalyticsAccountPaginator(filters []essdk.BoolFilter, limit *int64) (DataLakeAnalyticsAccountPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_datalakeanalytics_accounts", filters, limit)
	if err != nil {
		return DataLakeAnalyticsAccountPaginator{}, err
	}

	p := DataLakeAnalyticsAccountPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DataLakeAnalyticsAccountPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DataLakeAnalyticsAccountPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DataLakeAnalyticsAccountPaginator) NextPage(ctx context.Context) ([]DataLakeAnalyticsAccount, error) {
	var response DataLakeAnalyticsAccountSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DataLakeAnalyticsAccount
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDataLakeAnalyticsAccountFilters = map[string]string{
	"account_id":                        "Description.DataLakeAnalyticsAccount.properties.accountId",
	"compute_policies":                  "Description.DataLakeAnalyticsAccount.Properties.ComputePolicies",
	"current_tier":                      "Description.DataLakeAnalyticsAccount.properties.currentTier",
	"data_lake_store_accounts":          "Description.DataLakeAnalyticsAccount.Properties.DataLakeStoreAccounts",
	"default_data_lake_store_account":   "Description.DataLakeAnalyticsAccount.properties.defaultDataLakeStoreAccount",
	"diagnostic_settings":               "Description.DiagnosticSettingsResource",
	"endpoint":                          "Description.DataLakeAnalyticsAccount.properties.endpoint",
	"firewall_allow_azure_ips":          "Description.DataLakeAnalyticsAccount.properties.firewallAllowAzureIps",
	"firewall_rules":                    "Description.DataLakeAnalyticsAccount.Properties.FirewallRules",
	"firewall_state":                    "Description.DataLakeAnalyticsAccount.properties.firewallState",
	"id":                                "Description.DataLakeAnalyticsAccount.id",
	"max_degree_of_parallelism":         "Description.DataLakeAnalyticsAccount.properties.maxDegreeOfParallelism",
	"max_degree_of_parallelism_per_job": "Description.DataLakeAnalyticsAccount.properties.maxDegreeOfParallelismPerJob",
	"max_job_count":                     "Description.DataLakeAnalyticsAccount.properties.maxJobCount",
	"min_priority_per_job":              "Description.DataLakeAnalyticsAccount.properties.minPriorityPerJob",
	"name":                              "Description.DataLakeAnalyticsAccount.name",
	"new_tier":                          "Description.DataLakeAnalyticsAccount.properties.newTier",
	"platform_integration_id":           "IntegrationID",
	"provisioning_state":                "Description.DataLakeAnalyticsAccount.properties.provisioningState",
	"query_store_retention":             "Description.DataLakeAnalyticsAccount.properties.queryStoreRetention",
	"resource_group":                    "Description.ResourceGroup",
	"state":                             "Description.DataLakeAnalyticsAccount.properties.state",
	"storage_accounts":                  "Description.DataLakeAnalyticsAccount.Properties.StorageAccounts",
	"subscription":                      "Description.DataLakeAnalyticsAccount.Properties.Subscription",
	"system_max_degree_of_parallelism":  "Description.DataLakeAnalyticsAccount.properties.systemMaxDegreeOfParallelism",
	"system_max_job_count":              "Description.DataLakeAnalyticsAccount.properties.systemMaxJobCount",
	"tags":                              "Description.DataLakeAnalyticsAccount.Tags",
	"title":                             "Description.DataLakeAnalyticsAccount.name",
	"type":                              "Description.DataLakeAnalyticsAccount.type",
}

func ListDataLakeAnalyticsAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDataLakeAnalyticsAccount")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataLakeAnalyticsAccount NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataLakeAnalyticsAccount NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataLakeAnalyticsAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataLakeAnalyticsAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataLakeAnalyticsAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDataLakeAnalyticsAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDataLakeAnalyticsAccountFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDataLakeAnalyticsAccount NewDataLakeAnalyticsAccountPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDataLakeAnalyticsAccount paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDataLakeAnalyticsAccountFilters = map[string]string{
	"account_id":                        "Description.DataLakeAnalyticsAccount.properties.accountId",
	"compute_policies":                  "Description.DataLakeAnalyticsAccount.Properties.ComputePolicies",
	"current_tier":                      "Description.DataLakeAnalyticsAccount.properties.currentTier",
	"data_lake_store_accounts":          "Description.DataLakeAnalyticsAccount.Properties.DataLakeStoreAccounts",
	"default_data_lake_store_account":   "Description.DataLakeAnalyticsAccount.properties.defaultDataLakeStoreAccount",
	"diagnostic_settings":               "Description.DiagnosticSettingsResource",
	"endpoint":                          "Description.DataLakeAnalyticsAccount.properties.endpoint",
	"firewall_allow_azure_ips":          "Description.DataLakeAnalyticsAccount.properties.firewallAllowAzureIps",
	"firewall_rules":                    "Description.DataLakeAnalyticsAccount.Properties.FirewallRules",
	"firewall_state":                    "Description.DataLakeAnalyticsAccount.properties.firewallState",
	"id":                                "Description.DataLakeAnalyticsAccount.id",
	"max_degree_of_parallelism":         "Description.DataLakeAnalyticsAccount.properties.maxDegreeOfParallelism",
	"max_degree_of_parallelism_per_job": "Description.DataLakeAnalyticsAccount.properties.maxDegreeOfParallelismPerJob",
	"max_job_count":                     "Description.DataLakeAnalyticsAccount.properties.maxJobCount",
	"min_priority_per_job":              "Description.DataLakeAnalyticsAccount.properties.minPriorityPerJob",
	"name":                              "description.DataLakeAnalyticsAccount.name",
	"new_tier":                          "Description.DataLakeAnalyticsAccount.properties.newTier",
	"platform_integration_id":           "IntegrationID",
	"provisioning_state":                "Description.DataLakeAnalyticsAccount.properties.provisioningState",
	"query_store_retention":             "Description.DataLakeAnalyticsAccount.properties.queryStoreRetention",
	"resource_group":                    "description.ResourceGroup",
	"state":                             "Description.DataLakeAnalyticsAccount.properties.state",
	"storage_accounts":                  "Description.DataLakeAnalyticsAccount.Properties.StorageAccounts",
	"subscription":                      "Description.DataLakeAnalyticsAccount.Properties.Subscription",
	"system_max_degree_of_parallelism":  "Description.DataLakeAnalyticsAccount.properties.systemMaxDegreeOfParallelism",
	"system_max_job_count":              "Description.DataLakeAnalyticsAccount.properties.systemMaxJobCount",
	"tags":                              "Description.DataLakeAnalyticsAccount.Tags",
	"title":                             "Description.DataLakeAnalyticsAccount.name",
	"type":                              "Description.DataLakeAnalyticsAccount.type",
}

func GetDataLakeAnalyticsAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDataLakeAnalyticsAccount")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDataLakeAnalyticsAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDataLakeAnalyticsAccountFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DataLakeAnalyticsAccount =============================

// ==========================  START: DiagnosticSetting =============================

type DiagnosticSetting struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     azure.DiagnosticSettingDescription `json:"Description"`
	Metadata        azure.Metadata                     `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type DiagnosticSettingHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  DiagnosticSetting `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type DiagnosticSettingHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []DiagnosticSettingHit `json:"hits"`
}

type DiagnosticSettingSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  DiagnosticSettingHits `json:"hits"`
}

type DiagnosticSettingPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDiagnosticSettingPaginator(filters []essdk.BoolFilter, limit *int64) (DiagnosticSettingPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_insights_guestdiagnosticsettings", filters, limit)
	if err != nil {
		return DiagnosticSettingPaginator{}, err
	}

	p := DiagnosticSettingPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DiagnosticSettingPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DiagnosticSettingPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DiagnosticSettingPaginator) NextPage(ctx context.Context) ([]DiagnosticSetting, error) {
	var response DiagnosticSettingSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DiagnosticSetting
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDiagnosticSettingFilters = map[string]string{
	"event_hub_authorization_rule_id": "Description.DiagnosticSettingsResource.properties.eventHubAuthorizationRuleId",
	"event_hub_name":                  "Description.DiagnosticSettingsResource.properties.eventHubName",
	"id":                              "Description.DiagnosticSettingsResource.id",
	"log_analytics_destination_type":  "Description.DiagnosticSettingsResource.properties.logAnalyticsDestinationType",
	"logs":                            "Description.DiagnosticSettingsResource.Properties.Logs",
	"metrics":                         "Description.DiagnosticSettingsResource.Properties.Metrics",
	"name":                            "Description.DiagnosticSettingsResource.name",
	"platform_integration_id":         "IntegrationID",
	"resource_group":                  "Description.ResourceGroup",
	"service_bus_rule_id":             "Description.DiagnosticSettingsResource.properties.serviceBusRuleId",
	"storage_account_id":              "Description.DiagnosticSettingsResource.properties.storageAccountId",
	"subscription":                    "Description.DiagnosticSettingsResource.Properties.Subscription",
	"title":                           "Description.DiagnosticSettingsResource.name",
	"type":                            "Description.DiagnosticSettingsResource.type",
	"workspace_id":                    "Description.DiagnosticSettingsResource.properties.workspaceId",
}

func ListDiagnosticSetting(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDiagnosticSetting")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDiagnosticSetting NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDiagnosticSetting NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDiagnosticSetting GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDiagnosticSetting GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDiagnosticSetting GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDiagnosticSettingPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDiagnosticSettingFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDiagnosticSetting NewDiagnosticSettingPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDiagnosticSetting paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDiagnosticSettingFilters = map[string]string{
	"event_hub_authorization_rule_id": "Description.DiagnosticSettingsResource.properties.eventHubAuthorizationRuleId",
	"event_hub_name":                  "Description.DiagnosticSettingsResource.properties.eventHubName",
	"id":                              "Description.DiagnosticSettingsResource.id",
	"log_analytics_destination_type":  "Description.DiagnosticSettingsResource.properties.logAnalyticsDestinationType",
	"logs":                            "Description.DiagnosticSettingsResource.Properties.Logs",
	"metrics":                         "Description.DiagnosticSettingsResource.Properties.Metrics",
	"name":                            "description.DiagnosticSettingsResource.name",
	"platform_integration_id":         "IntegrationID",
	"resource_group":                  "description.ResourceGroup",
	"service_bus_rule_id":             "Description.DiagnosticSettingsResource.properties.serviceBusRuleId",
	"storage_account_id":              "Description.DiagnosticSettingsResource.properties.storageAccountId",
	"subscription":                    "Description.DiagnosticSettingsResource.Properties.Subscription",
	"title":                           "Description.DiagnosticSettingsResource.name",
	"type":                            "Description.DiagnosticSettingsResource.type",
	"workspace_id":                    "Description.DiagnosticSettingsResource.properties.workspaceId",
}

func GetDiagnosticSetting(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDiagnosticSetting")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDiagnosticSettingPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDiagnosticSettingFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DiagnosticSetting =============================

// ==========================  START: AutoscaleSetting =============================

type AutoscaleSetting struct {
	ResourceID      string                            `json:"resource_id"`
	PlatformID      string                            `json:"platform_id"`
	Description     azure.AutoscaleSettingDescription `json:"Description"`
	Metadata        azure.Metadata                    `json:"metadata"`
	DescribedBy     string                            `json:"described_by"`
	ResourceType    string                            `json:"resource_type"`
	IntegrationType string                            `json:"integration_type"`
	IntegrationID   string                            `json:"integration_id"`
}

type AutoscaleSettingHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  AutoscaleSetting `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type AutoscaleSettingHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []AutoscaleSettingHit `json:"hits"`
}

type AutoscaleSettingSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  AutoscaleSettingHits `json:"hits"`
}

type AutoscaleSettingPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAutoscaleSettingPaginator(filters []essdk.BoolFilter, limit *int64) (AutoscaleSettingPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_insights_autoscalesettings", filters, limit)
	if err != nil {
		return AutoscaleSettingPaginator{}, err
	}

	p := AutoscaleSettingPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AutoscaleSettingPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AutoscaleSettingPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AutoscaleSettingPaginator) NextPage(ctx context.Context) ([]AutoscaleSetting, error) {
	var response AutoscaleSettingSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AutoscaleSetting
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAutoscaleSettingFilters = map[string]string{
	"enabled":                  "Description.AutoscaleSettingsResource.properties.enabled",
	"id":                       "Description.AutoscaleSettingsResource.id",
	"name":                     "Description.AutoscaleSettingsResource.name",
	"notifications":            "Description.AutoscaleSettingsResource.Properties.Notifications",
	"platform_integration_id":  "IntegrationID",
	"profiles":                 "Description.AutoscaleSettingsResource.Properties.Profiles",
	"resource_group":           "Description.ResourceGroup",
	"subscription":             "Description.AutoscaleSettingsResource.Properties.Subscription",
	"target_resource_location": "Description.AutoscaleSettingsResource.properties.targetResourceLocation",
	"target_resource_uri":      "Description.AutoscaleSettingsResource.properties.targetResourceUri",
	"title":                    "Description.AutoscaleSettingsResource.name",
	"type":                     "Description.AutoscaleSettingsResource.type",
}

func ListAutoscaleSetting(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAutoscaleSetting")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutoscaleSetting NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutoscaleSetting NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutoscaleSetting GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutoscaleSetting GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutoscaleSetting GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAutoscaleSettingPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAutoscaleSettingFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAutoscaleSetting NewAutoscaleSettingPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAutoscaleSetting paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAutoscaleSettingFilters = map[string]string{
	"enabled":                  "Description.AutoscaleSettingsResource.properties.enabled",
	"id":                       "Description.AutoscaleSettingsResource.id",
	"name":                     "description.AutoscaleSettingsResource.name",
	"notifications":            "Description.AutoscaleSettingsResource.Properties.Notifications",
	"platform_integration_id":  "IntegrationID",
	"profiles":                 "Description.AutoscaleSettingsResource.Properties.Profiles",
	"resource_group":           "description.ResourceGroup",
	"subscription":             "Description.AutoscaleSettingsResource.Properties.Subscription",
	"target_resource_location": "Description.AutoscaleSettingsResource.properties.targetResourceLocation",
	"target_resource_uri":      "Description.AutoscaleSettingsResource.properties.targetResourceUri",
	"title":                    "Description.AutoscaleSettingsResource.name",
	"type":                     "Description.AutoscaleSettingsResource.type",
}

func GetAutoscaleSetting(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAutoscaleSetting")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAutoscaleSettingPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAutoscaleSettingFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AutoscaleSetting =============================

// ==========================  START: EventGridDomain =============================

type EventGridDomain struct {
	ResourceID      string                           `json:"resource_id"`
	PlatformID      string                           `json:"platform_id"`
	Description     azure.EventGridDomainDescription `json:"Description"`
	Metadata        azure.Metadata                   `json:"metadata"`
	DescribedBy     string                           `json:"described_by"`
	ResourceType    string                           `json:"resource_type"`
	IntegrationType string                           `json:"integration_type"`
	IntegrationID   string                           `json:"integration_id"`
}

type EventGridDomainHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  EventGridDomain `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type EventGridDomainHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []EventGridDomainHit `json:"hits"`
}

type EventGridDomainSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  EventGridDomainHits `json:"hits"`
}

type EventGridDomainPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEventGridDomainPaginator(filters []essdk.BoolFilter, limit *int64) (EventGridDomainPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_eventgrid_domains", filters, limit)
	if err != nil {
		return EventGridDomainPaginator{}, err
	}

	p := EventGridDomainPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EventGridDomainPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EventGridDomainPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EventGridDomainPaginator) NextPage(ctx context.Context) ([]EventGridDomain, error) {
	var response EventGridDomainSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EventGridDomain
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEventGridDomainFilters = map[string]string{
	"auto_create_topic_with_first_subscription": "Description.Domain.properties.autoCreateTopicWithFirstSubscription",
	"auto_delete_topic_with_last_subscription":  "Description.Domain.properties.autoDeleteTopicWithLastSubscription",
	"created_by":               "Description.Domain.systemData.createdBy",
	"created_by_type":          "Description.Domain.systemData.createdByType",
	"diagnostic_settings":      "Description.DiagnosticSettingsResources",
	"disable_local_auth":       "Description.Domain.properties.disableLocalAuth",
	"endpoint":                 "Description.Domain.properties.endpoint",
	"id":                       "Description.Domain.id",
	"identity_type":            "Description.Domain.identity.type",
	"inbound_ip_rules":         "Description.Domain.Properties.InboundIPRules",
	"input_schema":             "Description.Domain.properties.inputSchema",
	"input_schema_mapping":     "Description.Domain.Properties.InputSchemaMapping",
	"last_modified_by":         "Description.Domain.systemData.lastModifiedBy",
	"last_modified_by_type":    "Description.Domain.systemData.lastModifiedByType",
	"location":                 "Description.Domain.location",
	"name":                     "Description.Domain.name",
	"platform_integration_id":  "IntegrationID",
	"principal_id":             "Description.Domain.identity.principalId",
	"provisioning_state":       "Description.Domain.properties.provisioningState",
	"public_network_access":    "Description.Domain.properties.publicNetworkAccess",
	"resource_group":           "Description.ResourceGroup",
	"sku_name":                 "Description.Domain.name",
	"subscription":             "Description.Domain.Properties.Subscription",
	"tags":                     "Description.Domain.Tags",
	"title":                    "Description.Domain.name",
	"type":                     "Description.Domain.type",
	"user_assigned_identities": "Description.Domain.Identity.UserAssignedIdentities",
}

func ListEventGridDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEventGridDomain")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventGridDomain NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventGridDomain NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventGridDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventGridDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventGridDomain GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEventGridDomainPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEventGridDomainFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventGridDomain NewEventGridDomainPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEventGridDomain paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEventGridDomainFilters = map[string]string{
	"auto_create_topic_with_first_subscription": "Description.Domain.properties.autoCreateTopicWithFirstSubscription",
	"auto_delete_topic_with_last_subscription":  "Description.Domain.properties.autoDeleteTopicWithLastSubscription",
	"created_by":               "Description.Domain.systemData.createdBy",
	"created_by_type":          "Description.Domain.systemData.createdByType",
	"diagnostic_settings":      "Description.DiagnosticSettingsResources",
	"disable_local_auth":       "Description.Domain.properties.disableLocalAuth",
	"endpoint":                 "Description.Domain.properties.endpoint",
	"id":                       "Description.Domain.id",
	"identity_type":            "Description.Domain.identity.type",
	"inbound_ip_rules":         "Description.Domain.Properties.InboundIPRules",
	"input_schema":             "Description.Domain.properties.inputSchema",
	"input_schema_mapping":     "Description.Domain.Properties.InputSchemaMapping",
	"last_modified_by":         "Description.Domain.systemData.lastModifiedBy",
	"last_modified_by_type":    "Description.Domain.systemData.lastModifiedByType",
	"location":                 "Description.Domain.location",
	"name":                     "description.Domain.name",
	"platform_integration_id":  "IntegrationID",
	"principal_id":             "Description.Domain.identity.principalId",
	"provisioning_state":       "Description.Domain.properties.provisioningState",
	"public_network_access":    "Description.Domain.properties.publicNetworkAccess",
	"resource_group":           "description.ResourceGroup",
	"sku_name":                 "Description.Domain.name",
	"subscription":             "Description.Domain.Properties.Subscription",
	"tags":                     "Description.Domain.Tags",
	"title":                    "Description.Domain.name",
	"type":                     "Description.Domain.type",
	"user_assigned_identities": "Description.Domain.Identity.UserAssignedIdentities",
}

func GetEventGridDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEventGridDomain")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEventGridDomainPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEventGridDomainFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EventGridDomain =============================

// ==========================  START: EventGridTopic =============================

type EventGridTopic struct {
	ResourceID      string                          `json:"resource_id"`
	PlatformID      string                          `json:"platform_id"`
	Description     azure.EventGridTopicDescription `json:"Description"`
	Metadata        azure.Metadata                  `json:"metadata"`
	DescribedBy     string                          `json:"described_by"`
	ResourceType    string                          `json:"resource_type"`
	IntegrationType string                          `json:"integration_type"`
	IntegrationID   string                          `json:"integration_id"`
}

type EventGridTopicHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  EventGridTopic `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type EventGridTopicHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []EventGridTopicHit `json:"hits"`
}

type EventGridTopicSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  EventGridTopicHits `json:"hits"`
}

type EventGridTopicPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEventGridTopicPaginator(filters []essdk.BoolFilter, limit *int64) (EventGridTopicPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_eventgrid_topics", filters, limit)
	if err != nil {
		return EventGridTopicPaginator{}, err
	}

	p := EventGridTopicPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EventGridTopicPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EventGridTopicPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EventGridTopicPaginator) NextPage(ctx context.Context) ([]EventGridTopic, error) {
	var response EventGridTopicSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EventGridTopic
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEventGridTopicFilters = map[string]string{
	"created_by":              "Description.Topic.systemData.createdBy",
	"created_by_type":         "Description.Topic.systemData.createdByType",
	"diagnostic_settings":     "Description.DiagnosticSettingsResources",
	"disable_local_auth":      "Description.Topic.properties.disableLocalAuth",
	"endpoint":                "Description.Topic.properties.endpoint",
	"extended_location":       "Description.Topic.location",
	"id":                      "Description.Topic.id",
	"identity":                "Description.Topic.Identity",
	"inbound_ip_rules":        "Description.Topic.Properties.InboundIPRules",
	"input_schema":            "Description.Topic.properties.inputSchema",
	"input_schema_mapping":    "Description.Topic.Properties.InputSchemaMapping",
	"kind":                    "Description.Topic.type",
	"last_modified_by":        "Description.Topic.systemData.lastModifiedBy",
	"last_modified_by_type":   "Description.Topic.systemData.lastModifiedByType",
	"location":                "Description.Topic.location",
	"name":                    "Description.Topic.name",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.Topic.properties.provisioningState",
	"public_network_access":   "Description.Topic.properties.publicNetworkAccess",
	"resource_group":          "Description.ResourceGroup",
	"sku_name":                "Description.Topic.name",
	"subscription":            "Description.Topic.Properties.Subscription",
	"tags":                    "Description.Topic.Tags",
	"title":                   "Description.Topic.name",
	"type":                    "Description.Topic.type",
}

func ListEventGridTopic(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEventGridTopic")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventGridTopic NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventGridTopic NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventGridTopic GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventGridTopic GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventGridTopic GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEventGridTopicPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEventGridTopicFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventGridTopic NewEventGridTopicPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEventGridTopic paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEventGridTopicFilters = map[string]string{
	"created_by":              "Description.Topic.systemData.createdBy",
	"created_by_type":         "Description.Topic.systemData.createdByType",
	"diagnostic_settings":     "Description.DiagnosticSettingsResources",
	"disable_local_auth":      "Description.Topic.properties.disableLocalAuth",
	"endpoint":                "Description.Topic.properties.endpoint",
	"extended_location":       "Description.Topic.location",
	"id":                      "Description.Topic.id",
	"identity":                "Description.Topic.Identity",
	"inbound_ip_rules":        "Description.Topic.Properties.InboundIPRules",
	"input_schema":            "Description.Topic.properties.inputSchema",
	"input_schema_mapping":    "Description.Topic.Properties.InputSchemaMapping",
	"kind":                    "Description.Topic.type",
	"last_modified_by":        "Description.Topic.systemData.lastModifiedBy",
	"last_modified_by_type":   "Description.Topic.systemData.lastModifiedByType",
	"location":                "Description.Topic.location",
	"name":                    "description.Topic.name",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.Topic.properties.provisioningState",
	"public_network_access":   "Description.Topic.properties.publicNetworkAccess",
	"resource_group":          "description.ResourceGroup",
	"sku_name":                "Description.Topic.name",
	"subscription":            "Description.Topic.Properties.Subscription",
	"tags":                    "Description.Topic.Tags",
	"title":                   "Description.Topic.name",
	"type":                    "Description.Topic.type",
}

func GetEventGridTopic(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEventGridTopic")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEventGridTopicPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEventGridTopicFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EventGridTopic =============================

// ==========================  START: EventhubNamespace =============================

type EventhubNamespace struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     azure.EventhubNamespaceDescription `json:"Description"`
	Metadata        azure.Metadata                     `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type EventhubNamespaceHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  EventhubNamespace `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type EventhubNamespaceHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []EventhubNamespaceHit `json:"hits"`
}

type EventhubNamespaceSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  EventhubNamespaceHits `json:"hits"`
}

type EventhubNamespacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEventhubNamespacePaginator(filters []essdk.BoolFilter, limit *int64) (EventhubNamespacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_eventhub_namespaces", filters, limit)
	if err != nil {
		return EventhubNamespacePaginator{}, err
	}

	p := EventhubNamespacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EventhubNamespacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EventhubNamespacePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EventhubNamespacePaginator) NextPage(ctx context.Context) ([]EventhubNamespace, error) {
	var response EventhubNamespaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EventhubNamespace
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEventhubNamespaceFilters = map[string]string{
	"cluster_arm_id":               "Description.EHNamespace.properties.clusterArmId",
	"diagnostic_settings":          "Description.DiagnosticSettingsResources",
	"encryption":                   "Description.EHNamespace.Properties.Encryption",
	"id":                           "Description.EHNamespace.id",
	"identity":                     "Description.EHNamespace.Properties.Encryption",
	"is_auto_inflate_enabled":      "Description.EHNamespace.properties.isAutoInflateEnabled",
	"kafka_enabled":                "Description.EHNamespace.properties.kafkaEnabled",
	"maximum_throughput_units":     "Description.EHNamespace.properties.maximumThroughputUnits",
	"metric_id":                    "Description.EHNamespace.properties.metricId",
	"name":                         "Description.EHNamespace.name",
	"network_rule_set":             "Description.NetworkRuleSet",
	"platform_integration_id":      "IntegrationID",
	"private_endpoint_connections": "Description.EHNamespace.Properties.PrivateEndpointConnections",
	"provisioning_state":           "Description.EHNamespace.properties.provisioningState",
	"resource_group":               "Description.ResourceGroup",
	"service_bus_endpoint":         "Description.EHNamespace.properties.serviceBusEndpoint",
	"sku_capacity":                 "Description.EHNamespace.sku.capacity",
	"sku_name":                     "Description.EHNamespace.sku.name",
	"sku_tier":                     "Description.EHNamespace.sku.tier",
	"subscription":                 "Description.EHNamespace.Properties.Subscription",
	"tags":                         "Description.EHNamespace.Tags",
	"title":                        "Description.EHNamespace.name",
	"type":                         "Description.EHNamespace.type",
	"zone_redundant":               "Description.EHNamespace.properties.zoneRedundant",
}

func ListEventhubNamespace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEventhubNamespace")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventhubNamespace NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventhubNamespace NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventhubNamespace GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventhubNamespace GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventhubNamespace GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEventhubNamespacePaginator(essdk.BuildFilter(ctx, d.QueryContext, listEventhubNamespaceFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventhubNamespace NewEventhubNamespacePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEventhubNamespace paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEventhubNamespaceFilters = map[string]string{
	"cluster_arm_id":               "Description.EHNamespace.properties.clusterArmId",
	"diagnostic_settings":          "Description.DiagnosticSettingsResources",
	"encryption":                   "Description.EHNamespace.Properties.Encryption",
	"id":                           "Description.EHNamespace.id",
	"identity":                     "Description.EHNamespace.Properties.Encryption",
	"is_auto_inflate_enabled":      "Description.EHNamespace.properties.isAutoInflateEnabled",
	"kafka_enabled":                "Description.EHNamespace.properties.kafkaEnabled",
	"maximum_throughput_units":     "Description.EHNamespace.properties.maximumThroughputUnits",
	"metric_id":                    "Description.EHNamespace.properties.metricId",
	"name":                         "description.EHNamespace.name",
	"network_rule_set":             "Description.NetworkRuleSet",
	"platform_integration_id":      "IntegrationID",
	"private_endpoint_connections": "Description.EHNamespace.Properties.PrivateEndpointConnections",
	"provisioning_state":           "Description.EHNamespace.properties.provisioningState",
	"resource_group":               "description.ResourceGroup",
	"service_bus_endpoint":         "Description.EHNamespace.properties.serviceBusEndpoint",
	"sku_capacity":                 "Description.EHNamespace.sku.capacity",
	"sku_name":                     "Description.EHNamespace.sku.name",
	"sku_tier":                     "Description.EHNamespace.sku.tier",
	"subscription":                 "Description.EHNamespace.Properties.Subscription",
	"tags":                         "Description.EHNamespace.Tags",
	"title":                        "Description.EHNamespace.name",
	"type":                         "Description.EHNamespace.type",
	"zone_redundant":               "Description.EHNamespace.properties.zoneRedundant",
}

func GetEventhubNamespace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEventhubNamespace")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEventhubNamespacePaginator(essdk.BuildFilter(ctx, d.QueryContext, getEventhubNamespaceFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EventhubNamespace =============================

// ==========================  START: EventhubNamespaceEventhub =============================

type EventhubNamespaceEventhub struct {
	ResourceID      string                                     `json:"resource_id"`
	PlatformID      string                                     `json:"platform_id"`
	Description     azure.EventhubNamespaceEventhubDescription `json:"Description"`
	Metadata        azure.Metadata                             `json:"metadata"`
	DescribedBy     string                                     `json:"described_by"`
	ResourceType    string                                     `json:"resource_type"`
	IntegrationType string                                     `json:"integration_type"`
	IntegrationID   string                                     `json:"integration_id"`
}

type EventhubNamespaceEventhubHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  EventhubNamespaceEventhub `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type EventhubNamespaceEventhubHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []EventhubNamespaceEventhubHit `json:"hits"`
}

type EventhubNamespaceEventhubSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  EventhubNamespaceEventhubHits `json:"hits"`
}

type EventhubNamespaceEventhubPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEventhubNamespaceEventhubPaginator(filters []essdk.BoolFilter, limit *int64) (EventhubNamespaceEventhubPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_eventhub_namespaces_eventhubs", filters, limit)
	if err != nil {
		return EventhubNamespaceEventhubPaginator{}, err
	}

	p := EventhubNamespaceEventhubPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EventhubNamespaceEventhubPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EventhubNamespaceEventhubPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EventhubNamespaceEventhubPaginator) NextPage(ctx context.Context) ([]EventhubNamespaceEventhub, error) {
	var response EventhubNamespaceEventhubSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EventhubNamespaceEventhub
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEventhubNamespaceEventhubFilters = map[string]string{
	"id":                      "Description.EventHub.id",
	"name":                    "Description.EHNamespace.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.EventHub.Properties.Subscription",
	"tags":                    "Description.EHNamespace.Tags",
	"title":                   "Description.EHNamespace.identity.type",
}

func ListEventhubNamespaceEventhub(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEventhubNamespaceEventhub")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventhubNamespaceEventhub NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventhubNamespaceEventhub NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventhubNamespaceEventhub GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventhubNamespaceEventhub GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventhubNamespaceEventhub GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEventhubNamespaceEventhubPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEventhubNamespaceEventhubFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEventhubNamespaceEventhub NewEventhubNamespaceEventhubPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEventhubNamespaceEventhub paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEventhubNamespaceEventhubFilters = map[string]string{
	"id":                      "Description.EventHub.id",
	"name":                    "Description.EHNamespace.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.EventHub.Properties.Subscription",
	"tags":                    "Description.EHNamespace.Tags",
	"title":                   "Description.EHNamespace.identity.type",
}

func GetEventhubNamespaceEventhub(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEventhubNamespaceEventhub")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEventhubNamespaceEventhubPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEventhubNamespaceEventhubFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EventhubNamespaceEventhub =============================

// ==========================  START: Frontdoor =============================

type Frontdoor struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     azure.FrontdoorDescription `json:"Description"`
	Metadata        azure.Metadata             `json:"metadata"`
	DescribedBy     string                     `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

type FrontdoorHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Frontdoor     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type FrontdoorHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []FrontdoorHit    `json:"hits"`
}

type FrontdoorSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  FrontdoorHits `json:"hits"`
}

type FrontdoorPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewFrontdoorPaginator(filters []essdk.BoolFilter, limit *int64) (FrontdoorPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_frontdoors", filters, limit)
	if err != nil {
		return FrontdoorPaginator{}, err
	}

	p := FrontdoorPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p FrontdoorPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p FrontdoorPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p FrontdoorPaginator) NextPage(ctx context.Context) ([]Frontdoor, error) {
	var response FrontdoorSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Frontdoor
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listFrontdoorFilters = map[string]string{
	"backend_pools":           "Description.FrontDoor.Properties.BackendPools",
	"backend_pools_settings":  "Description.FrontDoor.Properties.BackendPoolsSettings",
	"diagnostic_settings":     "Description.DiagnosticSettingsResources",
	"enabled_state":           "Description.FrontDoor.properties.enabledState",
	"friendly_name":           "Description.FrontDoor.properties.friendlyName",
	"front_door_id":           "Description.FrontDoor.properties.frontdoorId",
	"frontend_endpoints":      "Description.FrontDoor.Properties.FrontendEndpoints",
	"health_probe_settings":   "Description.FrontDoor.Properties.HealthProbeSettings",
	"id":                      "Description.FrontDoor.id",
	"load_balancing_settings": "Description.FrontDoor.Properties.LoadBalancingSettings",
	"name":                    "Description.FrontDoor.name",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.FrontDoor.properties.provisioningState",
	"resource_group":          "Description.ResourceGroup",
	"resource_state":          "Description.FrontDoor.properties.resourceState",
	"routing_rules":           "Description.FrontDoor.Properties.RoutingRules",
	"rules_engines":           "Description.FrontDoor.Properties.RulesEngines",
	"subscription":            "Description.FrontDoor.Properties.Subscription",
	"tags":                    "Description.FrontDoor.Tags",
	"title":                   "Description.FrontDoor.name",
	"type":                    "Description.FrontDoor.type",
}

func ListFrontdoor(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListFrontdoor")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListFrontdoor NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListFrontdoor NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListFrontdoor GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListFrontdoor GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListFrontdoor GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewFrontdoorPaginator(essdk.BuildFilter(ctx, d.QueryContext, listFrontdoorFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListFrontdoor NewFrontdoorPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListFrontdoor paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getFrontdoorFilters = map[string]string{
	"backend_pools":           "Description.FrontDoor.Properties.BackendPools",
	"backend_pools_settings":  "Description.FrontDoor.Properties.BackendPoolsSettings",
	"diagnostic_settings":     "Description.DiagnosticSettingsResources",
	"enabled_state":           "Description.FrontDoor.properties.enabledState",
	"friendly_name":           "Description.FrontDoor.properties.friendlyName",
	"front_door_id":           "Description.FrontDoor.properties.frontdoorId",
	"frontend_endpoints":      "Description.FrontDoor.Properties.FrontendEndpoints",
	"health_probe_settings":   "Description.FrontDoor.Properties.HealthProbeSettings",
	"id":                      "Description.FrontDoor.id",
	"load_balancing_settings": "Description.FrontDoor.Properties.LoadBalancingSettings",
	"name":                    "description.FrontDoor.name",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.FrontDoor.properties.provisioningState",
	"resource_group":          "description.ResourceGroup",
	"resource_state":          "Description.FrontDoor.properties.resourceState",
	"routing_rules":           "Description.FrontDoor.Properties.RoutingRules",
	"rules_engines":           "Description.FrontDoor.Properties.RulesEngines",
	"subscription":            "Description.FrontDoor.Properties.Subscription",
	"tags":                    "Description.FrontDoor.Tags",
	"title":                   "Description.FrontDoor.name",
	"type":                    "Description.FrontDoor.type",
}

func GetFrontdoor(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetFrontdoor")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewFrontdoorPaginator(essdk.BuildFilter(ctx, d.QueryContext, getFrontdoorFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Frontdoor =============================

// ==========================  START: HdinsightCluster =============================

type HdinsightCluster struct {
	ResourceID      string                            `json:"resource_id"`
	PlatformID      string                            `json:"platform_id"`
	Description     azure.HdinsightClusterDescription `json:"Description"`
	Metadata        azure.Metadata                    `json:"metadata"`
	DescribedBy     string                            `json:"described_by"`
	ResourceType    string                            `json:"resource_type"`
	IntegrationType string                            `json:"integration_type"`
	IntegrationID   string                            `json:"integration_id"`
}

type HdinsightClusterHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  HdinsightCluster `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type HdinsightClusterHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []HdinsightClusterHit `json:"hits"`
}

type HdinsightClusterSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  HdinsightClusterHits `json:"hits"`
}

type HdinsightClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewHdinsightClusterPaginator(filters []essdk.BoolFilter, limit *int64) (HdinsightClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_hdinsight_clusters", filters, limit)
	if err != nil {
		return HdinsightClusterPaginator{}, err
	}

	p := HdinsightClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p HdinsightClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p HdinsightClusterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p HdinsightClusterPaginator) NextPage(ctx context.Context) ([]HdinsightCluster, error) {
	var response HdinsightClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []HdinsightCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listHdinsightClusterFilters = map[string]string{
	"cluster_definition":               "Description.Cluster.Properties.ClusterDefinition",
	"cluster_hdp_version":              "Description.Cluster.properties.clusterHdpVersion",
	"cluster_id":                       "Description.Cluster.properties.clusterId",
	"cluster_state":                    "Description.Cluster.properties.clusterState",
	"cluster_version":                  "Description.Cluster.properties.clusterVersion",
	"compute_isolation_properties":     "Description.Cluster.Properties.ComputeIsolationProperties",
	"compute_profile":                  "Description.Cluster.Properties.ComputeProfile",
	"connectivity_endpoints":           "Description.Cluster.Properties.ConnectivityEndpoints",
	"created_date":                     "Description.Cluster.properties.createdDate",
	"diagnostic_settings":              "Description.DiagnosticSettingsResources",
	"disk_encryption_properties":       "Description.Cluster.Properties.DiskEncryptionProperties",
	"encryption_in_transit_properties": "Description.Cluster.Properties.EncryptionInTransitProperties",
	"errors":                           "Description.Cluster.Properties.Errors",
	"etag":                             "Description.Cluster.etag",
	"excluded_services_config":         "Description.Cluster.Properties.ExcludedServicesConfig",
	"id":                               "Description.Cluster.id",
	"identity":                         "Description.Cluster.Identity",
	"kafka_rest_properties":            "Description.Cluster.Properties.KafkaRestProperties",
	"min_supported_tls_version":        "Description.Cluster.properties.minSupportedTlsVersion",
	"name":                             "Description.Cluster.name",
	"network_properties":               "Description.Cluster.Properties.NetworkProperties",
	"os_type":                          "Description.Cluster.properties.osType",
	"platform_integration_id":          "IntegrationID",
	"provisioning_state":               "Description.Cluster.properties.provisioningState",
	"quota_info":                       "Description.Cluster.Properties.QuotaInfo",
	"resource_group":                   "Description.ResourceGroup",
	"security_profile":                 "Description.Cluster.Properties.SecurityProfile",
	"storage_profile":                  "Description.Cluster.Properties.StorageProfile",
	"subscription":                     "Description.Cluster.Properties.Subscription",
	"tags":                             "Description.Cluster.Tags",
	"tier":                             "Description.Cluster.properties.tier",
	"title":                            "Description.Cluster.name",
	"type":                             "Description.Cluster.type",
}

func ListHdinsightCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListHdinsightCluster")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListHdinsightCluster NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListHdinsightCluster NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListHdinsightCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListHdinsightCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListHdinsightCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewHdinsightClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listHdinsightClusterFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListHdinsightCluster NewHdinsightClusterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListHdinsightCluster paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getHdinsightClusterFilters = map[string]string{
	"cluster_definition":               "Description.Cluster.Properties.ClusterDefinition",
	"cluster_hdp_version":              "Description.Cluster.properties.clusterHdpVersion",
	"cluster_id":                       "Description.Cluster.properties.clusterId",
	"cluster_state":                    "Description.Cluster.properties.clusterState",
	"cluster_version":                  "Description.Cluster.properties.clusterVersion",
	"compute_isolation_properties":     "Description.Cluster.Properties.ComputeIsolationProperties",
	"compute_profile":                  "Description.Cluster.Properties.ComputeProfile",
	"connectivity_endpoints":           "Description.Cluster.Properties.ConnectivityEndpoints",
	"created_date":                     "Description.Cluster.properties.createdDate",
	"diagnostic_settings":              "Description.DiagnosticSettingsResources",
	"disk_encryption_properties":       "Description.Cluster.Properties.DiskEncryptionProperties",
	"encryption_in_transit_properties": "Description.Cluster.Properties.EncryptionInTransitProperties",
	"errors":                           "Description.Cluster.Properties.Errors",
	"etag":                             "Description.Cluster.etag",
	"excluded_services_config":         "Description.Cluster.Properties.ExcludedServicesConfig",
	"id":                               "Description.Cluster.id",
	"identity":                         "Description.Cluster.Identity",
	"kafka_rest_properties":            "Description.Cluster.Properties.KafkaRestProperties",
	"min_supported_tls_version":        "Description.Cluster.properties.minSupportedTlsVersion",
	"name":                             "description.Cluster.name",
	"network_properties":               "Description.Cluster.Properties.NetworkProperties",
	"os_type":                          "Description.Cluster.properties.osType",
	"platform_integration_id":          "IntegrationID",
	"provisioning_state":               "Description.Cluster.properties.provisioningState",
	"quota_info":                       "Description.Cluster.Properties.QuotaInfo",
	"resource_group":                   "description.ResourceGroup",
	"security_profile":                 "Description.Cluster.Properties.SecurityProfile",
	"storage_profile":                  "Description.Cluster.Properties.StorageProfile",
	"subscription":                     "Description.Cluster.Properties.Subscription",
	"tags":                             "Description.Cluster.Tags",
	"tier":                             "Description.Cluster.properties.tier",
	"title":                            "Description.Cluster.name",
	"type":                             "Description.Cluster.type",
}

func GetHdinsightCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetHdinsightCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewHdinsightClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getHdinsightClusterFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: HdinsightCluster =============================

// ==========================  START: HybridComputeMachine =============================

type HybridComputeMachine struct {
	ResourceID      string                                `json:"resource_id"`
	PlatformID      string                                `json:"platform_id"`
	Description     azure.HybridComputeMachineDescription `json:"Description"`
	Metadata        azure.Metadata                        `json:"metadata"`
	DescribedBy     string                                `json:"described_by"`
	ResourceType    string                                `json:"resource_type"`
	IntegrationType string                                `json:"integration_type"`
	IntegrationID   string                                `json:"integration_id"`
}

type HybridComputeMachineHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  HybridComputeMachine `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type HybridComputeMachineHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []HybridComputeMachineHit `json:"hits"`
}

type HybridComputeMachineSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  HybridComputeMachineHits `json:"hits"`
}

type HybridComputeMachinePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewHybridComputeMachinePaginator(filters []essdk.BoolFilter, limit *int64) (HybridComputeMachinePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_hybridcompute_machines", filters, limit)
	if err != nil {
		return HybridComputeMachinePaginator{}, err
	}

	p := HybridComputeMachinePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p HybridComputeMachinePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p HybridComputeMachinePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p HybridComputeMachinePaginator) NextPage(ctx context.Context) ([]HybridComputeMachine, error) {
	var response HybridComputeMachineSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []HybridComputeMachine
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listHybridComputeMachineFilters = map[string]string{
	"ad_fqdn":                       "Description.Machine.properties.adFqdn",
	"agent_version":                 "Description.Machine.properties.agentVersion",
	"client_public_key":             "Description.Machine.properties.clientPublicKey",
	"display_name":                  "Description.Machine.properties.displayName",
	"dns_fqdn":                      "Description.Machine.properties.dnsFqdn",
	"domain_name":                   "Description.Machine.properties.domainName",
	"error_details":                 "Description.Machine.Properties.ErrorDetails",
	"extensions":                    "Description.MachineExtensions",
	"id":                            "Description.Machine.id",
	"identity":                      "Description.Machine.Identity",
	"location_data":                 "Description.Machine.Properties.LocationData",
	"machine_fqdn":                  "Description.Machine.properties.machineFqdn",
	"machine_properties_extensions": "Description.Machine.Properties.Extensions",
	"name":                          "Description.Machine.name",
	"os_name":                       "Description.Machine.properties.osName",
	"os_profile":                    "Description.Machine.Properties.OSProfile",
	"os_sku":                        "Description.Machine.properties.osSku",
	"os_version":                    "Description.Machine.properties.osVersion",
	"platform_integration_id":       "IntegrationID",
	"provisioning_state":            "Description.Machine.properties.provisioningState",
	"resource_group":                "Description.ResourceGroup",
	"status":                        "Description.Machine.properties.status",
	"subscription":                  "Description.Machine.Properties.Subscription",
	"tags":                          "Description.Machine.Tags",
	"title":                         "Description.Machine.name",
	"type":                          "Description.Machine.type",
	"vm_id":                         "Description.Machine.properties.vmId",
	"vm_uuid":                       "Description.Machine.properties.vmUuid",
}

func ListHybridComputeMachine(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListHybridComputeMachine")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListHybridComputeMachine NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListHybridComputeMachine NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListHybridComputeMachine GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListHybridComputeMachine GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListHybridComputeMachine GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewHybridComputeMachinePaginator(essdk.BuildFilter(ctx, d.QueryContext, listHybridComputeMachineFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListHybridComputeMachine NewHybridComputeMachinePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListHybridComputeMachine paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getHybridComputeMachineFilters = map[string]string{
	"ad_fqdn":                       "Description.Machine.properties.adFqdn",
	"agent_version":                 "Description.Machine.properties.agentVersion",
	"client_public_key":             "Description.Machine.properties.clientPublicKey",
	"display_name":                  "Description.Machine.properties.displayName",
	"dns_fqdn":                      "Description.Machine.properties.dnsFqdn",
	"domain_name":                   "Description.Machine.properties.domainName",
	"error_details":                 "Description.Machine.Properties.ErrorDetails",
	"extensions":                    "Description.MachineExtensions",
	"id":                            "Description.Machine.id",
	"identity":                      "Description.Machine.Identity",
	"location_data":                 "Description.Machine.Properties.LocationData",
	"machine_fqdn":                  "Description.Machine.properties.machineFqdn",
	"machine_properties_extensions": "Description.Machine.Properties.Extensions",
	"name":                          "description.Machine.name",
	"os_name":                       "Description.Machine.properties.osName",
	"os_profile":                    "Description.Machine.Properties.OSProfile",
	"os_sku":                        "Description.Machine.properties.osSku",
	"os_version":                    "Description.Machine.properties.osVersion",
	"platform_integration_id":       "IntegrationID",
	"provisioning_state":            "Description.Machine.properties.provisioningState",
	"resource_group":                "description.ResourceGroup",
	"status":                        "Description.Machine.properties.status",
	"subscription":                  "Description.Machine.Properties.Subscription",
	"tags":                          "Description.Machine.Tags",
	"title":                         "Description.Machine.name",
	"type":                          "Description.Machine.type",
	"vm_id":                         "Description.Machine.properties.vmId",
	"vm_uuid":                       "Description.Machine.properties.vmUuid",
}

func GetHybridComputeMachine(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetHybridComputeMachine")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewHybridComputeMachinePaginator(essdk.BuildFilter(ctx, d.QueryContext, getHybridComputeMachineFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: HybridComputeMachine =============================

// ==========================  START: IOTHub =============================

type IOTHub struct {
	ResourceID      string                  `json:"resource_id"`
	PlatformID      string                  `json:"platform_id"`
	Description     azure.IOTHubDescription `json:"Description"`
	Metadata        azure.Metadata          `json:"metadata"`
	DescribedBy     string                  `json:"described_by"`
	ResourceType    string                  `json:"resource_type"`
	IntegrationType string                  `json:"integration_type"`
	IntegrationID   string                  `json:"integration_id"`
}

type IOTHubHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  IOTHub        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type IOTHubHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []IOTHubHit       `json:"hits"`
}

type IOTHubSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  IOTHubHits `json:"hits"`
}

type IOTHubPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIOTHubPaginator(filters []essdk.BoolFilter, limit *int64) (IOTHubPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_devices_iothubs", filters, limit)
	if err != nil {
		return IOTHubPaginator{}, err
	}

	p := IOTHubPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IOTHubPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IOTHubPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IOTHubPaginator) NextPage(ctx context.Context) ([]IOTHub, error) {
	var response IOTHubSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IOTHub
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIOTHubFilters = map[string]string{
	"authorization_policies":           "Description.IotHubDescription.Properties.AuthorizationPolicies",
	"cloud_to_device":                  "Description.IotHubDescription.Properties.CloudToDevice",
	"comments":                         "Description.IotHubDescription.properties.comments",
	"diagnostic_settings":              "Description.DiagnosticSettingsResources",
	"enable_file_upload_notifications": "Description.IotHubDescription.properties.enableFileUploadNotifications",
	"etag":                             "Description.IotHubDescription.etag",
	"event_hub_endpoints":              "Description.IotHubDescription.Properties.EventHubEndpoints",
	"features":                         "Description.IotHubDescription.properties.features",
	"host_name":                        "Description.IotHubDescription.properties.hostName",
	"id":                               "Description.IotHubDescription.id",
	"ip_filter_rules":                  "Description.IotHubDescription.Properties.IPFilterRules",
	"locations":                        "Description.IotHubDescription.Properties.Locations",
	"messaging_endpoints":              "Description.IotHubDescription.Properties.MessagingEndpoints",
	"min_tls_version":                  "Description.IotHubDescription.properties.minTlsVersion",
	"name":                             "Description.IotHubDescription.name",
	"platform_integration_id":          "IntegrationID",
	"private_endpoint_connections":     "Description.IotHubDescription.Properties.PrivateEndpointConnections",
	"provisioning_state":               "Description.IotHubDescription.properties.provisioningState",
	"public_network_access":            "Description.IotHubDescription.properties.publicNetworkAccess",
	"resource_group":                   "Description.ResourceGroup",
	"routing":                          "Description.IotHubDescription.Properties.Routing",
	"sku_capacity":                     "Description.IotHubDescription.sku.capacity",
	"sku_name":                         "Description.IotHubDescription.sku.name",
	"sku_tier":                         "Description.IotHubDescription.sku.tier",
	"state":                            "Description.IotHubDescription.properties.state",
	"storage_endpoints":                "Description.IotHubDescription.Properties.StorageEndpoints",
	"subscription":                     "Description.IotHubDescription.Properties.Subscription",
	"tags":                             "Description.IotHubDescription.Tags",
	"title":                            "Description.IotHubDescription.name",
	"type":                             "Description.IotHubDescription.type",
}

func ListIOTHub(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIOTHub")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIOTHub NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIOTHub NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIOTHub GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIOTHub GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIOTHub GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIOTHubPaginator(essdk.BuildFilter(ctx, d.QueryContext, listIOTHubFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIOTHub NewIOTHubPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIOTHub paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIOTHubFilters = map[string]string{
	"authorization_policies":           "Description.IotHubDescription.Properties.AuthorizationPolicies",
	"cloud_to_device":                  "Description.IotHubDescription.Properties.CloudToDevice",
	"comments":                         "Description.IotHubDescription.properties.comments",
	"diagnostic_settings":              "Description.DiagnosticSettingsResources",
	"enable_file_upload_notifications": "Description.IotHubDescription.properties.enableFileUploadNotifications",
	"etag":                             "Description.IotHubDescription.etag",
	"event_hub_endpoints":              "Description.IotHubDescription.Properties.EventHubEndpoints",
	"features":                         "Description.IotHubDescription.properties.features",
	"host_name":                        "Description.IotHubDescription.properties.hostName",
	"id":                               "Description.IotHubDescription.id",
	"ip_filter_rules":                  "Description.IotHubDescription.Properties.IPFilterRules",
	"locations":                        "Description.IotHubDescription.Properties.Locations",
	"messaging_endpoints":              "Description.IotHubDescription.Properties.MessagingEndpoints",
	"min_tls_version":                  "Description.IotHubDescription.properties.minTlsVersion",
	"name":                             "description.IotHubDescription.name",
	"platform_integration_id":          "IntegrationID",
	"private_endpoint_connections":     "Description.IotHubDescription.Properties.PrivateEndpointConnections",
	"provisioning_state":               "Description.IotHubDescription.properties.provisioningState",
	"public_network_access":            "Description.IotHubDescription.properties.publicNetworkAccess",
	"resource_group":                   "description.ResourceGroup",
	"routing":                          "Description.IotHubDescription.Properties.Routing",
	"sku_capacity":                     "Description.IotHubDescription.sku.capacity",
	"sku_name":                         "Description.IotHubDescription.sku.name",
	"sku_tier":                         "Description.IotHubDescription.sku.tier",
	"state":                            "Description.IotHubDescription.properties.state",
	"storage_endpoints":                "Description.IotHubDescription.Properties.StorageEndpoints",
	"subscription":                     "Description.IotHubDescription.Properties.Subscription",
	"tags":                             "Description.IotHubDescription.Tags",
	"title":                            "Description.IotHubDescription.name",
	"type":                             "Description.IotHubDescription.type",
}

func GetIOTHub(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIOTHub")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIOTHubPaginator(essdk.BuildFilter(ctx, d.QueryContext, getIOTHubFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IOTHub =============================

// ==========================  START: IOTHubDps =============================

type IOTHubDps struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     azure.IOTHubDpsDescription `json:"Description"`
	Metadata        azure.Metadata             `json:"metadata"`
	DescribedBy     string                     `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

type IOTHubDpsHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  IOTHubDps     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type IOTHubDpsHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []IOTHubDpsHit    `json:"hits"`
}

type IOTHubDpsSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  IOTHubDpsHits `json:"hits"`
}

type IOTHubDpsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIOTHubDpsPaginator(filters []essdk.BoolFilter, limit *int64) (IOTHubDpsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_devices_provisioningservices", filters, limit)
	if err != nil {
		return IOTHubDpsPaginator{}, err
	}

	p := IOTHubDpsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IOTHubDpsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IOTHubDpsPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p IOTHubDpsPaginator) NextPage(ctx context.Context) ([]IOTHubDps, error) {
	var response IOTHubDpsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IOTHubDps
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIOTHubDpsFilters = map[string]string{
	"allocation_policy":             "Description.IotHubDps.properties.allocationPolicy",
	"authorization_policies":        "Description.IotHubDps.Properties.AuthorizationPolicies",
	"device_provisioning_host_name": "Description.IotHubDps.properties.deviceProvisioningHostName",
	"diagnostic_settings":           "Description.DiagnosticSettingsResources",
	"etag":                          "Description.IotHubDps.etag",
	"id":                            "Description.IotHubDps.id",
	"id_scope":                      "Description.IotHubDps.properties.idScope",
	"iot_hubs":                      "Description.IotHubDps.Properties.IotHubs",
	"name":                          "Description.IotHubDps.name",
	"platform_integration_id":       "IntegrationID",
	"provisioning_state":            "Description.IotHubDps.properties.provisioningState",
	"resource_group":                "Description.ResourceGroup",
	"service_operations_host_name":  "Description.IotHubDps.properties.serviceOperationsHostName",
	"sku_capacity":                  "Description.IotHubDps.sku.capacity",
	"sku_name":                      "Description.IotHubDps.sku.name",
	"sku_tier":                      "Description.IotHubDps.sku.tier",
	"state":                         "Description.IotHubDps.properties.state",
	"subscription":                  "Description.IotHubDps.Properties.Subscription",
	"tags":                          "Description.IotHubDps.Tags",
	"title":                         "Description.IotHubDps.name",
	"type":                          "Description.IotHubDps.type",
}

func ListIOTHubDps(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIOTHubDps")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListIOTHubDps NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListIOTHubDps NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListIOTHubDps GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListIOTHubDps GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListIOTHubDps GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewIOTHubDpsPaginator(essdk.BuildFilter(ctx, d.QueryContext, listIOTHubDpsFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListIOTHubDps NewIOTHubDpsPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListIOTHubDps paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getIOTHubDpsFilters = map[string]string{
	"allocation_policy":             "Description.IotHubDps.properties.allocationPolicy",
	"authorization_policies":        "Description.IotHubDps.Properties.AuthorizationPolicies",
	"device_provisioning_host_name": "Description.IotHubDps.properties.deviceProvisioningHostName",
	"diagnostic_settings":           "Description.DiagnosticSettingsResources",
	"etag":                          "Description.IotHubDps.etag",
	"id":                            "Description.IotHubDps.id",
	"id_scope":                      "Description.IotHubDps.properties.idScope",
	"iot_hubs":                      "Description.IotHubDps.Properties.IotHubs",
	"name":                          "description.IotHubDps.name",
	"platform_integration_id":       "IntegrationID",
	"provisioning_state":            "Description.IotHubDps.properties.provisioningState",
	"resource_group":                "description.ResourceGroup",
	"service_operations_host_name":  "Description.IotHubDps.properties.serviceOperationsHostName",
	"sku_capacity":                  "Description.IotHubDps.sku.capacity",
	"sku_name":                      "Description.IotHubDps.sku.name",
	"sku_tier":                      "Description.IotHubDps.sku.tier",
	"state":                         "Description.IotHubDps.properties.state",
	"subscription":                  "Description.IotHubDps.Properties.Subscription",
	"tags":                          "Description.IotHubDps.Tags",
	"title":                         "Description.IotHubDps.name",
	"type":                          "Description.IotHubDps.type",
}

func GetIOTHubDps(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIOTHubDps")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewIOTHubDpsPaginator(essdk.BuildFilter(ctx, d.QueryContext, getIOTHubDpsFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: IOTHubDps =============================

// ==========================  START: KeyVault =============================

type KeyVault struct {
	ResourceID      string                    `json:"resource_id"`
	PlatformID      string                    `json:"platform_id"`
	Description     azure.KeyVaultDescription `json:"Description"`
	Metadata        azure.Metadata            `json:"metadata"`
	DescribedBy     string                    `json:"described_by"`
	ResourceType    string                    `json:"resource_type"`
	IntegrationType string                    `json:"integration_type"`
	IntegrationID   string                    `json:"integration_id"`
}

type KeyVaultHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  KeyVault      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type KeyVaultHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []KeyVaultHit     `json:"hits"`
}

type KeyVaultSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  KeyVaultHits `json:"hits"`
}

type KeyVaultPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKeyVaultPaginator(filters []essdk.BoolFilter, limit *int64) (KeyVaultPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_keyvault_vaults", filters, limit)
	if err != nil {
		return KeyVaultPaginator{}, err
	}

	p := KeyVaultPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KeyVaultPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KeyVaultPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p KeyVaultPaginator) NextPage(ctx context.Context) ([]KeyVault, error) {
	var response KeyVaultSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KeyVault
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKeyVaultFilters = map[string]string{
	"create_mode":                     "Description.Vault.properties.createMode",
	"diagnostic_settings":             "Description.DiagnosticSettingsResources",
	"enable_rbac_authorization":       "Description.Vault.properties.enableRbacAuthorization",
	"enabled_for_deployment":          "Description.Vault.properties.enabledForDeployment",
	"enabled_for_disk_encryption":     "Description.Vault.properties.enabledForDiskEncryption",
	"enabled_for_template_deployment": "Description.Vault.properties.enabledForTemplateDeployment",
	"id":                              "Description.Vault.id",
	"name":                            "Description.Vault.name",
	"network_acls":                    "Description.Vault.Properties.NetworkACLs",
	"platform_integration_id":         "IntegrationID",
	"purge_protection_enabled":        "Description.Vault.properties.enablePurgeProtection",
	"resource_group":                  "Description.ResourceGroup",
	"sku_family":                      "Description.Vault.properties.sku.family",
	"sku_name":                        "Description.Vault.properties.sku.name",
	"soft_delete_enabled":             "Description.Vault.properties.enableSoftDelete",
	"soft_delete_retention_in_days":   "Description.Vault.properties.softDeleteRetentionInDays",
	"subscription":                    "Description.Vault.Properties.Subscription",
	"tags":                            "Description.Vault.Tags",
	"tenant_id":                       "Description.Vault.properties.tenantId",
	"title":                           "Description.Vault.name",
	"type":                            "Description.Vault.type",
	"vault_uri":                       "Description.Vault.properties.vaultUri",
}

func ListKeyVault(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKeyVault")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVault NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVault NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVault GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVault GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVault GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewKeyVaultPaginator(essdk.BuildFilter(ctx, d.QueryContext, listKeyVaultFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVault NewKeyVaultPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListKeyVault paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getKeyVaultFilters = map[string]string{
	"create_mode":                     "Description.Vault.properties.createMode",
	"diagnostic_settings":             "Description.DiagnosticSettingsResources",
	"enable_rbac_authorization":       "Description.Vault.properties.enableRbacAuthorization",
	"enabled_for_deployment":          "Description.Vault.properties.enabledForDeployment",
	"enabled_for_disk_encryption":     "Description.Vault.properties.enabledForDiskEncryption",
	"enabled_for_template_deployment": "Description.Vault.properties.enabledForTemplateDeployment",
	"id":                              "Description.Vault.id",
	"name":                            "description.Resource.name",
	"network_acls":                    "Description.Vault.Properties.NetworkACLs",
	"platform_integration_id":         "IntegrationID",
	"purge_protection_enabled":        "Description.Vault.properties.enablePurgeProtection",
	"resource_group":                  "description.ResourceGroup",
	"sku_family":                      "Description.Vault.properties.sku.family",
	"sku_name":                        "Description.Vault.properties.sku.name",
	"soft_delete_enabled":             "Description.Vault.properties.enableSoftDelete",
	"soft_delete_retention_in_days":   "Description.Vault.properties.softDeleteRetentionInDays",
	"subscription":                    "Description.Vault.Properties.Subscription",
	"tags":                            "Description.Vault.Tags",
	"tenant_id":                       "Description.Vault.properties.tenantId",
	"title":                           "Description.Vault.name",
	"type":                            "Description.Vault.type",
	"vault_uri":                       "Description.Vault.properties.vaultUri",
}

func GetKeyVault(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKeyVault")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewKeyVaultPaginator(essdk.BuildFilter(ctx, d.QueryContext, getKeyVaultFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: KeyVault =============================

// ==========================  START: KeyVaultCertificate =============================

type KeyVaultCertificate struct {
	ResourceID      string                               `json:"resource_id"`
	PlatformID      string                               `json:"platform_id"`
	Description     azure.KeyVaultCertificateDescription `json:"Description"`
	Metadata        azure.Metadata                       `json:"metadata"`
	DescribedBy     string                               `json:"described_by"`
	ResourceType    string                               `json:"resource_type"`
	IntegrationType string                               `json:"integration_type"`
	IntegrationID   string                               `json:"integration_id"`
}

type KeyVaultCertificateHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  KeyVaultCertificate `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type KeyVaultCertificateHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []KeyVaultCertificateHit `json:"hits"`
}

type KeyVaultCertificateSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  KeyVaultCertificateHits `json:"hits"`
}

type KeyVaultCertificatePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKeyVaultCertificatePaginator(filters []essdk.BoolFilter, limit *int64) (KeyVaultCertificatePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_keyvault_vaults_certificates", filters, limit)
	if err != nil {
		return KeyVaultCertificatePaginator{}, err
	}

	p := KeyVaultCertificatePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KeyVaultCertificatePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KeyVaultCertificatePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p KeyVaultCertificatePaginator) NextPage(ctx context.Context) ([]KeyVaultCertificate, error) {
	var response KeyVaultCertificateSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KeyVaultCertificate
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKeyVaultCertificateFilters = map[string]string{
	"attributes":              "Description.Policy.Attributes",
	"id":                      "Description.Policy.id",
	"issuer_parameters":       "Description.Policy.IssuerParameters",
	"key_properties":          "Description.Policy.KeyProperties",
	"lifetime_actions":        "Description.Policy.LifetimeActions",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "Description.ResourceGroup",
	"secret_properties":       "Description.Policy.SecretProperties",
	"subscription":            "Description.Policy.Properties.Subscription",
	"tags":                    "Description.Policy.Tags",
	"vault_name":              "Description.Vault.name",
}

func ListKeyVaultCertificate(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKeyVaultCertificate")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultCertificate NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultCertificate NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultCertificate GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultCertificate GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultCertificate GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewKeyVaultCertificatePaginator(essdk.BuildFilter(ctx, d.QueryContext, listKeyVaultCertificateFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultCertificate NewKeyVaultCertificatePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListKeyVaultCertificate paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getKeyVaultCertificateFilters = map[string]string{
	"attributes":              "Description.Policy.Attributes",
	"id":                      "Description.Policy.id",
	"issuer_parameters":       "Description.Policy.IssuerParameters",
	"key_properties":          "Description.Policy.KeyProperties",
	"lifetime_actions":        "Description.Policy.LifetimeActions",
	"name":                    "description.Resource.name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "description.ResourceGroup",
	"secret_properties":       "Description.Policy.SecretProperties",
	"subscription":            "Description.Policy.Properties.Subscription",
	"tags":                    "Description.Policy.Tags",
	"vault_name":              "Description.Vault.name",
}

func GetKeyVaultCertificate(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKeyVaultCertificate")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewKeyVaultCertificatePaginator(essdk.BuildFilter(ctx, d.QueryContext, getKeyVaultCertificateFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: KeyVaultCertificate =============================

// ==========================  START: KeyVaultDeletedVault =============================

type KeyVaultDeletedVault struct {
	ResourceID      string                                `json:"resource_id"`
	PlatformID      string                                `json:"platform_id"`
	Description     azure.KeyVaultDeletedVaultDescription `json:"Description"`
	Metadata        azure.Metadata                        `json:"metadata"`
	DescribedBy     string                                `json:"described_by"`
	ResourceType    string                                `json:"resource_type"`
	IntegrationType string                                `json:"integration_type"`
	IntegrationID   string                                `json:"integration_id"`
}

type KeyVaultDeletedVaultHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  KeyVaultDeletedVault `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type KeyVaultDeletedVaultHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []KeyVaultDeletedVaultHit `json:"hits"`
}

type KeyVaultDeletedVaultSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  KeyVaultDeletedVaultHits `json:"hits"`
}

type KeyVaultDeletedVaultPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKeyVaultDeletedVaultPaginator(filters []essdk.BoolFilter, limit *int64) (KeyVaultDeletedVaultPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_keyvault_deletedvaults", filters, limit)
	if err != nil {
		return KeyVaultDeletedVaultPaginator{}, err
	}

	p := KeyVaultDeletedVaultPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KeyVaultDeletedVaultPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KeyVaultDeletedVaultPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p KeyVaultDeletedVaultPaginator) NextPage(ctx context.Context) ([]KeyVaultDeletedVault, error) {
	var response KeyVaultDeletedVaultSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KeyVaultDeletedVault
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKeyVaultDeletedVaultFilters = map[string]string{
	"id":                      "Description.Vault.id",
	"name":                    "Description.Vault.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Vault.Properties.Subscription",
	"tags":                    "Description.Vault.Properties.Tags",
	"title":                   "Description.Vault.name",
	"type":                    "Description.Vault.type",
	"vault_id":                "Description.Vault.properties.vaultId",
}

func ListKeyVaultDeletedVault(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKeyVaultDeletedVault")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultDeletedVault NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultDeletedVault NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultDeletedVault GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultDeletedVault GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultDeletedVault GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewKeyVaultDeletedVaultPaginator(essdk.BuildFilter(ctx, d.QueryContext, listKeyVaultDeletedVaultFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultDeletedVault NewKeyVaultDeletedVaultPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListKeyVaultDeletedVault paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getKeyVaultDeletedVaultFilters = map[string]string{
	"id":                      "Description.Vault.id",
	"name":                    "description.Vault.name",
	"platform_integration_id": "IntegrationID",
	"region":                  "description.Vault.Properties.Location",
	"subscription":            "Description.Vault.Properties.Subscription",
	"tags":                    "Description.Vault.Properties.Tags",
	"title":                   "Description.Vault.name",
	"type":                    "Description.Vault.type",
	"vault_id":                "Description.Vault.properties.vaultId",
}

func GetKeyVaultDeletedVault(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKeyVaultDeletedVault")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewKeyVaultDeletedVaultPaginator(essdk.BuildFilter(ctx, d.QueryContext, getKeyVaultDeletedVaultFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: KeyVaultDeletedVault =============================

// ==========================  START: KeyVaultManagedHardwareSecurityModule =============================

type KeyVaultManagedHardwareSecurityModule struct {
	ResourceID      string                                                 `json:"resource_id"`
	PlatformID      string                                                 `json:"platform_id"`
	Description     azure.KeyVaultManagedHardwareSecurityModuleDescription `json:"Description"`
	Metadata        azure.Metadata                                         `json:"metadata"`
	DescribedBy     string                                                 `json:"described_by"`
	ResourceType    string                                                 `json:"resource_type"`
	IntegrationType string                                                 `json:"integration_type"`
	IntegrationID   string                                                 `json:"integration_id"`
}

type KeyVaultManagedHardwareSecurityModuleHit struct {
	ID      string                                `json:"_id"`
	Score   float64                               `json:"_score"`
	Index   string                                `json:"_index"`
	Type    string                                `json:"_type"`
	Version int64                                 `json:"_version,omitempty"`
	Source  KeyVaultManagedHardwareSecurityModule `json:"_source"`
	Sort    []interface{}                         `json:"sort"`
}

type KeyVaultManagedHardwareSecurityModuleHits struct {
	Total essdk.SearchTotal                          `json:"total"`
	Hits  []KeyVaultManagedHardwareSecurityModuleHit `json:"hits"`
}

type KeyVaultManagedHardwareSecurityModuleSearchResponse struct {
	PitID string                                    `json:"pit_id"`
	Hits  KeyVaultManagedHardwareSecurityModuleHits `json:"hits"`
}

type KeyVaultManagedHardwareSecurityModulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKeyVaultManagedHardwareSecurityModulePaginator(filters []essdk.BoolFilter, limit *int64) (KeyVaultManagedHardwareSecurityModulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_keyvault_managedhsms", filters, limit)
	if err != nil {
		return KeyVaultManagedHardwareSecurityModulePaginator{}, err
	}

	p := KeyVaultManagedHardwareSecurityModulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KeyVaultManagedHardwareSecurityModulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KeyVaultManagedHardwareSecurityModulePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p KeyVaultManagedHardwareSecurityModulePaginator) NextPage(ctx context.Context) ([]KeyVaultManagedHardwareSecurityModule, error) {
	var response KeyVaultManagedHardwareSecurityModuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KeyVaultManagedHardwareSecurityModule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKeyVaultManagedHardwareSecurityModuleFilters = map[string]string{
	"create_mode":                   "Description.ManagedHsm.properties.createMode",
	"diagnostic_settings":           "Description.DiagnosticSettingsResources",
	"enable_purge_protection":       "Description.ManagedHsm.properties.enablePurgeProtection",
	"enable_soft_delete":            "Description.ManagedHsm.properties.enableSoftDelete",
	"hsm_uri":                       "Description.ManagedHsm.properties.hsmUri",
	"id":                            "Description.ManagedHsm.id",
	"name":                          "Description.ManagedHsm.name",
	"platform_integration_id":       "IntegrationID",
	"provisioning_state":            "Description.ManagedHsm.properties.provisioningState",
	"resource_group":                "Description.ResourceGroup",
	"sku_family":                    "Description.ManagedHsm.sku.family",
	"sku_name":                      "Description.ManagedHsm.sku.name",
	"soft_delete_retention_in_days": "Description.ManagedHsm.properties.softDeleteRetentionInDays",
	"status_message":                "Description.ManagedHsm.properties.statusMessage",
	"subscription":                  "Description.ManagedHsm.Properties.Subscription",
	"tags":                          "Description.ManagedHsm.Tags",
	"tenant_id":                     "Description.ManagedHsm.properties.tenantId",
	"title":                         "Description.ManagedHsm.name",
	"type":                          "Description.ManagedHsm.type",
}

func ListKeyVaultManagedHardwareSecurityModule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKeyVaultManagedHardwareSecurityModule")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultManagedHardwareSecurityModule NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultManagedHardwareSecurityModule NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultManagedHardwareSecurityModule GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultManagedHardwareSecurityModule GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultManagedHardwareSecurityModule GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewKeyVaultManagedHardwareSecurityModulePaginator(essdk.BuildFilter(ctx, d.QueryContext, listKeyVaultManagedHardwareSecurityModuleFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultManagedHardwareSecurityModule NewKeyVaultManagedHardwareSecurityModulePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListKeyVaultManagedHardwareSecurityModule paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getKeyVaultManagedHardwareSecurityModuleFilters = map[string]string{
	"create_mode":                   "Description.ManagedHsm.properties.createMode",
	"diagnostic_settings":           "Description.DiagnosticSettingsResources",
	"enable_purge_protection":       "Description.ManagedHsm.properties.enablePurgeProtection",
	"enable_soft_delete":            "Description.ManagedHsm.properties.enableSoftDelete",
	"hsm_uri":                       "Description.ManagedHsm.properties.hsmUri",
	"id":                            "Description.ManagedHsm.id",
	"name":                          "description.ManagedHsm.name",
	"platform_integration_id":       "IntegrationID",
	"provisioning_state":            "Description.ManagedHsm.properties.provisioningState",
	"resource_group":                "description.ResourceGroup",
	"sku_family":                    "Description.ManagedHsm.sku.family",
	"sku_name":                      "Description.ManagedHsm.sku.name",
	"soft_delete_retention_in_days": "Description.ManagedHsm.properties.softDeleteRetentionInDays",
	"status_message":                "Description.ManagedHsm.properties.statusMessage",
	"subscription":                  "Description.ManagedHsm.Properties.Subscription",
	"tags":                          "Description.ManagedHsm.Tags",
	"tenant_id":                     "Description.ManagedHsm.properties.tenantId",
	"title":                         "Description.ManagedHsm.name",
	"type":                          "Description.ManagedHsm.type",
}

func GetKeyVaultManagedHardwareSecurityModule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKeyVaultManagedHardwareSecurityModule")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewKeyVaultManagedHardwareSecurityModulePaginator(essdk.BuildFilter(ctx, d.QueryContext, getKeyVaultManagedHardwareSecurityModuleFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: KeyVaultManagedHardwareSecurityModule =============================

// ==========================  START: KeyVaultSecret =============================

type KeyVaultSecret struct {
	ResourceID      string                          `json:"resource_id"`
	PlatformID      string                          `json:"platform_id"`
	Description     azure.KeyVaultSecretDescription `json:"Description"`
	Metadata        azure.Metadata                  `json:"metadata"`
	DescribedBy     string                          `json:"described_by"`
	ResourceType    string                          `json:"resource_type"`
	IntegrationType string                          `json:"integration_type"`
	IntegrationID   string                          `json:"integration_id"`
}

type KeyVaultSecretHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  KeyVaultSecret `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type KeyVaultSecretHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []KeyVaultSecretHit `json:"hits"`
}

type KeyVaultSecretSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  KeyVaultSecretHits `json:"hits"`
}

type KeyVaultSecretPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKeyVaultSecretPaginator(filters []essdk.BoolFilter, limit *int64) (KeyVaultSecretPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_keyvault_vaults_secrets", filters, limit)
	if err != nil {
		return KeyVaultSecretPaginator{}, err
	}

	p := KeyVaultSecretPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KeyVaultSecretPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KeyVaultSecretPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p KeyVaultSecretPaginator) NextPage(ctx context.Context) ([]KeyVaultSecret, error) {
	var response KeyVaultSecretSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KeyVaultSecret
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKeyVaultSecretFilters = map[string]string{
	"akas":                    "Description.TurboData.Akas",
	"content_type":            "Description.SecretItem.properties.contentType",
	"enabled":                 "Description.SecretItem.properties.attributes.enabled",
	"id":                      "Description.SecretItem.id",
	"kid":                     "Description.SecretBundle.Kid",
	"name":                    "Description.SecretItem.name",
	"platform_integration_id": "IntegrationID",
	"recoverable_days":        "Description.Vault.properties.softDeleteRetentionInDays",
	"resource_group":          "Description.TurboData.ResourceGroup",
	"subscription":            "Description.SecretItem.Properties.Subscription",
	"tags":                    "Description.SecretItem.Tags",
	"value":                   "Description.SecretItem.properties.value",
}

func ListKeyVaultSecret(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKeyVaultSecret")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultSecret NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultSecret NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultSecret GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultSecret GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultSecret GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewKeyVaultSecretPaginator(essdk.BuildFilter(ctx, d.QueryContext, listKeyVaultSecretFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListKeyVaultSecret NewKeyVaultSecretPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListKeyVaultSecret paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getKeyVaultSecretFilters = map[string]string{
	"akas":                    "Description.TurboData.Akas",
	"content_type":            "Description.SecretItem.properties.contentType",
	"enabled":                 "Description.SecretItem.properties.attributes.enabled",
	"id":                      "Description.SecretItem.id",
	"kid":                     "Description.SecretBundle.Kid",
	"name":                    "description.SecretItem.name",
	"platform_integration_id": "IntegrationID",
	"recoverable_days":        "Description.Vault.properties.softDeleteRetentionInDays",
	"resource_group":          "description.ResourceGroup",
	"subscription":            "Description.SecretItem.Properties.Subscription",
	"tags":                    "Description.SecretItem.Tags",
	"value":                   "Description.SecretItem.properties.value",
}

func GetKeyVaultSecret(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKeyVaultSecret")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewKeyVaultSecretPaginator(essdk.BuildFilter(ctx, d.QueryContext, getKeyVaultSecretFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: KeyVaultSecret =============================

// ==========================  START: KustoCluster =============================

type KustoCluster struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     azure.KustoClusterDescription `json:"Description"`
	Metadata        azure.Metadata                `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type KustoClusterHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  KustoCluster  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type KustoClusterHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []KustoClusterHit `json:"hits"`
}

type KustoClusterSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  KustoClusterHits `json:"hits"`
}

type KustoClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKustoClusterPaginator(filters []essdk.BoolFilter, limit *int64) (KustoClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_kusto_clusters", filters, limit)
	if err != nil {
		return KustoClusterPaginator{}, err
	}

	p := KustoClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KustoClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KustoClusterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p KustoClusterPaginator) NextPage(ctx context.Context) ([]KustoCluster, error) {
	var response KustoClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KustoCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKustoClusterFilters = map[string]string{
	"data_ingestion_uri":            "Description.Cluster.properties.dataIngestionUri",
	"enable_disk_encryption":        "Description.Cluster.properties.enableDiskEncryption",
	"enable_double_encryption":      "Description.Cluster.properties.enableDoubleEncryption",
	"enable_purge":                  "Description.Cluster.properties.enablePurge",
	"enable_streaming_ingest":       "Description.Cluster.properties.enableStreamingIngest",
	"engine_type":                   "Description.Cluster.properties.engineType",
	"etag":                          "Description.Cluster.etag",
	"id":                            "Description.Cluster.id",
	"identity":                      "Description.Cluster.Identity",
	"key_vault_properties":          "Description.Cluster.Properties.KeyVaultProperties",
	"language_extensions":           "Description.Cluster.Properties.LanguageExtensions",
	"location":                      "Description.Cluster.location",
	"name":                          "Description.Cluster.name",
	"optimized_autoscale":           "Description.Cluster.Properties.OptimizedAutoscale",
	"platform_integration_id":       "IntegrationID",
	"provisioning_state":            "Description.Cluster.properties.provisioningState",
	"resource_group":                "Description.ResourceGroup",
	"sku_capacity":                  "Description.Cluster.sku.capacity",
	"sku_name":                      "Description.Cluster.sku.name",
	"sku_tier":                      "Description.Cluster.sku.tier",
	"state":                         "Description.Cluster.properties.state",
	"state_reason":                  "Description.Cluster.properties.stateReason",
	"subscription":                  "Description.Cluster.Properties.Subscription",
	"tags":                          "Description.Cluster.Tags",
	"title":                         "Description.Cluster.name",
	"trusted_external_tenants":      "Description.Cluster.Properties.TrustedExternalTenants",
	"type":                          "Description.Cluster.type",
	"uri":                           "Description.Cluster.properties.uri",
	"virtual_network_configuration": "Description.Cluster.Properties.VirtualNetworkConfiguration",
}

func ListKustoCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKustoCluster")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListKustoCluster NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListKustoCluster NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListKustoCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListKustoCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListKustoCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewKustoClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listKustoClusterFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListKustoCluster NewKustoClusterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListKustoCluster paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getKustoClusterFilters = map[string]string{
	"data_ingestion_uri":            "Description.Cluster.properties.dataIngestionUri",
	"enable_disk_encryption":        "Description.Cluster.properties.enableDiskEncryption",
	"enable_double_encryption":      "Description.Cluster.properties.enableDoubleEncryption",
	"enable_purge":                  "Description.Cluster.properties.enablePurge",
	"enable_streaming_ingest":       "Description.Cluster.properties.enableStreamingIngest",
	"engine_type":                   "Description.Cluster.properties.engineType",
	"etag":                          "Description.Cluster.etag",
	"id":                            "Description.Cluster.id",
	"identity":                      "Description.Cluster.Identity",
	"key_vault_properties":          "Description.Cluster.Properties.KeyVaultProperties",
	"language_extensions":           "Description.Cluster.Properties.LanguageExtensions",
	"location":                      "Description.Cluster.location",
	"name":                          "description.Cluster.name",
	"optimized_autoscale":           "Description.Cluster.Properties.OptimizedAutoscale",
	"platform_integration_id":       "IntegrationID",
	"provisioning_state":            "Description.Cluster.properties.provisioningState",
	"resource_group":                "description.ResourceGroup",
	"sku_capacity":                  "Description.Cluster.sku.capacity",
	"sku_name":                      "Description.Cluster.sku.name",
	"sku_tier":                      "Description.Cluster.sku.tier",
	"state":                         "Description.Cluster.properties.state",
	"state_reason":                  "Description.Cluster.properties.stateReason",
	"subscription":                  "Description.Cluster.Properties.Subscription",
	"tags":                          "Description.Cluster.Tags",
	"title":                         "Description.Cluster.name",
	"trusted_external_tenants":      "Description.Cluster.Properties.TrustedExternalTenants",
	"type":                          "Description.Cluster.type",
	"uri":                           "Description.Cluster.properties.uri",
	"virtual_network_configuration": "Description.Cluster.Properties.VirtualNetworkConfiguration",
}

func GetKustoCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKustoCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewKustoClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getKustoClusterFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: KustoCluster =============================

// ==========================  START: LogAlert =============================

type LogAlert struct {
	ResourceID      string                    `json:"resource_id"`
	PlatformID      string                    `json:"platform_id"`
	Description     azure.LogAlertDescription `json:"Description"`
	Metadata        azure.Metadata            `json:"metadata"`
	DescribedBy     string                    `json:"described_by"`
	ResourceType    string                    `json:"resource_type"`
	IntegrationType string                    `json:"integration_type"`
	IntegrationID   string                    `json:"integration_id"`
}

type LogAlertHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  LogAlert      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type LogAlertHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []LogAlertHit     `json:"hits"`
}

type LogAlertSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  LogAlertHits `json:"hits"`
}

type LogAlertPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLogAlertPaginator(filters []essdk.BoolFilter, limit *int64) (LogAlertPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_insights_activitylogalerts", filters, limit)
	if err != nil {
		return LogAlertPaginator{}, err
	}

	p := LogAlertPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LogAlertPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LogAlertPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LogAlertPaginator) NextPage(ctx context.Context) ([]LogAlert, error) {
	var response LogAlertSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LogAlert
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLogAlertFilters = map[string]string{
	"actions":                 "Description.ActivityLogAlertResource.Properties.Actions",
	"condition":               "Description.ActivityLogAlertResource.Properties.Condition",
	"description":             "Description.ActivityLogAlertResource.properties.description",
	"enabled":                 "Description.ActivityLogAlertResource.properties.enabled",
	"id":                      "Description.ActivityLogAlertResource.id",
	"location":                "Description.ActivityLogAlertResource.location",
	"name":                    "Description.ActivityLogAlertResource.name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "Description.ResourceGroup",
	"scopes":                  "Description.ActivityLogAlertResource.Properties.Scopes",
	"subscription":            "Description.ActivityLogAlertResource.Properties.Subscription",
	"tags":                    "Description.ActivityLogAlertResource.Tags",
	"title":                   "Description.ActivityLogAlertResource.name",
	"type":                    "Description.ActivityLogAlertResource.type",
}

func ListLogAlert(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLogAlert")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLogAlert NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLogAlert NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLogAlert GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLogAlert GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLogAlert GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLogAlertPaginator(essdk.BuildFilter(ctx, d.QueryContext, listLogAlertFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLogAlert NewLogAlertPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLogAlert paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLogAlertFilters = map[string]string{
	"actions":                 "Description.ActivityLogAlertResource.Properties.Actions",
	"condition":               "Description.ActivityLogAlertResource.Properties.Condition",
	"description":             "Description.ActivityLogAlertResource.properties.description",
	"enabled":                 "Description.ActivityLogAlertResource.properties.enabled",
	"id":                      "Description.ActivityLogAlertResource.id",
	"location":                "Description.ActivityLogAlertResource.location",
	"name":                    "description.ActivityLogAlertResource.name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "description.ResourceGroup",
	"scopes":                  "Description.ActivityLogAlertResource.Properties.Scopes",
	"subscription":            "Description.ActivityLogAlertResource.Properties.Subscription",
	"tags":                    "Description.ActivityLogAlertResource.Tags",
	"title":                   "Description.ActivityLogAlertResource.name",
	"type":                    "Description.ActivityLogAlertResource.type",
}

func GetLogAlert(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLogAlert")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLogAlertPaginator(essdk.BuildFilter(ctx, d.QueryContext, getLogAlertFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: LogAlert =============================

// ==========================  START: LogProfile =============================

type LogProfile struct {
	ResourceID      string                      `json:"resource_id"`
	PlatformID      string                      `json:"platform_id"`
	Description     azure.LogProfileDescription `json:"Description"`
	Metadata        azure.Metadata              `json:"metadata"`
	DescribedBy     string                      `json:"described_by"`
	ResourceType    string                      `json:"resource_type"`
	IntegrationType string                      `json:"integration_type"`
	IntegrationID   string                      `json:"integration_id"`
}

type LogProfileHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  LogProfile    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type LogProfileHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []LogProfileHit   `json:"hits"`
}

type LogProfileSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  LogProfileHits `json:"hits"`
}

type LogProfilePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLogProfilePaginator(filters []essdk.BoolFilter, limit *int64) (LogProfilePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_insights_logprofiles", filters, limit)
	if err != nil {
		return LogProfilePaginator{}, err
	}

	p := LogProfilePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LogProfilePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LogProfilePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LogProfilePaginator) NextPage(ctx context.Context) ([]LogProfile, error) {
	var response LogProfileSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LogProfile
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLogProfileFilters = map[string]string{
	"categories":              "Description.LogProfileResource.Properties.Categories",
	"id":                      "Description.LogProfileResource.id",
	"location":                "Description.LogProfileResource.location",
	"log_event_location":      "Description.LogProfileResource.Properties.Locations",
	"name":                    "Description.LogProfileResource.name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "Description.ResourceGroup",
	"retention_policy":        "Description.LogProfileResource.Properties.RetentionPolicy",
	"service_bus_rule_id":     "Description.LogProfileResource.properties.serviceBusRuleId",
	"storage_account_id":      "Description.LogProfileResource.properties.storageAccountId",
	"subscription":            "Description.LogProfileResource.Properties.Subscription",
	"tags":                    "Description.LogProfileResource.Tags",
	"title":                   "Description.LogProfileResource.name",
	"type":                    "Description.LogProfileResource.type",
}

func ListLogProfile(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLogProfile")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLogProfile NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLogProfile NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLogProfile GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLogProfile GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLogProfile GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLogProfilePaginator(essdk.BuildFilter(ctx, d.QueryContext, listLogProfileFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLogProfile NewLogProfilePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLogProfile paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLogProfileFilters = map[string]string{
	"categories":              "Description.LogProfileResource.Properties.Categories",
	"id":                      "Description.LogProfileResource.id",
	"location":                "Description.LogProfileResource.location",
	"log_event_location":      "Description.LogProfileResource.Properties.Locations",
	"name":                    "description.LogProfileResource.name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "description.ResourceGroup",
	"retention_policy":        "Description.LogProfileResource.Properties.RetentionPolicy",
	"service_bus_rule_id":     "Description.LogProfileResource.properties.serviceBusRuleId",
	"storage_account_id":      "Description.LogProfileResource.properties.storageAccountId",
	"subscription":            "Description.LogProfileResource.Properties.Subscription",
	"tags":                    "Description.LogProfileResource.Tags",
	"title":                   "Description.LogProfileResource.name",
	"type":                    "Description.LogProfileResource.type",
}

func GetLogProfile(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLogProfile")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLogProfilePaginator(essdk.BuildFilter(ctx, d.QueryContext, getLogProfileFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: LogProfile =============================

// ==========================  START: LogicAppWorkflow =============================

type LogicAppWorkflow struct {
	ResourceID      string                            `json:"resource_id"`
	PlatformID      string                            `json:"platform_id"`
	Description     azure.LogicAppWorkflowDescription `json:"Description"`
	Metadata        azure.Metadata                    `json:"metadata"`
	DescribedBy     string                            `json:"described_by"`
	ResourceType    string                            `json:"resource_type"`
	IntegrationType string                            `json:"integration_type"`
	IntegrationID   string                            `json:"integration_id"`
}

type LogicAppWorkflowHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  LogicAppWorkflow `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type LogicAppWorkflowHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []LogicAppWorkflowHit `json:"hits"`
}

type LogicAppWorkflowSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  LogicAppWorkflowHits `json:"hits"`
}

type LogicAppWorkflowPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLogicAppWorkflowPaginator(filters []essdk.BoolFilter, limit *int64) (LogicAppWorkflowPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_logic_workflows", filters, limit)
	if err != nil {
		return LogicAppWorkflowPaginator{}, err
	}

	p := LogicAppWorkflowPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LogicAppWorkflowPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LogicAppWorkflowPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LogicAppWorkflowPaginator) NextPage(ctx context.Context) ([]LogicAppWorkflow, error) {
	var response LogicAppWorkflowSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LogicAppWorkflow
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLogicAppWorkflowFilters = map[string]string{
	"access_control":                  "Description.Workflow.Properties.AccessControl",
	"access_endpoint":                 "Description.Workflow.properties.accessEndpoint",
	"definition":                      "Description.Workflow.Properties.Definition",
	"diagnostic_settings":             "Description.DiagnosticSettingsResources",
	"endpoints_configuration":         "Description.Workflow.Properties.EndpointsConfiguration",
	"id":                              "Description.Workflow.id",
	"integration_account":             "Description.Workflow.Properties.IntegrationAccount",
	"integration_service_environment": "Description.Workflow.Properties.IntegrationServiceEnvironment",
	"name":                            "Description.Workflow.name",
	"parameters":                      "Description.Workflow.Properties.Parameters",
	"platform_integration_id":         "IntegrationID",
	"provisioning_state":              "Description.Workflow.properties.provisioningState",
	"resource_group":                  "Description.ResourceGroup",
	"sku_name":                        "Description.Workflow.properties.sku.name",
	"sku_plan":                        "Description.Workflow.Properties.SKU.Plan",
	"state":                           "Description.Workflow.properties.state",
	"subscription":                    "Description.Workflow.Properties.Subscription",
	"tags":                            "Description.Workflow.Tags",
	"title":                           "Description.Workflow.name",
	"type":                            "Description.Workflow.type",
	"version":                         "Description.Workflow.properties.version",
}

func ListLogicAppWorkflow(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLogicAppWorkflow")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLogicAppWorkflow NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLogicAppWorkflow NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLogicAppWorkflow GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLogicAppWorkflow GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLogicAppWorkflow GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLogicAppWorkflowPaginator(essdk.BuildFilter(ctx, d.QueryContext, listLogicAppWorkflowFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLogicAppWorkflow NewLogicAppWorkflowPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLogicAppWorkflow paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLogicAppWorkflowFilters = map[string]string{
	"access_control":                  "Description.Workflow.Properties.AccessControl",
	"access_endpoint":                 "Description.Workflow.properties.accessEndpoint",
	"definition":                      "Description.Workflow.Properties.Definition",
	"diagnostic_settings":             "Description.DiagnosticSettingsResources",
	"endpoints_configuration":         "Description.Workflow.Properties.EndpointsConfiguration",
	"id":                              "Description.Workflow.id",
	"integration_account":             "Description.Workflow.Properties.IntegrationAccount",
	"integration_service_environment": "Description.Workflow.Properties.IntegrationServiceEnvironment",
	"name":                            "description.Workflow.name",
	"parameters":                      "Description.Workflow.Properties.Parameters",
	"platform_integration_id":         "IntegrationID",
	"provisioning_state":              "Description.Workflow.properties.provisioningState",
	"resource_group":                  "description.ResourceGroup",
	"sku_name":                        "Description.Workflow.properties.sku.name",
	"sku_plan":                        "Description.Workflow.Properties.SKU.Plan",
	"state":                           "Description.Workflow.properties.state",
	"subscription":                    "Description.Workflow.Properties.Subscription",
	"tags":                            "Description.Workflow.Tags",
	"title":                           "Description.Workflow.name",
	"type":                            "Description.Workflow.type",
	"version":                         "Description.Workflow.properties.version",
}

func GetLogicAppWorkflow(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLogicAppWorkflow")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLogicAppWorkflowPaginator(essdk.BuildFilter(ctx, d.QueryContext, getLogicAppWorkflowFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: LogicAppWorkflow =============================

// ==========================  START: LogicIntegrationAccounts =============================

type LogicIntegrationAccounts struct {
	ResourceID      string                                    `json:"resource_id"`
	PlatformID      string                                    `json:"platform_id"`
	Description     azure.LogicIntegrationAccountsDescription `json:"Description"`
	Metadata        azure.Metadata                            `json:"metadata"`
	DescribedBy     string                                    `json:"described_by"`
	ResourceType    string                                    `json:"resource_type"`
	IntegrationType string                                    `json:"integration_type"`
	IntegrationID   string                                    `json:"integration_id"`
}

type LogicIntegrationAccountsHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  LogicIntegrationAccounts `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type LogicIntegrationAccountsHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []LogicIntegrationAccountsHit `json:"hits"`
}

type LogicIntegrationAccountsSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  LogicIntegrationAccountsHits `json:"hits"`
}

type LogicIntegrationAccountsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLogicIntegrationAccountsPaginator(filters []essdk.BoolFilter, limit *int64) (LogicIntegrationAccountsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_logic_integrationaccounts", filters, limit)
	if err != nil {
		return LogicIntegrationAccountsPaginator{}, err
	}

	p := LogicIntegrationAccountsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LogicIntegrationAccountsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LogicIntegrationAccountsPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LogicIntegrationAccountsPaginator) NextPage(ctx context.Context) ([]LogicIntegrationAccounts, error) {
	var response LogicIntegrationAccountsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LogicIntegrationAccounts
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLogicIntegrationAccountsFilters = map[string]string{
	"id":                      "Description.IntegrationAccounts.ID",
	"name":                    "Description.Account.properties.integrationServiceEnvironment.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.IntegrationAccounts.Properties.Subscription",
	"tags":                    "Description.Account.properties.integrationServiceEnvironment.name",
	"title":                   "Description.Account.properties.integrationServiceEnvironment.name",
}

func ListLogicIntegrationAccounts(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLogicIntegrationAccounts")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLogicIntegrationAccounts NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLogicIntegrationAccounts NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLogicIntegrationAccounts GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLogicIntegrationAccounts GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLogicIntegrationAccounts GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLogicIntegrationAccountsPaginator(essdk.BuildFilter(ctx, d.QueryContext, listLogicIntegrationAccountsFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLogicIntegrationAccounts NewLogicIntegrationAccountsPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLogicIntegrationAccounts paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLogicIntegrationAccountsFilters = map[string]string{
	"id":                      "Description.IntegrationAccounts.ID",
	"name":                    "Description.Account.properties.integrationServiceEnvironment.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.IntegrationAccounts.Properties.Subscription",
	"tags":                    "Description.Account.properties.integrationServiceEnvironment.name",
	"title":                   "Description.Account.properties.integrationServiceEnvironment.name",
}

func GetLogicIntegrationAccounts(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLogicIntegrationAccounts")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLogicIntegrationAccountsPaginator(essdk.BuildFilter(ctx, d.QueryContext, getLogicIntegrationAccountsFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: LogicIntegrationAccounts =============================

// ==========================  START: MachineLearningWorkspace =============================

type MachineLearningWorkspace struct {
	ResourceID      string                                    `json:"resource_id"`
	PlatformID      string                                    `json:"platform_id"`
	Description     azure.MachineLearningWorkspaceDescription `json:"Description"`
	Metadata        azure.Metadata                            `json:"metadata"`
	DescribedBy     string                                    `json:"described_by"`
	ResourceType    string                                    `json:"resource_type"`
	IntegrationType string                                    `json:"integration_type"`
	IntegrationID   string                                    `json:"integration_id"`
}

type MachineLearningWorkspaceHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  MachineLearningWorkspace `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type MachineLearningWorkspaceHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []MachineLearningWorkspaceHit `json:"hits"`
}

type MachineLearningWorkspaceSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  MachineLearningWorkspaceHits `json:"hits"`
}

type MachineLearningWorkspacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMachineLearningWorkspacePaginator(filters []essdk.BoolFilter, limit *int64) (MachineLearningWorkspacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_machinelearningservices_workspaces", filters, limit)
	if err != nil {
		return MachineLearningWorkspacePaginator{}, err
	}

	p := MachineLearningWorkspacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MachineLearningWorkspacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MachineLearningWorkspacePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p MachineLearningWorkspacePaginator) NextPage(ctx context.Context) ([]MachineLearningWorkspace, error) {
	var response MachineLearningWorkspaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MachineLearningWorkspace
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMachineLearningWorkspaceFilters = map[string]string{
	"application_insights":               "Description.Workspace.properties.applicationInsights",
	"container_registry":                 "Description.Workspace.properties.containerRegistry",
	"description":                        "Description.Workspace.properties.description",
	"diagnostic_settings":                "Description.DiagnosticSettingsResources",
	"discovery_url":                      "Description.Workspace.properties.discoveryUrl",
	"encryption":                         "Description.Workspace.Properties.Encryption",
	"friendly_name":                      "Description.Workspace.properties.friendlyName",
	"hbi_workspace":                      "Description.Workspace.properties.hbiWorkspace",
	"id":                                 "Description.Workspace.id",
	"identity":                           "Description.Workspace.Identity",
	"key_vault":                          "Description.Workspace.properties.keyVault",
	"location":                           "Description.Workspace.location",
	"name":                               "Description.Workspace.name",
	"platform_integration_id":            "IntegrationID",
	"provisioning_state":                 "Description.Workspace.properties.provisioningState",
	"resource_group":                     "Description.ResourceGroup",
	"service_provisioned_resource_group": "Description.Workspace.properties.serviceProvisionedResourceGroup",
	"sku_name":                           "Description.Workspace.sku.name",
	"sku_tier":                           "Description.Workspace.sku.tier",
	"storage_account":                    "Description.Workspace.properties.storageAccount",
	"subscription":                       "Description.Workspace.Properties.Subscription",
	"tags":                               "Description.Workspace.Tags",
	"title":                              "Description.Workspace.name",
	"type":                               "Description.Workspace.type",
	"workspace_id":                       "Description.Workspace.properties.workspaceId",
}

func ListMachineLearningWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMachineLearningWorkspace")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListMachineLearningWorkspace NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListMachineLearningWorkspace NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListMachineLearningWorkspace GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListMachineLearningWorkspace GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListMachineLearningWorkspace GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewMachineLearningWorkspacePaginator(essdk.BuildFilter(ctx, d.QueryContext, listMachineLearningWorkspaceFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListMachineLearningWorkspace NewMachineLearningWorkspacePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListMachineLearningWorkspace paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getMachineLearningWorkspaceFilters = map[string]string{
	"application_insights":               "Description.Workspace.properties.applicationInsights",
	"container_registry":                 "Description.Workspace.properties.containerRegistry",
	"description":                        "Description.Workspace.properties.description",
	"diagnostic_settings":                "Description.DiagnosticSettingsResources",
	"discovery_url":                      "Description.Workspace.properties.discoveryUrl",
	"encryption":                         "Description.Workspace.Properties.Encryption",
	"friendly_name":                      "Description.Workspace.properties.friendlyName",
	"hbi_workspace":                      "Description.Workspace.properties.hbiWorkspace",
	"id":                                 "Description.Workspace.id",
	"identity":                           "Description.Workspace.Identity",
	"key_vault":                          "Description.Workspace.properties.keyVault",
	"location":                           "Description.Workspace.location",
	"name":                               "description.Workspace.name",
	"platform_integration_id":            "IntegrationID",
	"provisioning_state":                 "Description.Workspace.properties.provisioningState",
	"resource_group":                     "description.ResourceGroup",
	"service_provisioned_resource_group": "Description.Workspace.properties.serviceProvisionedResourceGroup",
	"sku_name":                           "Description.Workspace.sku.name",
	"sku_tier":                           "Description.Workspace.sku.tier",
	"storage_account":                    "Description.Workspace.properties.storageAccount",
	"subscription":                       "Description.Workspace.Properties.Subscription",
	"tags":                               "Description.Workspace.Tags",
	"title":                              "Description.Workspace.name",
	"type":                               "Description.Workspace.type",
	"workspace_id":                       "Description.Workspace.properties.workspaceId",
}

func GetMachineLearningWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMachineLearningWorkspace")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewMachineLearningWorkspacePaginator(essdk.BuildFilter(ctx, d.QueryContext, getMachineLearningWorkspaceFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: MachineLearningWorkspace =============================

// ==========================  START: MariadbServer =============================

type MariadbServer struct {
	ResourceID      string                         `json:"resource_id"`
	PlatformID      string                         `json:"platform_id"`
	Description     azure.MariadbServerDescription `json:"Description"`
	Metadata        azure.Metadata                 `json:"metadata"`
	DescribedBy     string                         `json:"described_by"`
	ResourceType    string                         `json:"resource_type"`
	IntegrationType string                         `json:"integration_type"`
	IntegrationID   string                         `json:"integration_id"`
}

type MariadbServerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  MariadbServer `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type MariadbServerHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []MariadbServerHit `json:"hits"`
}

type MariadbServerSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  MariadbServerHits `json:"hits"`
}

type MariadbServerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMariadbServerPaginator(filters []essdk.BoolFilter, limit *int64) (MariadbServerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_dbformariadb_servers", filters, limit)
	if err != nil {
		return MariadbServerPaginator{}, err
	}

	p := MariadbServerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MariadbServerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MariadbServerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p MariadbServerPaginator) NextPage(ctx context.Context) ([]MariadbServer, error) {
	var response MariadbServerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MariadbServer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMariadbServerFilters = map[string]string{
	"administrator_login":          "Description.Server.properties.administratorLogin",
	"auto_grow_enabled":            "Description.Server.properties.storageProfile.storageAutogrow",
	"backup_retention_days":        "Description.Server.properties.storageProfile.backupRetentionDays",
	"fully_qualified_domain_name":  "Description.Server.properties.fullyQualifiedDomainName",
	"geo_redundant_backup_enabled": "Description.Server.properties.storageProfile.geoRedundantBackup",
	"id":                           "Description.Server.id",
	"master_service_id":            "Description.Server.properties.masterServerId",
	"name":                         "Description.Server.name",
	"platform_integration_id":      "IntegrationID",
	"private_endpoint_connections": "Description.Server.Properties.PrivateEndpointConnections",
	"public_network_access":        "Description.Server.properties.publicNetworkAccess",
	"replica_capacity":             "Description.Server.properties.replicaCapacity",
	"replication_role":             "Description.Server.properties.replicationRole",
	"resource_group":               "Description.ResourceGroup",
	"sku_capacity":                 "Description.Server.sku.capacity",
	"sku_family":                   "Description.Server.sku.family",
	"sku_name":                     "Description.Server.sku.name",
	"sku_size":                     "Description.Server.sku.size",
	"sku_tier":                     "Description.Server.sku.tier",
	"ssl_enforcement":              "Description.Server.properties.sslEnforcement",
	"storage_mb":                   "Description.Server.properties.storageProfile.storageMB",
	"subscription":                 "Description.Server.Properties.Subscription",
	"tags":                         "Description.Server.Tags",
	"title":                        "Description.Server.name",
	"type":                         "Description.Server.type",
	"user_visible_state":           "Description.Server.properties.userVisibleState",
	"version":                      "Description.Server.properties.version",
}

func ListMariadbServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMariadbServer")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListMariadbServer NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListMariadbServer NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListMariadbServer GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListMariadbServer GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListMariadbServer GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewMariadbServerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listMariadbServerFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListMariadbServer NewMariadbServerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListMariadbServer paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getMariadbServerFilters = map[string]string{
	"administrator_login":          "Description.Server.properties.administratorLogin",
	"auto_grow_enabled":            "Description.Server.properties.storageProfile.storageAutogrow",
	"backup_retention_days":        "Description.Server.properties.storageProfile.backupRetentionDays",
	"fully_qualified_domain_name":  "Description.Server.properties.fullyQualifiedDomainName",
	"geo_redundant_backup_enabled": "Description.Server.properties.storageProfile.geoRedundantBackup",
	"id":                           "Description.Server.id",
	"master_service_id":            "Description.Server.properties.masterServerId",
	"name":                         "description.Server.name",
	"platform_integration_id":      "IntegrationID",
	"private_endpoint_connections": "Description.Server.Properties.PrivateEndpointConnections",
	"public_network_access":        "Description.Server.properties.publicNetworkAccess",
	"replica_capacity":             "Description.Server.properties.replicaCapacity",
	"replication_role":             "Description.Server.properties.replicationRole",
	"resource_group":               "description.ResourceGroup",
	"sku_capacity":                 "Description.Server.sku.capacity",
	"sku_family":                   "Description.Server.sku.family",
	"sku_name":                     "Description.Server.sku.name",
	"sku_size":                     "Description.Server.sku.size",
	"sku_tier":                     "Description.Server.sku.tier",
	"ssl_enforcement":              "Description.Server.properties.sslEnforcement",
	"storage_mb":                   "Description.Server.properties.storageProfile.storageMB",
	"subscription":                 "Description.Server.Properties.Subscription",
	"tags":                         "Description.Server.Tags",
	"title":                        "Description.Server.name",
	"type":                         "Description.Server.type",
	"user_visible_state":           "Description.Server.properties.userVisibleState",
	"version":                      "Description.Server.properties.version",
}

func GetMariadbServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMariadbServer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewMariadbServerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getMariadbServerFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: MariadbServer =============================

// ==========================  START: MariadbDatabase =============================

type MariadbDatabase struct {
	ResourceID      string                           `json:"resource_id"`
	PlatformID      string                           `json:"platform_id"`
	Description     azure.MariadbDatabaseDescription `json:"Description"`
	Metadata        azure.Metadata                   `json:"metadata"`
	DescribedBy     string                           `json:"described_by"`
	ResourceType    string                           `json:"resource_type"`
	IntegrationType string                           `json:"integration_type"`
	IntegrationID   string                           `json:"integration_id"`
}

type MariadbDatabaseHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  MariadbDatabase `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type MariadbDatabaseHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []MariadbDatabaseHit `json:"hits"`
}

type MariadbDatabaseSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  MariadbDatabaseHits `json:"hits"`
}

type MariadbDatabasePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMariadbDatabasePaginator(filters []essdk.BoolFilter, limit *int64) (MariadbDatabasePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_dbformariadb_servers_databases", filters, limit)
	if err != nil {
		return MariadbDatabasePaginator{}, err
	}

	p := MariadbDatabasePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MariadbDatabasePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MariadbDatabasePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p MariadbDatabasePaginator) NextPage(ctx context.Context) ([]MariadbDatabase, error) {
	var response MariadbDatabaseSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MariadbDatabase
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMariadbDatabaseFilters = map[string]string{
	"id":                      "Description.Databases.ID",
	"name":                    "Description.Database.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Databases.Properties.Subscription",
	"tags":                    "Description.Database.name",
	"title":                   "Description.Database.name",
}

func ListMariadbDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMariadbDatabase")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListMariadbDatabase NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListMariadbDatabase NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListMariadbDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListMariadbDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListMariadbDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewMariadbDatabasePaginator(essdk.BuildFilter(ctx, d.QueryContext, listMariadbDatabaseFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListMariadbDatabase NewMariadbDatabasePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListMariadbDatabase paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getMariadbDatabaseFilters = map[string]string{
	"id":                      "Description.Databases.ID",
	"name":                    "Description.Database.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Databases.Properties.Subscription",
	"tags":                    "Description.Database.name",
	"title":                   "Description.Database.name",
}

func GetMariadbDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMariadbDatabase")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewMariadbDatabasePaginator(essdk.BuildFilter(ctx, d.QueryContext, getMariadbDatabaseFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: MariadbDatabase =============================

// ==========================  START: MysqlServer =============================

type MysqlServer struct {
	ResourceID      string                       `json:"resource_id"`
	PlatformID      string                       `json:"platform_id"`
	Description     azure.MysqlServerDescription `json:"Description"`
	Metadata        azure.Metadata               `json:"metadata"`
	DescribedBy     string                       `json:"described_by"`
	ResourceType    string                       `json:"resource_type"`
	IntegrationType string                       `json:"integration_type"`
	IntegrationID   string                       `json:"integration_id"`
}

type MysqlServerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  MysqlServer   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type MysqlServerHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []MysqlServerHit  `json:"hits"`
}

type MysqlServerSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  MysqlServerHits `json:"hits"`
}

type MysqlServerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMysqlServerPaginator(filters []essdk.BoolFilter, limit *int64) (MysqlServerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_dbformysql_servers", filters, limit)
	if err != nil {
		return MysqlServerPaginator{}, err
	}

	p := MysqlServerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MysqlServerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MysqlServerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p MysqlServerPaginator) NextPage(ctx context.Context) ([]MysqlServer, error) {
	var response MysqlServerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MysqlServer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMysqlServerFilters = map[string]string{
	"administrator_login":          "Description.Server.properties.administratorLogin",
	"backup_retention_days":        "Description.Server.properties.storageProfile.backupRetentionDays",
	"byok_enforcement":             "Description.Server.properties.byokEnforcement",
	"fully_qualified_domain_name":  "Description.Server.properties.fullyQualifiedDomainName",
	"geo_redundant_backup":         "Description.Server.properties.storageProfile.geoRedundantBackup",
	"id":                           "Description.Server.id",
	"infrastructure_encryption":    "Description.Server.properties.infrastructureEncryption",
	"location":                     "Description.Server.location",
	"master_server_id":             "Description.Server.properties.masterServerId",
	"minimal_tls_version":          "Description.Server.properties.minimalTlsVersion",
	"name":                         "Description.Server.name",
	"platform_integration_id":      "IntegrationID",
	"public_network_access":        "Description.Server.properties.publicNetworkAccess",
	"replica_capacity":             "Description.Server.properties.replicaCapacity",
	"replication_role":             "Description.Server.properties.replicationRole",
	"resource_group":               "Description.ResourceGroup",
	"server_configurations":        "Description.Configurations",
	"server_keys":                  "Description.ServerKeys",
	"server_security_alert_policy": "Description.SecurityAlertPolicies",
	"sku_capacity":                 "Description.Server.sku.capacity",
	"sku_family":                   "Description.Server.sku.family",
	"sku_name":                     "Description.Server.sku.name",
	"sku_size":                     "Description.Server.sku.size",
	"sku_tier":                     "Description.Server.sku.tier",
	"ssl_enforcement":              "Description.Server.properties.sslEnforcement",
	"state":                        "Description.Server.properties.userVisibleState",
	"storage_auto_grow":            "Description.Server.properties.storageProfile.storageAutogrow",
	"storage_mb":                   "Description.Server.properties.storageProfile.storageMB",
	"subscription":                 "Description.Server.Properties.Subscription",
	"tags":                         "Description.Server.Tags",
	"title":                        "Description.Server.name",
	"type":                         "Description.Server.type",
	"user_visible_state":           "Description.Server.properties.userVisibleState",
	"version":                      "Description.Server.properties.version",
	"vnet_rules":                   "Description.VnetRules",
}

func ListMysqlServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMysqlServer")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListMysqlServer NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListMysqlServer NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListMysqlServer GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListMysqlServer GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListMysqlServer GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewMysqlServerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listMysqlServerFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListMysqlServer NewMysqlServerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListMysqlServer paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getMysqlServerFilters = map[string]string{
	"administrator_login":          "Description.Server.properties.administratorLogin",
	"backup_retention_days":        "Description.Server.properties.storageProfile.backupRetentionDays",
	"byok_enforcement":             "Description.Server.properties.byokEnforcement",
	"fully_qualified_domain_name":  "Description.Server.properties.fullyQualifiedDomainName",
	"geo_redundant_backup":         "Description.Server.properties.storageProfile.geoRedundantBackup",
	"id":                           "Description.Server.id",
	"infrastructure_encryption":    "Description.Server.properties.infrastructureEncryption",
	"location":                     "Description.Server.location",
	"master_server_id":             "Description.Server.properties.masterServerId",
	"minimal_tls_version":          "Description.Server.properties.minimalTlsVersion",
	"name":                         "description.Server.name",
	"platform_integration_id":      "IntegrationID",
	"public_network_access":        "Description.Server.properties.publicNetworkAccess",
	"replica_capacity":             "Description.Server.properties.replicaCapacity",
	"replication_role":             "Description.Server.properties.replicationRole",
	"resource_group":               "description.ResourceGroup",
	"server_configurations":        "Description.Configurations",
	"server_keys":                  "Description.ServerKeys",
	"server_security_alert_policy": "Description.SecurityAlertPolicies",
	"sku_capacity":                 "Description.Server.sku.capacity",
	"sku_family":                   "Description.Server.sku.family",
	"sku_name":                     "Description.Server.sku.name",
	"sku_size":                     "Description.Server.sku.size",
	"sku_tier":                     "Description.Server.sku.tier",
	"ssl_enforcement":              "Description.Server.properties.sslEnforcement",
	"state":                        "Description.Server.properties.userVisibleState",
	"storage_auto_grow":            "Description.Server.properties.storageProfile.storageAutogrow",
	"storage_mb":                   "Description.Server.properties.storageProfile.storageMB",
	"subscription":                 "Description.Server.Properties.Subscription",
	"tags":                         "Description.Server.Tags",
	"title":                        "Description.Server.name",
	"type":                         "Description.Server.type",
	"user_visible_state":           "Description.Server.properties.userVisibleState",
	"version":                      "Description.Server.properties.version",
	"vnet_rules":                   "Description.VnetRules",
}

func GetMysqlServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMysqlServer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewMysqlServerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getMysqlServerFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: MysqlServer =============================

// ==========================  START: MysqlFlexibleserver =============================

type MysqlFlexibleserver struct {
	ResourceID      string                               `json:"resource_id"`
	PlatformID      string                               `json:"platform_id"`
	Description     azure.MysqlFlexibleserverDescription `json:"Description"`
	Metadata        azure.Metadata                       `json:"metadata"`
	DescribedBy     string                               `json:"described_by"`
	ResourceType    string                               `json:"resource_type"`
	IntegrationType string                               `json:"integration_type"`
	IntegrationID   string                               `json:"integration_id"`
}

type MysqlFlexibleserverHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  MysqlFlexibleserver `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type MysqlFlexibleserverHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []MysqlFlexibleserverHit `json:"hits"`
}

type MysqlFlexibleserverSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  MysqlFlexibleserverHits `json:"hits"`
}

type MysqlFlexibleserverPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMysqlFlexibleserverPaginator(filters []essdk.BoolFilter, limit *int64) (MysqlFlexibleserverPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_dbformysql_flexibleservers", filters, limit)
	if err != nil {
		return MysqlFlexibleserverPaginator{}, err
	}

	p := MysqlFlexibleserverPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MysqlFlexibleserverPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MysqlFlexibleserverPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p MysqlFlexibleserverPaginator) NextPage(ctx context.Context) ([]MysqlFlexibleserver, error) {
	var response MysqlFlexibleserverSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MysqlFlexibleserver
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMysqlFlexibleserverFilters = map[string]string{
	"id":                      "Description.Server.id",
	"name":                    "Description.Server.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Server.Properties.Subscription",
	"tags":                    "Description.Server.Tags",
	"title":                   "Description.Server.name",
}

func ListMysqlFlexibleserver(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMysqlFlexibleserver")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListMysqlFlexibleserver NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListMysqlFlexibleserver NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListMysqlFlexibleserver GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListMysqlFlexibleserver GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListMysqlFlexibleserver GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewMysqlFlexibleserverPaginator(essdk.BuildFilter(ctx, d.QueryContext, listMysqlFlexibleserverFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListMysqlFlexibleserver NewMysqlFlexibleserverPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListMysqlFlexibleserver paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getMysqlFlexibleserverFilters = map[string]string{
	"id":                      "Description.Server.id",
	"name":                    "Description.Server.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Server.Properties.Subscription",
	"tags":                    "Description.Server.Tags",
	"title":                   "Description.Server.name",
}

func GetMysqlFlexibleserver(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMysqlFlexibleserver")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewMysqlFlexibleserverPaginator(essdk.BuildFilter(ctx, d.QueryContext, getMysqlFlexibleserverFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: MysqlFlexibleserver =============================

// ==========================  START: NetworkSecurityGroup =============================

type NetworkSecurityGroup struct {
	ResourceID      string                                `json:"resource_id"`
	PlatformID      string                                `json:"platform_id"`
	Description     azure.NetworkSecurityGroupDescription `json:"Description"`
	Metadata        azure.Metadata                        `json:"metadata"`
	DescribedBy     string                                `json:"described_by"`
	ResourceType    string                                `json:"resource_type"`
	IntegrationType string                                `json:"integration_type"`
	IntegrationID   string                                `json:"integration_id"`
}

type NetworkSecurityGroupHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  NetworkSecurityGroup `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type NetworkSecurityGroupHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []NetworkSecurityGroupHit `json:"hits"`
}

type NetworkSecurityGroupSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  NetworkSecurityGroupHits `json:"hits"`
}

type NetworkSecurityGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNetworkSecurityGroupPaginator(filters []essdk.BoolFilter, limit *int64) (NetworkSecurityGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_networksecuritygroups", filters, limit)
	if err != nil {
		return NetworkSecurityGroupPaginator{}, err
	}

	p := NetworkSecurityGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NetworkSecurityGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NetworkSecurityGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p NetworkSecurityGroupPaginator) NextPage(ctx context.Context) ([]NetworkSecurityGroup, error) {
	var response NetworkSecurityGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NetworkSecurityGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNetworkSecurityGroupFilters = map[string]string{
	"default_security_rules":  "Description.SecurityGroup.Properties.DefaultSecurityRules",
	"diagnostic_settings":     "Description.DiagnosticSettingsResources",
	"etag":                    "Description.SecurityGroup.etag",
	"flow_logs":               "Description.SecurityGroup.Properties.FlowLogs",
	"id":                      "Description.SecurityGroup.id",
	"name":                    "Description.SecurityGroup.name",
	"network_interfaces":      "Description.SecurityGroup.Properties.NetworkInterfaces",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.SecurityGroup.properties.provisioningState",
	"resource_group":          "Description.ResourceGroup",
	"resource_guid":           "Description.SecurityGroup.properties.resourceGuid",
	"security_rules":          "Description.SecurityGroup.Properties.SecurityRules",
	"subnets":                 "Description.SecurityGroup.Properties.Subnets",
	"subscription":            "Description.SecurityGroup.Properties.Subscription",
	"tags":                    "Description.SecurityGroup.Tags",
	"title":                   "Description.SecurityGroup.name",
	"type":                    "Description.SecurityGroup.type",
}

func ListNetworkSecurityGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNetworkSecurityGroup")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkSecurityGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkSecurityGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkSecurityGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkSecurityGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkSecurityGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewNetworkSecurityGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listNetworkSecurityGroupFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkSecurityGroup NewNetworkSecurityGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListNetworkSecurityGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getNetworkSecurityGroupFilters = map[string]string{
	"default_security_rules":  "Description.SecurityGroup.Properties.DefaultSecurityRules",
	"diagnostic_settings":     "Description.DiagnosticSettingsResources",
	"etag":                    "Description.SecurityGroup.etag",
	"flow_logs":               "Description.SecurityGroup.Properties.FlowLogs",
	"id":                      "Description.SecurityGroup.id",
	"name":                    "description.SecurityGroup.name",
	"network_interfaces":      "Description.SecurityGroup.Properties.NetworkInterfaces",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.SecurityGroup.properties.provisioningState",
	"resource_group":          "description.ResourceGroup",
	"resource_guid":           "Description.SecurityGroup.properties.resourceGuid",
	"security_rules":          "Description.SecurityGroup.Properties.SecurityRules",
	"subnets":                 "Description.SecurityGroup.Properties.Subnets",
	"subscription":            "Description.SecurityGroup.Properties.Subscription",
	"tags":                    "Description.SecurityGroup.Tags",
	"title":                   "Description.SecurityGroup.name",
	"type":                    "Description.SecurityGroup.type",
}

func GetNetworkSecurityGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNetworkSecurityGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewNetworkSecurityGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getNetworkSecurityGroupFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: NetworkSecurityGroup =============================

// ==========================  START: NetworkWatcher =============================

type NetworkWatcher struct {
	ResourceID      string                          `json:"resource_id"`
	PlatformID      string                          `json:"platform_id"`
	Description     azure.NetworkWatcherDescription `json:"Description"`
	Metadata        azure.Metadata                  `json:"metadata"`
	DescribedBy     string                          `json:"described_by"`
	ResourceType    string                          `json:"resource_type"`
	IntegrationType string                          `json:"integration_type"`
	IntegrationID   string                          `json:"integration_id"`
}

type NetworkWatcherHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  NetworkWatcher `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type NetworkWatcherHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []NetworkWatcherHit `json:"hits"`
}

type NetworkWatcherSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  NetworkWatcherHits `json:"hits"`
}

type NetworkWatcherPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNetworkWatcherPaginator(filters []essdk.BoolFilter, limit *int64) (NetworkWatcherPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_networkwatchers", filters, limit)
	if err != nil {
		return NetworkWatcherPaginator{}, err
	}

	p := NetworkWatcherPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NetworkWatcherPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NetworkWatcherPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p NetworkWatcherPaginator) NextPage(ctx context.Context) ([]NetworkWatcher, error) {
	var response NetworkWatcherSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NetworkWatcher
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNetworkWatcherFilters = map[string]string{
	"etag":                    "Description.Watcher.etag",
	"id":                      "Description.Watcher.id",
	"name":                    "Description.Watcher.name",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.Watcher.properties.provisioningState",
	"resource_group":          "Description.ResourceGroup",
	"subscription":            "Description.Watcher.Properties.Subscription",
	"tags":                    "Description.Watcher.Tags",
	"title":                   "Description.Watcher.name",
	"type":                    "Description.Watcher.type",
}

func ListNetworkWatcher(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNetworkWatcher")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkWatcher NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkWatcher NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkWatcher GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkWatcher GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkWatcher GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewNetworkWatcherPaginator(essdk.BuildFilter(ctx, d.QueryContext, listNetworkWatcherFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetworkWatcher NewNetworkWatcherPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListNetworkWatcher paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getNetworkWatcherFilters = map[string]string{
	"etag":                    "Description.Watcher.etag",
	"id":                      "Description.Watcher.id",
	"name":                    "description.Watcher.name",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.Watcher.properties.provisioningState",
	"resource_group":          "description.ResourceGroup",
	"subscription":            "Description.Watcher.Properties.Subscription",
	"tags":                    "Description.Watcher.Tags",
	"title":                   "Description.Watcher.name",
	"type":                    "Description.Watcher.type",
}

func GetNetworkWatcher(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNetworkWatcher")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewNetworkWatcherPaginator(essdk.BuildFilter(ctx, d.QueryContext, getNetworkWatcherFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: NetworkWatcher =============================

// ==========================  START: SearchService =============================

type SearchService struct {
	ResourceID      string                         `json:"resource_id"`
	PlatformID      string                         `json:"platform_id"`
	Description     azure.SearchServiceDescription `json:"Description"`
	Metadata        azure.Metadata                 `json:"metadata"`
	DescribedBy     string                         `json:"described_by"`
	ResourceType    string                         `json:"resource_type"`
	IntegrationType string                         `json:"integration_type"`
	IntegrationID   string                         `json:"integration_id"`
}

type SearchServiceHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SearchService `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SearchServiceHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []SearchServiceHit `json:"hits"`
}

type SearchServiceSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  SearchServiceHits `json:"hits"`
}

type SearchServicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSearchServicePaginator(filters []essdk.BoolFilter, limit *int64) (SearchServicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_search_searchservices", filters, limit)
	if err != nil {
		return SearchServicePaginator{}, err
	}

	p := SearchServicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SearchServicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SearchServicePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SearchServicePaginator) NextPage(ctx context.Context) ([]SearchService, error) {
	var response SearchServiceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SearchService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSearchServiceFilters = map[string]string{
	"diagnostic_settings":           "Description.DiagnosticSettingsResources",
	"hosting_mode":                  "Description.Service.properties.hostingMode",
	"id":                            "Description.Service.id",
	"identity":                      "Description.Service.Identity",
	"name":                          "Description.Service.name",
	"network_rule_set":              "Description.Service.Properties.NetworkRuleSet",
	"partition_count":               "Description.Service.properties.partitionCount",
	"platform_integration_id":       "IntegrationID",
	"private_endpoint_connections":  "Description.Service.Properties.PrivateEndpointConnections",
	"provisioning_state":            "Description.Service.properties.provisioningState",
	"public_network_access":         "Description.Service.properties.publicNetworkAccess",
	"replica_count":                 "Description.Service.properties.replicaCount",
	"shared_private_link_resources": "Description.Service.Properties.SharedPrivateLinkResources",
	"sku_name":                      "Description.Service.sku.name",
	"status":                        "Description.Service.properties.status",
	"status_details":                "Description.Service.properties.statusDetails",
	"subscription":                  "Description.Service.Properties.Subscription",
	"tags":                          "Description.Service.Tags",
	"title":                         "Description.Service.name",
	"type":                          "Description.Service.type",
}

func ListSearchService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSearchService")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSearchService NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSearchService NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSearchService GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSearchService GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSearchService GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSearchServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, listSearchServiceFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSearchService NewSearchServicePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSearchService paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSearchServiceFilters = map[string]string{
	"diagnostic_settings":           "Description.DiagnosticSettingsResources",
	"hosting_mode":                  "Description.Service.properties.hostingMode",
	"id":                            "Description.Service.id",
	"identity":                      "Description.Service.Identity",
	"name":                          "description.Service.name",
	"network_rule_set":              "Description.Service.Properties.NetworkRuleSet",
	"partition_count":               "Description.Service.properties.partitionCount",
	"platform_integration_id":       "IntegrationID",
	"private_endpoint_connections":  "Description.Service.Properties.PrivateEndpointConnections",
	"provisioning_state":            "Description.Service.properties.provisioningState",
	"public_network_access":         "Description.Service.properties.publicNetworkAccess",
	"replica_count":                 "Description.Service.properties.replicaCount",
	"resource_group":                "description.ResourceGroup",
	"shared_private_link_resources": "Description.Service.Properties.SharedPrivateLinkResources",
	"sku_name":                      "Description.Service.sku.name",
	"status":                        "Description.Service.properties.status",
	"status_details":                "Description.Service.properties.statusDetails",
	"subscription":                  "Description.Service.Properties.Subscription",
	"tags":                          "Description.Service.Tags",
	"title":                         "Description.Service.name",
	"type":                          "Description.Service.type",
}

func GetSearchService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSearchService")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSearchServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, getSearchServiceFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SearchService =============================

// ==========================  START: ServiceFabricCluster =============================

type ServiceFabricCluster struct {
	ResourceID      string                                `json:"resource_id"`
	PlatformID      string                                `json:"platform_id"`
	Description     azure.ServiceFabricClusterDescription `json:"Description"`
	Metadata        azure.Metadata                        `json:"metadata"`
	DescribedBy     string                                `json:"described_by"`
	ResourceType    string                                `json:"resource_type"`
	IntegrationType string                                `json:"integration_type"`
	IntegrationID   string                                `json:"integration_id"`
}

type ServiceFabricClusterHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  ServiceFabricCluster `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type ServiceFabricClusterHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []ServiceFabricClusterHit `json:"hits"`
}

type ServiceFabricClusterSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  ServiceFabricClusterHits `json:"hits"`
}

type ServiceFabricClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewServiceFabricClusterPaginator(filters []essdk.BoolFilter, limit *int64) (ServiceFabricClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_servicefabric_clusters", filters, limit)
	if err != nil {
		return ServiceFabricClusterPaginator{}, err
	}

	p := ServiceFabricClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ServiceFabricClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ServiceFabricClusterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ServiceFabricClusterPaginator) NextPage(ctx context.Context) ([]ServiceFabricCluster, error) {
	var response ServiceFabricClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ServiceFabricCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listServiceFabricClusterFilters = map[string]string{
	"add_on_features":                        "Description.Cluster.Properties.AddOnFeatures",
	"available_cluster_versions":             "Description.Cluster.Properties.AvailableClusterVersions",
	"azure_active_directory":                 "Description.Cluster.Properties.AzureActiveDirectory",
	"certificate":                            "Description.Cluster.Properties.Certificate",
	"certificate_common_names":               "Description.Cluster.Properties.CertificateCommonNames",
	"client_certificate_common_names":        "Description.Cluster.Properties.ClientCertificateCommonNames",
	"client_certificate_thumbprints":         "Description.Cluster.Properties.ClientCertificateThumbprints",
	"cluster_code_version":                   "Description.Cluster.properties.clusterCodeVersion",
	"cluster_endpoint":                       "Description.Cluster.properties.clusterEndpoint",
	"cluster_id":                             "Description.Cluster.properties.clusterId",
	"cluster_state":                          "Description.Cluster.properties.clusterState",
	"diagnostics_storage_account_config":     "Description.Cluster.Properties.DiagnosticsStorageAccountConfig",
	"etag":                                   "Description.Cluster.etag",
	"event_store_service_enabled":            "Description.Cluster.properties.eventStoreServiceEnabled",
	"fabric_settings":                        "Description.Cluster.Properties.FabricSettings",
	"id":                                     "Description.Cluster.id",
	"management_endpoint":                    "Description.Cluster.properties.managementEndpoint",
	"name":                                   "Description.Cluster.name",
	"node_types":                             "Description.Cluster.Properties.NodeTypes",
	"platform_integration_id":                "IntegrationID",
	"provisioning_state":                     "Description.Cluster.properties.provisioningState",
	"reliability_level":                      "Description.Cluster.properties.reliabilityLevel",
	"resource_group":                         "Description.ResourceGroup",
	"reverse_proxy_certificate":              "Description.Cluster.Properties.ReverseProxyCertificate",
	"reverse_proxy_certificate_common_names": "Description.Cluster.Properties.ReverseProxyCertificateCommonNames",
	"subscription":                           "Description.Cluster.Properties.Subscription",
	"tags":                                   "Description.Cluster.Tags",
	"title":                                  "Description.Cluster.name",
	"type":                                   "Description.Cluster.type",
	"upgrade_description":                    "Description.Cluster.Properties.UpgradeDescription",
	"upgrade_mode":                           "Description.Cluster.properties.upgradeMode",
	"vm_image":                               "Description.Cluster.properties.vmImage",
}

func ListServiceFabricCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListServiceFabricCluster")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceFabricCluster NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceFabricCluster NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceFabricCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceFabricCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceFabricCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewServiceFabricClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listServiceFabricClusterFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListServiceFabricCluster NewServiceFabricClusterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListServiceFabricCluster paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getServiceFabricClusterFilters = map[string]string{
	"add_on_features":                        "Description.Cluster.Properties.AddOnFeatures",
	"available_cluster_versions":             "Description.Cluster.Properties.AvailableClusterVersions",
	"azure_active_directory":                 "Description.Cluster.Properties.AzureActiveDirectory",
	"certificate":                            "Description.Cluster.Properties.Certificate",
	"certificate_common_names":               "Description.Cluster.Properties.CertificateCommonNames",
	"client_certificate_common_names":        "Description.Cluster.Properties.ClientCertificateCommonNames",
	"client_certificate_thumbprints":         "Description.Cluster.Properties.ClientCertificateThumbprints",
	"cluster_code_version":                   "Description.Cluster.properties.clusterCodeVersion",
	"cluster_endpoint":                       "Description.Cluster.properties.clusterEndpoint",
	"cluster_id":                             "Description.Cluster.properties.clusterId",
	"cluster_state":                          "Description.Cluster.properties.clusterState",
	"diagnostics_storage_account_config":     "Description.Cluster.Properties.DiagnosticsStorageAccountConfig",
	"etag":                                   "Description.Cluster.etag",
	"event_store_service_enabled":            "Description.Cluster.properties.eventStoreServiceEnabled",
	"fabric_settings":                        "Description.Cluster.Properties.FabricSettings",
	"id":                                     "Description.Cluster.id",
	"management_endpoint":                    "Description.Cluster.properties.managementEndpoint",
	"name":                                   "description.Cluster.name",
	"node_types":                             "Description.Cluster.Properties.NodeTypes",
	"platform_integration_id":                "IntegrationID",
	"provisioning_state":                     "Description.Cluster.properties.provisioningState",
	"reliability_level":                      "Description.Cluster.properties.reliabilityLevel",
	"resource_group":                         "description.ResourceGroup",
	"reverse_proxy_certificate":              "Description.Cluster.Properties.ReverseProxyCertificate",
	"reverse_proxy_certificate_common_names": "Description.Cluster.Properties.ReverseProxyCertificateCommonNames",
	"subscription":                           "Description.Cluster.Properties.Subscription",
	"tags":                                   "Description.Cluster.Tags",
	"title":                                  "Description.Cluster.name",
	"type":                                   "Description.Cluster.type",
	"upgrade_description":                    "Description.Cluster.Properties.UpgradeDescription",
	"upgrade_mode":                           "Description.Cluster.properties.upgradeMode",
	"vm_image":                               "Description.Cluster.properties.vmImage",
}

func GetServiceFabricCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetServiceFabricCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewServiceFabricClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getServiceFabricClusterFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ServiceFabricCluster =============================

// ==========================  START: ServicebusNamespace =============================

type ServicebusNamespace struct {
	ResourceID      string                               `json:"resource_id"`
	PlatformID      string                               `json:"platform_id"`
	Description     azure.ServicebusNamespaceDescription `json:"Description"`
	Metadata        azure.Metadata                       `json:"metadata"`
	DescribedBy     string                               `json:"described_by"`
	ResourceType    string                               `json:"resource_type"`
	IntegrationType string                               `json:"integration_type"`
	IntegrationID   string                               `json:"integration_id"`
}

type ServicebusNamespaceHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  ServicebusNamespace `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type ServicebusNamespaceHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []ServicebusNamespaceHit `json:"hits"`
}

type ServicebusNamespaceSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  ServicebusNamespaceHits `json:"hits"`
}

type ServicebusNamespacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewServicebusNamespacePaginator(filters []essdk.BoolFilter, limit *int64) (ServicebusNamespacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_servicebus_namespaces", filters, limit)
	if err != nil {
		return ServicebusNamespacePaginator{}, err
	}

	p := ServicebusNamespacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ServicebusNamespacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ServicebusNamespacePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ServicebusNamespacePaginator) NextPage(ctx context.Context) ([]ServicebusNamespace, error) {
	var response ServicebusNamespaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ServicebusNamespace
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listServicebusNamespaceFilters = map[string]string{
	"authorization_rules":          "Description.AuthorizationRules",
	"diagnostic_settings":          "Description.DiagnosticSettingsResources",
	"disable_local_auth":           "Description.SBNamespace.properties.disableLocalAuth",
	"encryption":                   "Description.SBNamespace.Properties.Encryption",
	"id":                           "Description.SBNamespace.id",
	"metric_id":                    "Description.SBNamespace.properties.metricId",
	"name":                         "Description.SBNamespace.name",
	"network_rule_set":             "Description.NetworkRuleSet",
	"platform_integration_id":      "IntegrationID",
	"private_endpoint_connections": "Description.SBNamespace.Properties.PrivateEndpointConnections",
	"provisioning_state":           "Description.SBNamespace.properties.provisioningState",
	"resource_group":               "Description.ResourceGroup",
	"servicebus_endpoint":          "Description.SBNamespace.properties.serviceBusEndpoint",
	"sku_capacity":                 "Description.SBNamespace.sku.capacity",
	"sku_name":                     "Description.SBNamespace.sku.name",
	"sku_tier":                     "Description.SBNamespace.sku.tier",
	"status":                       "Description.SBNamespace.properties.status",
	"subscription":                 "Description.SBNamespace.Properties.Subscription",
	"tags":                         "Description.SBNamespace.Tags",
	"title":                        "Description.SBNamespace.name",
	"type":                         "Description.SBNamespace.type",
	"zone_redundant":               "Description.SBNamespace.properties.zoneRedundant",
}

func ListServicebusNamespace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListServicebusNamespace")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListServicebusNamespace NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListServicebusNamespace NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListServicebusNamespace GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListServicebusNamespace GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListServicebusNamespace GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewServicebusNamespacePaginator(essdk.BuildFilter(ctx, d.QueryContext, listServicebusNamespaceFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListServicebusNamespace NewServicebusNamespacePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListServicebusNamespace paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getServicebusNamespaceFilters = map[string]string{
	"authorization_rules":          "Description.AuthorizationRules",
	"diagnostic_settings":          "Description.DiagnosticSettingsResources",
	"disable_local_auth":           "Description.SBNamespace.properties.disableLocalAuth",
	"encryption":                   "Description.SBNamespace.Properties.Encryption",
	"id":                           "Description.SBNamespace.id",
	"metric_id":                    "Description.SBNamespace.properties.metricId",
	"name":                         "description.SBNamespace.name",
	"network_rule_set":             "Description.NetworkRuleSet",
	"platform_integration_id":      "IntegrationID",
	"private_endpoint_connections": "Description.SBNamespace.Properties.PrivateEndpointConnections",
	"provisioning_state":           "Description.SBNamespace.properties.provisioningState",
	"resource_group":               "description.ResourceGroup",
	"servicebus_endpoint":          "Description.SBNamespace.properties.serviceBusEndpoint",
	"sku_capacity":                 "Description.SBNamespace.sku.capacity",
	"sku_name":                     "Description.SBNamespace.sku.name",
	"sku_tier":                     "Description.SBNamespace.sku.tier",
	"status":                       "Description.SBNamespace.properties.status",
	"subscription":                 "Description.SBNamespace.Properties.Subscription",
	"tags":                         "Description.SBNamespace.Tags",
	"title":                        "Description.SBNamespace.name",
	"type":                         "Description.SBNamespace.type",
	"zone_redundant":               "Description.SBNamespace.properties.zoneRedundant",
}

func GetServicebusNamespace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetServicebusNamespace")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewServicebusNamespacePaginator(essdk.BuildFilter(ctx, d.QueryContext, getServicebusNamespaceFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ServicebusNamespace =============================

// ==========================  START: SignalrService =============================

type SignalrService struct {
	ResourceID      string                          `json:"resource_id"`
	PlatformID      string                          `json:"platform_id"`
	Description     azure.SignalrServiceDescription `json:"Description"`
	Metadata        azure.Metadata                  `json:"metadata"`
	DescribedBy     string                          `json:"described_by"`
	ResourceType    string                          `json:"resource_type"`
	IntegrationType string                          `json:"integration_type"`
	IntegrationID   string                          `json:"integration_id"`
}

type SignalrServiceHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  SignalrService `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type SignalrServiceHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []SignalrServiceHit `json:"hits"`
}

type SignalrServiceSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  SignalrServiceHits `json:"hits"`
}

type SignalrServicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSignalrServicePaginator(filters []essdk.BoolFilter, limit *int64) (SignalrServicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_signalrservice_signalr", filters, limit)
	if err != nil {
		return SignalrServicePaginator{}, err
	}

	p := SignalrServicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SignalrServicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SignalrServicePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SignalrServicePaginator) NextPage(ctx context.Context) ([]SignalrService, error) {
	var response SignalrServiceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SignalrService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSignalrServiceFilters = map[string]string{
	"cors":                    "Description.ResourceInfo.Properties.Cors",
	"diagnostic_settings":     "Description.DiagnosticSettingsResources",
	"external_ip":             "Description.ResourceInfo.properties.externalIP",
	"features":                "Description.ResourceInfo.Properties.Features",
	"host_name":               "Description.ResourceInfo.properties.hostName",
	"host_name_prefix":        "Description.ResourceInfo.properties.hostNamePrefix",
	"id":                      "Description.ResourceInfo.id",
	"kind":                    "Description.ResourceInfo.kind",
	"name":                    "Description.ResourceInfo.name",
	"network_acls":            "Description.ResourceInfo.Properties.NetworkACLs",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.ResourceInfo.properties.provisioningState",
	"public_port":             "Description.ResourceInfo.properties.publicPort",
	"resource_group":          "Description.ResourceGroup",
	"server_port":             "Description.ResourceInfo.properties.serverPort",
	"sku":                     "Description.ResourceInfo.SKU",
	"subscription":            "Description.ResourceInfo.Properties.Subscription",
	"tags":                    "Description.ResourceInfo.Tags",
	"title":                   "Description.ResourceInfo.name",
	"type":                    "Description.ResourceInfo.type",
	"upstream":                "Description.ResourceInfo.Properties.Upstream",
	"version":                 "Description.ResourceInfo.properties.version",
}

func ListSignalrService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSignalrService")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSignalrService NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSignalrService NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSignalrService GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSignalrService GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSignalrService GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSignalrServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, listSignalrServiceFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSignalrService NewSignalrServicePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSignalrService paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSignalrServiceFilters = map[string]string{
	"cors":                    "Description.ResourceInfo.Properties.Cors",
	"diagnostic_settings":     "Description.DiagnosticSettingsResources",
	"external_ip":             "Description.ResourceInfo.properties.externalIP",
	"features":                "Description.ResourceInfo.Properties.Features",
	"host_name":               "Description.ResourceInfo.properties.hostName",
	"host_name_prefix":        "Description.ResourceInfo.properties.hostNamePrefix",
	"id":                      "Description.ResourceInfo.id",
	"kind":                    "Description.ResourceInfo.kind",
	"name":                    "description.ResourceType.name",
	"network_acls":            "Description.ResourceInfo.Properties.NetworkACLs",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.ResourceInfo.properties.provisioningState",
	"public_port":             "Description.ResourceInfo.properties.publicPort",
	"resource_group":          "description.ResourceGroup",
	"server_port":             "Description.ResourceInfo.properties.serverPort",
	"sku":                     "Description.ResourceInfo.SKU",
	"subscription":            "Description.ResourceInfo.Properties.Subscription",
	"tags":                    "Description.ResourceInfo.Tags",
	"title":                   "Description.ResourceInfo.name",
	"type":                    "Description.ResourceInfo.type",
	"upstream":                "Description.ResourceInfo.Properties.Upstream",
	"version":                 "Description.ResourceInfo.properties.version",
}

func GetSignalrService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSignalrService")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSignalrServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, getSignalrServiceFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SignalrService =============================

// ==========================  START: SpringCloudService =============================

type SpringCloudService struct {
	ResourceID      string                              `json:"resource_id"`
	PlatformID      string                              `json:"platform_id"`
	Description     azure.SpringCloudServiceDescription `json:"Description"`
	Metadata        azure.Metadata                      `json:"metadata"`
	DescribedBy     string                              `json:"described_by"`
	ResourceType    string                              `json:"resource_type"`
	IntegrationType string                              `json:"integration_type"`
	IntegrationID   string                              `json:"integration_id"`
}

type SpringCloudServiceHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  SpringCloudService `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type SpringCloudServiceHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []SpringCloudServiceHit `json:"hits"`
}

type SpringCloudServiceSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  SpringCloudServiceHits `json:"hits"`
}

type SpringCloudServicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSpringCloudServicePaginator(filters []essdk.BoolFilter, limit *int64) (SpringCloudServicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_appplatform_spring", filters, limit)
	if err != nil {
		return SpringCloudServicePaginator{}, err
	}

	p := SpringCloudServicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SpringCloudServicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SpringCloudServicePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SpringCloudServicePaginator) NextPage(ctx context.Context) ([]SpringCloudService, error) {
	var response SpringCloudServiceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SpringCloudService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSpringCloudServiceFilters = map[string]string{
	"diagnostic_settings":     "Description.DiagnosticSettingsResource",
	"id":                      "Description.App.id",
	"name":                    "Description.App.name",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.App.properties.provisioningState",
	"resource_group":          "Description.ResourceGroup",
	"subscription":            "Description.App.Properties.Subscription",
	"tags":                    "Description.App.Tags",
	"title":                   "Description.App.name",
	"type":                    "Description.App.properties.appType",
	"version":                 "Description.App.properties.springBootVersion",
}

func ListSpringCloudService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSpringCloudService")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSpringCloudService NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSpringCloudService NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSpringCloudService GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSpringCloudService GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSpringCloudService GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSpringCloudServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, listSpringCloudServiceFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSpringCloudService NewSpringCloudServicePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSpringCloudService paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSpringCloudServiceFilters = map[string]string{
	"diagnostic_settings":     "Description.DiagnosticSettingsResource",
	"id":                      "Description.App.id",
	"name":                    "description.ServiceResource.name",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.App.properties.provisioningState",
	"resource_group":          "description.ResourceGroup",
	"subscription":            "Description.App.Properties.Subscription",
	"tags":                    "Description.App.Tags",
	"title":                   "Description.App.name",
	"type":                    "Description.App.properties.appType",
	"version":                 "Description.App.properties.springBootVersion",
}

func GetSpringCloudService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSpringCloudService")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSpringCloudServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, getSpringCloudServiceFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SpringCloudService =============================

// ==========================  START: StreamAnalyticsJob =============================

type StreamAnalyticsJob struct {
	ResourceID      string                              `json:"resource_id"`
	PlatformID      string                              `json:"platform_id"`
	Description     azure.StreamAnalyticsJobDescription `json:"Description"`
	Metadata        azure.Metadata                      `json:"metadata"`
	DescribedBy     string                              `json:"described_by"`
	ResourceType    string                              `json:"resource_type"`
	IntegrationType string                              `json:"integration_type"`
	IntegrationID   string                              `json:"integration_id"`
}

type StreamAnalyticsJobHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  StreamAnalyticsJob `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type StreamAnalyticsJobHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []StreamAnalyticsJobHit `json:"hits"`
}

type StreamAnalyticsJobSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  StreamAnalyticsJobHits `json:"hits"`
}

type StreamAnalyticsJobPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStreamAnalyticsJobPaginator(filters []essdk.BoolFilter, limit *int64) (StreamAnalyticsJobPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_streamanalytics_streamingjobs", filters, limit)
	if err != nil {
		return StreamAnalyticsJobPaginator{}, err
	}

	p := StreamAnalyticsJobPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StreamAnalyticsJobPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StreamAnalyticsJobPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p StreamAnalyticsJobPaginator) NextPage(ctx context.Context) ([]StreamAnalyticsJob, error) {
	var response StreamAnalyticsJobSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StreamAnalyticsJob
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStreamAnalyticsJobFilters = map[string]string{
	"compatibility_level": "Description.StreamingJob.properties.compatibilityLevel",
	"data_locale":         "Description.StreamingJob.properties.dataLocale",
	"diagnostic_settings": "Description.DiagnosticSettingsResources",
	"etag":                "Description.StreamingJob.properties.etag",
	"events_late_arrival_max_delay_in_seconds": "Description.StreamingJob.properties.eventsLateArrivalMaxDelayInSeconds",
	"events_out_of_order_max_delay_in_seconds": "Description.StreamingJob.properties.eventsOutOfOrderMaxDelayInSeconds",
	"events_out_of_order_policy":               "Description.StreamingJob.properties.eventsOutOfOrderPolicy",
	"functions":                                "Description.StreamingJob.Properties.Functions",
	"id":                                       "Description.StreamingJob.id",
	"inputs":                                   "Description.StreamingJob.Properties.Inputs",
	"job_id":                                   "Description.StreamingJob.properties.jobId",
	"job_state":                                "Description.StreamingJob.properties.jobState",
	"name":                                     "Description.StreamingJob.name",
	"output_error_policy":                      "Description.StreamingJob.properties.outputErrorPolicy",
	"output_start_mode":                        "Description.StreamingJob.properties.outputStartMode",
	"outputs":                                  "Description.StreamingJob.Properties.Outputs",
	"platform_integration_id":                  "IntegrationID",
	"provisioning_state":                       "Description.StreamingJob.properties.provisioningState",
	"resource_group":                           "Description.ResourceGroup",
	"sku_name":                                 "Description.StreamingJob.properties.sku.name",
	"subscription":                             "Description.StreamingJob.Properties.Subscription",
	"tags":                                     "Description.StreamingJob.Tags",
	"title":                                    "Description.StreamingJob.name",
	"transformation":                           "Description.StreamingJob.Properties.Transformation",
	"type":                                     "Description.StreamingJob.type",
}

func ListStreamAnalyticsJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStreamAnalyticsJob")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListStreamAnalyticsJob NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListStreamAnalyticsJob NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListStreamAnalyticsJob GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListStreamAnalyticsJob GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListStreamAnalyticsJob GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewStreamAnalyticsJobPaginator(essdk.BuildFilter(ctx, d.QueryContext, listStreamAnalyticsJobFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListStreamAnalyticsJob NewStreamAnalyticsJobPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListStreamAnalyticsJob paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getStreamAnalyticsJobFilters = map[string]string{
	"compatibility_level": "Description.StreamingJob.properties.compatibilityLevel",
	"data_locale":         "Description.StreamingJob.properties.dataLocale",
	"diagnostic_settings": "Description.DiagnosticSettingsResources",
	"etag":                "Description.StreamingJob.properties.etag",
	"events_late_arrival_max_delay_in_seconds": "Description.StreamingJob.properties.eventsLateArrivalMaxDelayInSeconds",
	"events_out_of_order_max_delay_in_seconds": "Description.StreamingJob.properties.eventsOutOfOrderMaxDelayInSeconds",
	"events_out_of_order_policy":               "Description.StreamingJob.properties.eventsOutOfOrderPolicy",
	"functions":                                "Description.StreamingJob.Properties.Functions",
	"id":                                       "Description.StreamingJob.id",
	"inputs":                                   "Description.StreamingJob.Properties.Inputs",
	"job_id":                                   "Description.StreamingJob.properties.jobId",
	"job_state":                                "Description.StreamingJob.properties.jobState",
	"name":                                     "description.StreamingJob.name",
	"output_error_policy":                      "Description.StreamingJob.properties.outputErrorPolicy",
	"output_start_mode":                        "Description.StreamingJob.properties.outputStartMode",
	"outputs":                                  "Description.StreamingJob.Properties.Outputs",
	"platform_integration_id":                  "IntegrationID",
	"provisioning_state":                       "Description.StreamingJob.properties.provisioningState",
	"resource_group":                           "description.ResourceGroup",
	"sku_name":                                 "Description.StreamingJob.properties.sku.name",
	"subscription":                             "Description.StreamingJob.Properties.Subscription",
	"tags":                                     "Description.StreamingJob.Tags",
	"title":                                    "Description.StreamingJob.name",
	"transformation":                           "Description.StreamingJob.Properties.Transformation",
	"type":                                     "Description.StreamingJob.type",
}

func GetStreamAnalyticsJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStreamAnalyticsJob")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewStreamAnalyticsJobPaginator(essdk.BuildFilter(ctx, d.QueryContext, getStreamAnalyticsJobFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: StreamAnalyticsJob =============================

// ==========================  START: StreamAnalyticsCluster =============================

type StreamAnalyticsCluster struct {
	ResourceID      string                                  `json:"resource_id"`
	PlatformID      string                                  `json:"platform_id"`
	Description     azure.StreamAnalyticsClusterDescription `json:"Description"`
	Metadata        azure.Metadata                          `json:"metadata"`
	DescribedBy     string                                  `json:"described_by"`
	ResourceType    string                                  `json:"resource_type"`
	IntegrationType string                                  `json:"integration_type"`
	IntegrationID   string                                  `json:"integration_id"`
}

type StreamAnalyticsClusterHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  StreamAnalyticsCluster `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type StreamAnalyticsClusterHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []StreamAnalyticsClusterHit `json:"hits"`
}

type StreamAnalyticsClusterSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  StreamAnalyticsClusterHits `json:"hits"`
}

type StreamAnalyticsClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStreamAnalyticsClusterPaginator(filters []essdk.BoolFilter, limit *int64) (StreamAnalyticsClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_streamanalytics_cluster", filters, limit)
	if err != nil {
		return StreamAnalyticsClusterPaginator{}, err
	}

	p := StreamAnalyticsClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StreamAnalyticsClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StreamAnalyticsClusterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p StreamAnalyticsClusterPaginator) NextPage(ctx context.Context) ([]StreamAnalyticsCluster, error) {
	var response StreamAnalyticsClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StreamAnalyticsCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStreamAnalyticsClusterFilters = map[string]string{
	"id":                      "Description.Cluster.ID",
	"name":                    "Description.StreamingJob.sku.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Cluster.Properties.Subscription",
	"tags":                    "Description.StreamingJob.Tags",
	"title":                   "Description.StreamingJob.sku.name",
}

func ListStreamAnalyticsCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStreamAnalyticsCluster")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListStreamAnalyticsCluster NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListStreamAnalyticsCluster NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListStreamAnalyticsCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListStreamAnalyticsCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListStreamAnalyticsCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewStreamAnalyticsClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listStreamAnalyticsClusterFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListStreamAnalyticsCluster NewStreamAnalyticsClusterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListStreamAnalyticsCluster paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getStreamAnalyticsClusterFilters = map[string]string{
	"id":                      "Description.Cluster.ID",
	"name":                    "Description.StreamingJob.sku.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Cluster.Properties.Subscription",
	"tags":                    "Description.StreamingJob.Tags",
	"title":                   "Description.StreamingJob.sku.name",
}

func GetStreamAnalyticsCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStreamAnalyticsCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewStreamAnalyticsClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getStreamAnalyticsClusterFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: StreamAnalyticsCluster =============================

// ==========================  START: VirtualMachineImagesImageTemplates =============================

type VirtualMachineImagesImageTemplates struct {
	ResourceID      string                                              `json:"resource_id"`
	PlatformID      string                                              `json:"platform_id"`
	Description     azure.VirtualMachineImagesImageTemplatesDescription `json:"Description"`
	Metadata        azure.Metadata                                      `json:"metadata"`
	DescribedBy     string                                              `json:"described_by"`
	ResourceType    string                                              `json:"resource_type"`
	IntegrationType string                                              `json:"integration_type"`
	IntegrationID   string                                              `json:"integration_id"`
}

type VirtualMachineImagesImageTemplatesHit struct {
	ID      string                             `json:"_id"`
	Score   float64                            `json:"_score"`
	Index   string                             `json:"_index"`
	Type    string                             `json:"_type"`
	Version int64                              `json:"_version,omitempty"`
	Source  VirtualMachineImagesImageTemplates `json:"_source"`
	Sort    []interface{}                      `json:"sort"`
}

type VirtualMachineImagesImageTemplatesHits struct {
	Total essdk.SearchTotal                       `json:"total"`
	Hits  []VirtualMachineImagesImageTemplatesHit `json:"hits"`
}

type VirtualMachineImagesImageTemplatesSearchResponse struct {
	PitID string                                 `json:"pit_id"`
	Hits  VirtualMachineImagesImageTemplatesHits `json:"hits"`
}

type VirtualMachineImagesImageTemplatesPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewVirtualMachineImagesImageTemplatesPaginator(filters []essdk.BoolFilter, limit *int64) (VirtualMachineImagesImageTemplatesPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_virtualmachineimages_imagetemplates", filters, limit)
	if err != nil {
		return VirtualMachineImagesImageTemplatesPaginator{}, err
	}

	p := VirtualMachineImagesImageTemplatesPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p VirtualMachineImagesImageTemplatesPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p VirtualMachineImagesImageTemplatesPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p VirtualMachineImagesImageTemplatesPaginator) NextPage(ctx context.Context) ([]VirtualMachineImagesImageTemplates, error) {
	var response VirtualMachineImagesImageTemplatesSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []VirtualMachineImagesImageTemplates
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listVirtualMachineImagesImageTemplatesFilters = map[string]string{
	"id":                      "Description.ImageTemplates.ID",
	"name":                    "Description.ImageTemplate.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.ImageTemplates.Subscription",
	"tags":                    "Description.ImageTemplate.Tags",
	"title":                   "Description.ImageTemplate.name",
}

func ListVirtualMachineImagesImageTemplates(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListVirtualMachineImagesImageTemplates")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualMachineImagesImageTemplates NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualMachineImagesImageTemplates NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualMachineImagesImageTemplates GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualMachineImagesImageTemplates GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualMachineImagesImageTemplates GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewVirtualMachineImagesImageTemplatesPaginator(essdk.BuildFilter(ctx, d.QueryContext, listVirtualMachineImagesImageTemplatesFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListVirtualMachineImagesImageTemplates NewVirtualMachineImagesImageTemplatesPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListVirtualMachineImagesImageTemplates paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getVirtualMachineImagesImageTemplatesFilters = map[string]string{
	"id":                      "Description.ImageTemplates.ID",
	"name":                    "Description.ImageTemplate.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.ImageTemplates.Subscription",
	"tags":                    "Description.ImageTemplate.Tags",
	"title":                   "Description.ImageTemplate.name",
}

func GetVirtualMachineImagesImageTemplates(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetVirtualMachineImagesImageTemplates")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewVirtualMachineImagesImageTemplatesPaginator(essdk.BuildFilter(ctx, d.QueryContext, getVirtualMachineImagesImageTemplatesFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: VirtualMachineImagesImageTemplates =============================

// ==========================  START: OperationalInsightsWorkspaces =============================

type OperationalInsightsWorkspaces struct {
	ResourceID      string                                         `json:"resource_id"`
	PlatformID      string                                         `json:"platform_id"`
	Description     azure.OperationalInsightsWorkspacesDescription `json:"Description"`
	Metadata        azure.Metadata                                 `json:"metadata"`
	DescribedBy     string                                         `json:"described_by"`
	ResourceType    string                                         `json:"resource_type"`
	IntegrationType string                                         `json:"integration_type"`
	IntegrationID   string                                         `json:"integration_id"`
}

type OperationalInsightsWorkspacesHit struct {
	ID      string                        `json:"_id"`
	Score   float64                       `json:"_score"`
	Index   string                        `json:"_index"`
	Type    string                        `json:"_type"`
	Version int64                         `json:"_version,omitempty"`
	Source  OperationalInsightsWorkspaces `json:"_source"`
	Sort    []interface{}                 `json:"sort"`
}

type OperationalInsightsWorkspacesHits struct {
	Total essdk.SearchTotal                  `json:"total"`
	Hits  []OperationalInsightsWorkspacesHit `json:"hits"`
}

type OperationalInsightsWorkspacesSearchResponse struct {
	PitID string                            `json:"pit_id"`
	Hits  OperationalInsightsWorkspacesHits `json:"hits"`
}

type OperationalInsightsWorkspacesPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOperationalInsightsWorkspacesPaginator(filters []essdk.BoolFilter, limit *int64) (OperationalInsightsWorkspacesPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_operationalinsights_workspaces", filters, limit)
	if err != nil {
		return OperationalInsightsWorkspacesPaginator{}, err
	}

	p := OperationalInsightsWorkspacesPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OperationalInsightsWorkspacesPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OperationalInsightsWorkspacesPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p OperationalInsightsWorkspacesPaginator) NextPage(ctx context.Context) ([]OperationalInsightsWorkspaces, error) {
	var response OperationalInsightsWorkspacesSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OperationalInsightsWorkspaces
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOperationalInsightsWorkspacesFilters = map[string]string{
	"cluster_resource_id": "Description.Workspace.properties.features.clusterResourceId",
	"customer_id":         "WDescription.Workspace.Properties.CustomerID",
	"disable_local_auth":  "Description.Workspace..Properties.Features.DisableLocalAuth",
	"enable_data_export":  "WDescription.Workspace.Properties.Features.EnableDataExport",
	"enable_log_access_using_only_resource_permissions": "WDescription.Workspace.Properties.Features.EnableLogAccessUsingOnlyResourcePermissions",
	"force_cmk_for_query":                               "Description.Workspace.properties.forceCmkForQuery",
	"id":                                                "Description.Workspaces.ID",
	"immediate_purge_data_on_30_days":                   "Description.Workspace.properties.features.immediatePurgeDataOn30Days",
	"location":                                          "Description.Workspace.location",
	"name":                                              "Description.Workspace.name",
	"platform_integration_id":                           "IntegrationID",
	"private_link_scoped_resources":                     "Description.Workspace.Properties.PrivateLinkScopedResources",
	"provisioning_state":                                "Description.Workspace.properties.provisioningState",
	"public_network_access_for_ingestion":               "Description.Workspace.properties.publicNetworkAccessForIngestion",
	"public_network_access_for_query":                   "Description.Workspace.properties.publicNetworkAccessForQuery",
	"resource_group":                                    "Description.ResourceGroup",
	"retention_in_days":                                 "Description.Workspace.properties.retentionInDays",
	"sku":                                               "Description.Workspace.Properties.SKU",
	"subscription":                                      "Description.Workspaces.Properties.Subscription",
	"tags":                                              "Description.Workspace.Tags",
	"title":                                             "Description.Workspace.name",
	"type":                                              "Description.Workspace.type",
	"workspace_capping":                                 "Description.Workspace.Properties.WorkspaceCapping",
}

func ListOperationalInsightsWorkspaces(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOperationalInsightsWorkspaces")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListOperationalInsightsWorkspaces NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListOperationalInsightsWorkspaces NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListOperationalInsightsWorkspaces GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListOperationalInsightsWorkspaces GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListOperationalInsightsWorkspaces GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewOperationalInsightsWorkspacesPaginator(essdk.BuildFilter(ctx, d.QueryContext, listOperationalInsightsWorkspacesFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListOperationalInsightsWorkspaces NewOperationalInsightsWorkspacesPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListOperationalInsightsWorkspaces paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getOperationalInsightsWorkspacesFilters = map[string]string{
	"cluster_resource_id": "Description.Workspace.properties.features.clusterResourceId",
	"customer_id":         "WDescription.Workspace.Properties.CustomerID",
	"disable_local_auth":  "Description.Workspace..Properties.Features.DisableLocalAuth",
	"enable_data_export":  "WDescription.Workspace.Properties.Features.EnableDataExport",
	"enable_log_access_using_only_resource_permissions": "WDescription.Workspace.Properties.Features.EnableLogAccessUsingOnlyResourcePermissions",
	"force_cmk_for_query":                               "Description.Workspace.properties.forceCmkForQuery",
	"id":                                                "Description.Workspaces.ID",
	"immediate_purge_data_on_30_days":                   "Description.Workspace.properties.features.immediatePurgeDataOn30Days",
	"location":                                          "Description.Workspace.location",
	"name":                                              "Description.Workspace.name",
	"platform_integration_id":                           "IntegrationID",
	"private_link_scoped_resources":                     "Description.Workspace.Properties.PrivateLinkScopedResources",
	"provisioning_state":                                "Description.Workspace.properties.provisioningState",
	"public_network_access_for_ingestion":               "Description.Workspace.properties.publicNetworkAccessForIngestion",
	"public_network_access_for_query":                   "Description.Workspace.properties.publicNetworkAccessForQuery",
	"resource_group":                                    "Description.ResourceGroup",
	"retention_in_days":                                 "Description.Workspace.properties.retentionInDays",
	"sku":                                               "Description.Workspace.Properties.SKU",
	"subscription":                                      "Description.Workspaces.Properties.Subscription",
	"tags":                                              "Description.Workspace.Tags",
	"title":                                             "Description.Workspace.name",
	"type":                                              "Description.Workspace.type",
	"workspace_capping":                                 "Description.Workspace.Properties.WorkspaceCapping",
}

func GetOperationalInsightsWorkspaces(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOperationalInsightsWorkspaces")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewOperationalInsightsWorkspacesPaginator(essdk.BuildFilter(ctx, d.QueryContext, getOperationalInsightsWorkspacesFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: OperationalInsightsWorkspaces =============================

// ==========================  START: SynapseWorkspace =============================

type SynapseWorkspace struct {
	ResourceID      string                            `json:"resource_id"`
	PlatformID      string                            `json:"platform_id"`
	Description     azure.SynapseWorkspaceDescription `json:"Description"`
	Metadata        azure.Metadata                    `json:"metadata"`
	DescribedBy     string                            `json:"described_by"`
	ResourceType    string                            `json:"resource_type"`
	IntegrationType string                            `json:"integration_type"`
	IntegrationID   string                            `json:"integration_id"`
}

type SynapseWorkspaceHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  SynapseWorkspace `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type SynapseWorkspaceHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []SynapseWorkspaceHit `json:"hits"`
}

type SynapseWorkspaceSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  SynapseWorkspaceHits `json:"hits"`
}

type SynapseWorkspacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSynapseWorkspacePaginator(filters []essdk.BoolFilter, limit *int64) (SynapseWorkspacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_synapse_workspaces", filters, limit)
	if err != nil {
		return SynapseWorkspacePaginator{}, err
	}

	p := SynapseWorkspacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SynapseWorkspacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SynapseWorkspacePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SynapseWorkspacePaginator) NextPage(ctx context.Context) ([]SynapseWorkspace, error) {
	var response SynapseWorkspaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SynapseWorkspace
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSynapseWorkspaceFilters = map[string]string{
	"adla_resource_id":                 "Description.Workspace.properties.adlaResourceId",
	"connectivity_endpoints":           "Description.Workspace.Properties.ConnectivityEndpoints",
	"default_data_lake_storage":        "Description.Workspace.Properties.DefaultDataLakeStorage",
	"diagnostic_settings":              "Description.DiagnosticSettingsResources",
	"extra_properties":                 "Description.Workspace.Properties.ExtraProperties",
	"id":                               "Description.Workspace.id",
	"identity":                         "Description.Workspace.Identity",
	"managed_resource_group_name":      "Description.Workspace.properties.managedResourceGroupName",
	"managed_virtual_network":          "Description.Workspace.properties.managedVirtualNetwork",
	"managed_virtual_network_settings": "Description.Workspace.Properties.ManagedVirtualNetworkSettings",
	"name":                             "Description.Workspace.name",
	"platform_integration_id":          "IntegrationID",
	"provisioning_state":               "Description.Workspace.properties.provisioningState",
	"public_network_access":            "Description.Workspace.properties.publicNetworkAccess",
	"purview_configuration":            "Description.Workspace.Properties.PurviewConfiguration",
	"resource_group":                   "Description.ResourceGroup",
	"sql_administrator_login":          "Description.Workspace.properties.sqlAdministratorLogin",
	"sql_administrator_login_password": "Description.Workspace.properties.sqlAdministratorLoginPassword",
	"subscription":                     "Description.Workspace.Properties.Subscription",
	"tags":                             "Description.Workspace.Tags",
	"title":                            "Description.Workspace.name",
	"type":                             "Description.Workspace.type",
	"virtual_network_profile":          "Description.Workspace.Properties.VirtualNetworkProfile",
	"workspace_managed_sql_server_vulnerability_assessments": "Description.ServerVulnerabilityAssessments",
	"workspace_repository_configuration":                     "Description.Workspace.Properties.WorkspaceRepositoryConfiguration",
	"workspace_uid":                                          "Description.Workspace.properties.workspaceUID",
}

func ListSynapseWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSynapseWorkspace")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSynapseWorkspace NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSynapseWorkspace NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSynapseWorkspace GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSynapseWorkspace GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSynapseWorkspace GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSynapseWorkspacePaginator(essdk.BuildFilter(ctx, d.QueryContext, listSynapseWorkspaceFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSynapseWorkspace NewSynapseWorkspacePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSynapseWorkspace paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSynapseWorkspaceFilters = map[string]string{
	"adla_resource_id":                 "Description.Workspace.properties.adlaResourceId",
	"connectivity_endpoints":           "Description.Workspace.Properties.ConnectivityEndpoints",
	"default_data_lake_storage":        "Description.Workspace.Properties.DefaultDataLakeStorage",
	"diagnostic_settings":              "Description.DiagnosticSettingsResources",
	"extra_properties":                 "Description.Workspace.Properties.ExtraProperties",
	"id":                               "Description.Workspace.id",
	"identity":                         "Description.Workspace.Identity",
	"managed_resource_group_name":      "Description.Workspace.properties.managedResourceGroupName",
	"managed_virtual_network":          "Description.Workspace.properties.managedVirtualNetwork",
	"managed_virtual_network_settings": "Description.Workspace.Properties.ManagedVirtualNetworkSettings",
	"name":                             "description.Workspace.name",
	"platform_integration_id":          "IntegrationID",
	"provisioning_state":               "Description.Workspace.properties.provisioningState",
	"public_network_access":            "Description.Workspace.properties.publicNetworkAccess",
	"purview_configuration":            "Description.Workspace.Properties.PurviewConfiguration",
	"resource_group":                   "description.ResourceGroup",
	"sql_administrator_login":          "Description.Workspace.properties.sqlAdministratorLogin",
	"sql_administrator_login_password": "Description.Workspace.properties.sqlAdministratorLoginPassword",
	"subscription":                     "Description.Workspace.Properties.Subscription",
	"tags":                             "Description.Workspace.Tags",
	"title":                            "Description.Workspace.name",
	"type":                             "Description.Workspace.type",
	"virtual_network_profile":          "Description.Workspace.Properties.VirtualNetworkProfile",
	"workspace_managed_sql_server_vulnerability_assessments": "Description.ServerVulnerabilityAssessments",
	"workspace_repository_configuration":                     "Description.Workspace.Properties.WorkspaceRepositoryConfiguration",
	"workspace_uid":                                          "Description.Workspace.properties.workspaceUID",
}

func GetSynapseWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSynapseWorkspace")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSynapseWorkspacePaginator(essdk.BuildFilter(ctx, d.QueryContext, getSynapseWorkspaceFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SynapseWorkspace =============================

// ==========================  START: SynapseWorkspaceBigdatapools =============================

type SynapseWorkspaceBigdatapools struct {
	ResourceID      string                                        `json:"resource_id"`
	PlatformID      string                                        `json:"platform_id"`
	Description     azure.SynapseWorkspaceBigdatapoolsDescription `json:"Description"`
	Metadata        azure.Metadata                                `json:"metadata"`
	DescribedBy     string                                        `json:"described_by"`
	ResourceType    string                                        `json:"resource_type"`
	IntegrationType string                                        `json:"integration_type"`
	IntegrationID   string                                        `json:"integration_id"`
}

type SynapseWorkspaceBigdatapoolsHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  SynapseWorkspaceBigdatapools `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type SynapseWorkspaceBigdatapoolsHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []SynapseWorkspaceBigdatapoolsHit `json:"hits"`
}

type SynapseWorkspaceBigdatapoolsSearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  SynapseWorkspaceBigdatapoolsHits `json:"hits"`
}

type SynapseWorkspaceBigdatapoolsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSynapseWorkspaceBigdatapoolsPaginator(filters []essdk.BoolFilter, limit *int64) (SynapseWorkspaceBigdatapoolsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_synapse_workspaces_bigdatapools", filters, limit)
	if err != nil {
		return SynapseWorkspaceBigdatapoolsPaginator{}, err
	}

	p := SynapseWorkspaceBigdatapoolsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SynapseWorkspaceBigdatapoolsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SynapseWorkspaceBigdatapoolsPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SynapseWorkspaceBigdatapoolsPaginator) NextPage(ctx context.Context) ([]SynapseWorkspaceBigdatapools, error) {
	var response SynapseWorkspaceBigdatapoolsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SynapseWorkspaceBigdatapools
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSynapseWorkspaceBigdatapoolsFilters = map[string]string{
	"id":                      "Description.BigDataPool.id",
	"name":                    "Description.BigDataPool.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.BigDataPool.Properties.Subscription",
	"tags":                    "Description.BigDataPool.Tags",
	"title":                   "Description.BigDataPool.name",
}

func ListSynapseWorkspaceBigdatapools(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSynapseWorkspaceBigdatapools")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSynapseWorkspaceBigdatapools NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSynapseWorkspaceBigdatapools NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSynapseWorkspaceBigdatapools GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSynapseWorkspaceBigdatapools GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSynapseWorkspaceBigdatapools GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSynapseWorkspaceBigdatapoolsPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSynapseWorkspaceBigdatapoolsFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSynapseWorkspaceBigdatapools NewSynapseWorkspaceBigdatapoolsPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSynapseWorkspaceBigdatapools paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSynapseWorkspaceBigdatapoolsFilters = map[string]string{
	"id":                      "Description.BigDataPool.id",
	"name":                    "Description.BigDataPool.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.BigDataPool.Properties.Subscription",
	"tags":                    "Description.BigDataPool.Tags",
	"title":                   "Description.BigDataPool.name",
}

func GetSynapseWorkspaceBigdatapools(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSynapseWorkspaceBigdatapools")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSynapseWorkspaceBigdatapoolsPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSynapseWorkspaceBigdatapoolsFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SynapseWorkspaceBigdatapools =============================

// ==========================  START: SynapseWorkspaceSqlpools =============================

type SynapseWorkspaceSqlpools struct {
	ResourceID      string                                    `json:"resource_id"`
	PlatformID      string                                    `json:"platform_id"`
	Description     azure.SynapseWorkspaceSqlpoolsDescription `json:"Description"`
	Metadata        azure.Metadata                            `json:"metadata"`
	DescribedBy     string                                    `json:"described_by"`
	ResourceType    string                                    `json:"resource_type"`
	IntegrationType string                                    `json:"integration_type"`
	IntegrationID   string                                    `json:"integration_id"`
}

type SynapseWorkspaceSqlpoolsHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  SynapseWorkspaceSqlpools `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type SynapseWorkspaceSqlpoolsHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []SynapseWorkspaceSqlpoolsHit `json:"hits"`
}

type SynapseWorkspaceSqlpoolsSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  SynapseWorkspaceSqlpoolsHits `json:"hits"`
}

type SynapseWorkspaceSqlpoolsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSynapseWorkspaceSqlpoolsPaginator(filters []essdk.BoolFilter, limit *int64) (SynapseWorkspaceSqlpoolsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_synapse_workspaces_sqlpools", filters, limit)
	if err != nil {
		return SynapseWorkspaceSqlpoolsPaginator{}, err
	}

	p := SynapseWorkspaceSqlpoolsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SynapseWorkspaceSqlpoolsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SynapseWorkspaceSqlpoolsPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SynapseWorkspaceSqlpoolsPaginator) NextPage(ctx context.Context) ([]SynapseWorkspaceSqlpools, error) {
	var response SynapseWorkspaceSqlpoolsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SynapseWorkspaceSqlpools
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSynapseWorkspaceSqlpoolsFilters = map[string]string{
	"id":                      "Description.SqlPool.id",
	"name":                    "Description.SqlPool.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.SqlPool.Properties.Subscription",
	"tags":                    "Description.SqlPool.Tags",
	"title":                   "Description.SqlPool.name",
}

func ListSynapseWorkspaceSqlpools(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSynapseWorkspaceSqlpools")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSynapseWorkspaceSqlpools NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSynapseWorkspaceSqlpools NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSynapseWorkspaceSqlpools GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSynapseWorkspaceSqlpools GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSynapseWorkspaceSqlpools GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSynapseWorkspaceSqlpoolsPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSynapseWorkspaceSqlpoolsFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSynapseWorkspaceSqlpools NewSynapseWorkspaceSqlpoolsPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSynapseWorkspaceSqlpools paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSynapseWorkspaceSqlpoolsFilters = map[string]string{
	"id":                      "Description.SqlPool.id",
	"name":                    "Description.SqlPool.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.SqlPool.Properties.Subscription",
	"tags":                    "Description.SqlPool.Tags",
	"title":                   "Description.SqlPool.name",
}

func GetSynapseWorkspaceSqlpools(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSynapseWorkspaceSqlpools")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSynapseWorkspaceSqlpoolsPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSynapseWorkspaceSqlpoolsFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SynapseWorkspaceSqlpools =============================

// ==========================  START: Location =============================

type Location struct {
	ResourceID      string                    `json:"resource_id"`
	PlatformID      string                    `json:"platform_id"`
	Description     azure.LocationDescription `json:"Description"`
	Metadata        azure.Metadata            `json:"metadata"`
	DescribedBy     string                    `json:"described_by"`
	ResourceType    string                    `json:"resource_type"`
	IntegrationType string                    `json:"integration_type"`
	IntegrationID   string                    `json:"integration_id"`
}

type LocationHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Location      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type LocationHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []LocationHit     `json:"hits"`
}

type LocationSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  LocationHits `json:"hits"`
}

type LocationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLocationPaginator(filters []essdk.BoolFilter, limit *int64) (LocationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_resources_subscriptions_locations", filters, limit)
	if err != nil {
		return LocationPaginator{}, err
	}

	p := LocationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LocationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LocationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LocationPaginator) NextPage(ctx context.Context) ([]Location, error) {
	var response LocationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Location
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLocationFilters = map[string]string{
	"display_name":            "Description.Location.displayName",
	"id":                      "Description.Location.id",
	"latitude":                "Description.Location.latitude",
	"longitude":               "Description.Location.longitude",
	"name":                    "Description.Location.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Location.Properties.Subscription",
	"title":                   "Description.Location.name",
}

func ListLocation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLocation")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLocation NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLocation NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLocation GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLocation GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLocation GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLocationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listLocationFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLocation NewLocationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLocation paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLocationFilters = map[string]string{
	"display_name":            "Description.Location.displayName",
	"id":                      "Description.Location.id",
	"latitude":                "Description.Location.latitude",
	"longitude":               "Description.Location.longitude",
	"name":                    "description.Location.name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "description.ResourceGroup",
	"subscription":            "Description.Location.Properties.Subscription",
	"title":                   "Description.Location.name",
}

func GetLocation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLocation")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLocationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getLocationFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Location =============================

// ==========================  START: AnalysisServiceServer =============================

type AnalysisServiceServer struct {
	ResourceID      string                                 `json:"resource_id"`
	PlatformID      string                                 `json:"platform_id"`
	Description     azure.AnalysisServiceServerDescription `json:"Description"`
	Metadata        azure.Metadata                         `json:"metadata"`
	DescribedBy     string                                 `json:"described_by"`
	ResourceType    string                                 `json:"resource_type"`
	IntegrationType string                                 `json:"integration_type"`
	IntegrationID   string                                 `json:"integration_id"`
}

type AnalysisServiceServerHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  AnalysisServiceServer `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type AnalysisServiceServerHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []AnalysisServiceServerHit `json:"hits"`
}

type AnalysisServiceServerSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  AnalysisServiceServerHits `json:"hits"`
}

type AnalysisServiceServerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAnalysisServiceServerPaginator(filters []essdk.BoolFilter, limit *int64) (AnalysisServiceServerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_analysisservices_servers", filters, limit)
	if err != nil {
		return AnalysisServiceServerPaginator{}, err
	}

	p := AnalysisServiceServerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AnalysisServiceServerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AnalysisServiceServerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AnalysisServiceServerPaginator) NextPage(ctx context.Context) ([]AnalysisServiceServer, error) {
	var response AnalysisServiceServerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AnalysisServiceServer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAnalysisServiceServerFilters = map[string]string{
	"id":                      "Description.Servers.ID",
	"name":                    "Description.Server.properties.serverFullName",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Servers.Properties.Subscription",
	"tags":                    "Description.Server.Tags",
	"title":                   "Description.Server.properties.serverFullName",
}

func ListAnalysisServiceServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAnalysisServiceServer")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAnalysisServiceServer NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAnalysisServiceServer NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAnalysisServiceServer GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAnalysisServiceServer GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAnalysisServiceServer GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAnalysisServiceServerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAnalysisServiceServerFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAnalysisServiceServer NewAnalysisServiceServerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAnalysisServiceServer paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAnalysisServiceServerFilters = map[string]string{
	"id":                      "Description.Servers.ID",
	"name":                    "description.Server.name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "description.ResourceGroup",
	"subscription":            "Description.Servers.Properties.Subscription",
	"tags":                    "Description.Server.Tags",
	"title":                   "Description.Server.properties.serverFullName",
}

func GetAnalysisServiceServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAnalysisServiceServer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAnalysisServiceServerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAnalysisServiceServerFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AnalysisServiceServer =============================

// ==========================  START: PostgresqlServer =============================

type PostgresqlServer struct {
	ResourceID      string                            `json:"resource_id"`
	PlatformID      string                            `json:"platform_id"`
	Description     azure.PostgresqlServerDescription `json:"Description"`
	Metadata        azure.Metadata                    `json:"metadata"`
	DescribedBy     string                            `json:"described_by"`
	ResourceType    string                            `json:"resource_type"`
	IntegrationType string                            `json:"integration_type"`
	IntegrationID   string                            `json:"integration_id"`
}

type PostgresqlServerHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  PostgresqlServer `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type PostgresqlServerHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []PostgresqlServerHit `json:"hits"`
}

type PostgresqlServerSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  PostgresqlServerHits `json:"hits"`
}

type PostgresqlServerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPostgresqlServerPaginator(filters []essdk.BoolFilter, limit *int64) (PostgresqlServerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_dbforpostgresql_servers", filters, limit)
	if err != nil {
		return PostgresqlServerPaginator{}, err
	}

	p := PostgresqlServerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PostgresqlServerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PostgresqlServerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p PostgresqlServerPaginator) NextPage(ctx context.Context) ([]PostgresqlServer, error) {
	var response PostgresqlServerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PostgresqlServer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPostgresqlServerFilters = map[string]string{
	"administrator_login":          "Description.Server.properties.administratorLogin",
	"backup_retention_days":        "Description.Server.properties.storageProfile.backupRetentionDays",
	"byok_enforcement":             "Description.Server.properties.byokEnforcement",
	"firewall_rules":               "Description.FirewallRules",
	"fully_qualified_domain_name":  "Description.Server.properties.fullyQualifiedDomainName",
	"geo_redundant_backup":         "Description.Server.properties.storageProfile.geoRedundantBackup",
	"id":                           "Description.Server.id",
	"infrastructure_encryption":    "Description.Server.properties.infrastructureEncryption",
	"location":                     "Description.Server.location",
	"master_server_id":             "Description.Server.properties.masterServerId",
	"minimal_tls_version":          "Description.Server.properties.minimalTlsVersion",
	"name":                         "Description.Server.name",
	"platform_integration_id":      "IntegrationID",
	"public_network_access":        "Description.Server.properties.publicNetworkAccess",
	"replica_capacity":             "Description.Server.properties.replicaCapacity",
	"replication_role":             "Description.Server.properties.replicationRole",
	"resource_group":               "Description.ResourceGroup",
	"server_administrators":        "Description.ServerAdministratorResources",
	"server_configurations":        "Description.Configurations",
	"server_keys":                  "Description.ServerKeys",
	"server_security_alert_policy": "Description.ServerSecurityAlertPolicies",
	"sku_capacity":                 "Description.Server.sku.capacity",
	"sku_family":                   "Description.Server.sku.family",
	"sku_name":                     "Description.Server.sku.name",
	"sku_size":                     "Description.Server.sku.size",
	"sku_tier":                     "Description.Server.sku.tier",
	"ssl_enforcement":              "Description.Server.properties.sslEnforcement",
	"storage_auto_grow":            "Description.Server.properties.storageProfile.storageAutogrow",
	"storage_mb":                   "Description.Server.properties.storageProfile.storageMB",
	"subscription":                 "Description.Server.Properties.Subscription",
	"tags":                         "Description.Server.Tags",
	"title":                        "Description.Server.name",
	"type":                         "Description.Server.type",
	"user_visible_state":           "Description.Server.properties.userVisibleState",
	"version":                      "Description.Server.properties.version",
}

func ListPostgresqlServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPostgresqlServer")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListPostgresqlServer NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListPostgresqlServer NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListPostgresqlServer GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListPostgresqlServer GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListPostgresqlServer GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewPostgresqlServerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listPostgresqlServerFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListPostgresqlServer NewPostgresqlServerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListPostgresqlServer paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getPostgresqlServerFilters = map[string]string{
	"administrator_login":          "Description.Server.properties.administratorLogin",
	"backup_retention_days":        "Description.Server.properties.storageProfile.backupRetentionDays",
	"byok_enforcement":             "Description.Server.properties.byokEnforcement",
	"firewall_rules":               "Description.FirewallRules",
	"fully_qualified_domain_name":  "Description.Server.properties.fullyQualifiedDomainName",
	"geo_redundant_backup":         "Description.Server.properties.storageProfile.geoRedundantBackup",
	"id":                           "Description.Server.id",
	"infrastructure_encryption":    "Description.Server.properties.infrastructureEncryption",
	"location":                     "Description.Server.location",
	"master_server_id":             "Description.Server.properties.masterServerId",
	"minimal_tls_version":          "Description.Server.properties.minimalTlsVersion",
	"name":                         "description.Server.name",
	"platform_integration_id":      "IntegrationID",
	"public_network_access":        "Description.Server.properties.publicNetworkAccess",
	"replica_capacity":             "Description.Server.properties.replicaCapacity",
	"replication_role":             "Description.Server.properties.replicationRole",
	"resource_group":               "description.ResourceGroup",
	"server_administrators":        "Description.ServerAdministratorResources",
	"server_configurations":        "Description.Configurations",
	"server_keys":                  "Description.ServerKeys",
	"server_security_alert_policy": "Description.ServerSecurityAlertPolicies",
	"sku_capacity":                 "Description.Server.sku.capacity",
	"sku_family":                   "Description.Server.sku.family",
	"sku_name":                     "Description.Server.sku.name",
	"sku_size":                     "Description.Server.sku.size",
	"sku_tier":                     "Description.Server.sku.tier",
	"ssl_enforcement":              "Description.Server.properties.sslEnforcement",
	"storage_auto_grow":            "Description.Server.properties.storageProfile.storageAutogrow",
	"storage_mb":                   "Description.Server.properties.storageProfile.storageMB",
	"subscription":                 "Description.Server.Properties.Subscription",
	"tags":                         "Description.Server.Tags",
	"title":                        "Description.Server.name",
	"type":                         "Description.Server.type",
	"user_visible_state":           "Description.Server.properties.userVisibleState",
	"version":                      "Description.Server.properties.version",
}

func GetPostgresqlServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPostgresqlServer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewPostgresqlServerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getPostgresqlServerFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: PostgresqlServer =============================

// ==========================  START: PostgresqlFlexibleServer =============================

type PostgresqlFlexibleServer struct {
	ResourceID      string                                    `json:"resource_id"`
	PlatformID      string                                    `json:"platform_id"`
	Description     azure.PostgresqlFlexibleServerDescription `json:"Description"`
	Metadata        azure.Metadata                            `json:"metadata"`
	DescribedBy     string                                    `json:"described_by"`
	ResourceType    string                                    `json:"resource_type"`
	IntegrationType string                                    `json:"integration_type"`
	IntegrationID   string                                    `json:"integration_id"`
}

type PostgresqlFlexibleServerHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  PostgresqlFlexibleServer `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type PostgresqlFlexibleServerHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []PostgresqlFlexibleServerHit `json:"hits"`
}

type PostgresqlFlexibleServerSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  PostgresqlFlexibleServerHits `json:"hits"`
}

type PostgresqlFlexibleServerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPostgresqlFlexibleServerPaginator(filters []essdk.BoolFilter, limit *int64) (PostgresqlFlexibleServerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_dbforpostgresql_flexibleservers", filters, limit)
	if err != nil {
		return PostgresqlFlexibleServerPaginator{}, err
	}

	p := PostgresqlFlexibleServerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PostgresqlFlexibleServerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PostgresqlFlexibleServerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p PostgresqlFlexibleServerPaginator) NextPage(ctx context.Context) ([]PostgresqlFlexibleServer, error) {
	var response PostgresqlFlexibleServerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PostgresqlFlexibleServer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPostgresqlFlexibleServerFilters = map[string]string{
	"flexible_server_configurations": "Description.Server.ServerConfigurations",
	"id":                             "Description.Server.id",
	"location":                       "Description.Server.location",
	"name":                           "Description.Server.name",
	"platform_integration_id":        "IntegrationID",
	"server_properties":              "Description.Server.ServerProperties",
	"sku":                            "Description.Server.SKU",
	"subscription":                   "Description.Server.Properties.Subscription",
	"tags":                           "Description.Server.Tags",
	"title":                          "Description.Server.name",
	"type":                           "Description.Server.type",
}

func ListPostgresqlFlexibleServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPostgresqlFlexibleServer")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListPostgresqlFlexibleServer NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListPostgresqlFlexibleServer NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListPostgresqlFlexibleServer GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListPostgresqlFlexibleServer GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListPostgresqlFlexibleServer GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewPostgresqlFlexibleServerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listPostgresqlFlexibleServerFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListPostgresqlFlexibleServer NewPostgresqlFlexibleServerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListPostgresqlFlexibleServer paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getPostgresqlFlexibleServerFilters = map[string]string{
	"flexible_server_configurations": "Description.Server.ServerConfigurations",
	"id":                             "Description.Server.id",
	"location":                       "Description.Server.location",
	"name":                           "Description.Server.name",
	"platform_integration_id":        "IntegrationID",
	"server_properties":              "Description.Server.ServerProperties",
	"sku":                            "Description.Server.SKU",
	"subscription":                   "Description.Server.Properties.Subscription",
	"tags":                           "Description.Server.Tags",
	"title":                          "Description.Server.name",
	"type":                           "Description.Server.type",
}

func GetPostgresqlFlexibleServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPostgresqlFlexibleServer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewPostgresqlFlexibleServerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getPostgresqlFlexibleServerFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: PostgresqlFlexibleServer =============================

// ==========================  START: StorageSync =============================

type StorageSync struct {
	ResourceID      string                       `json:"resource_id"`
	PlatformID      string                       `json:"platform_id"`
	Description     azure.StorageSyncDescription `json:"Description"`
	Metadata        azure.Metadata               `json:"metadata"`
	DescribedBy     string                       `json:"described_by"`
	ResourceType    string                       `json:"resource_type"`
	IntegrationType string                       `json:"integration_type"`
	IntegrationID   string                       `json:"integration_id"`
}

type StorageSyncHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  StorageSync   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type StorageSyncHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []StorageSyncHit  `json:"hits"`
}

type StorageSyncSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  StorageSyncHits `json:"hits"`
}

type StorageSyncPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStorageSyncPaginator(filters []essdk.BoolFilter, limit *int64) (StorageSyncPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_storagesync_storagesyncservices", filters, limit)
	if err != nil {
		return StorageSyncPaginator{}, err
	}

	p := StorageSyncPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StorageSyncPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StorageSyncPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p StorageSyncPaginator) NextPage(ctx context.Context) ([]StorageSync, error) {
	var response StorageSyncSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StorageSync
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStorageSyncFilters = map[string]string{
	"id":                          "Description.Service.id",
	"incoming_traffic_policy":     "Description.Service.properties.incomingTrafficPolicy",
	"last_operation_name":         "Description.Service.properties.lastOperationName",
	"last_workflow_id":            "Description.Service.properties.lastWorkflowId",
	"name":                        "Description.Service.name",
	"platform_integration_id":     "IntegrationID",
	"provisioning_state":          "Description.Service.properties.provisioningState",
	"resource_group":              "Description.ResourceGroup",
	"storage_sync_service_status": "Description.Service.properties.storageSyncServiceStatus",
	"storage_sync_service_uid":    "Description.Service.properties.storageSyncServiceUid",
	"subscription":                "Description.Service.Properties.Subscription",
	"tags":                        "Description.Service.Tags",
	"title":                       "Description.Service.name",
	"type":                        "Description.Service.type",
}

func ListStorageSync(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStorageSync")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageSync NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageSync NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageSync GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageSync GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageSync GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewStorageSyncPaginator(essdk.BuildFilter(ctx, d.QueryContext, listStorageSyncFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageSync NewStorageSyncPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListStorageSync paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getStorageSyncFilters = map[string]string{
	"id":                          "Description.Service.id",
	"incoming_traffic_policy":     "Description.Service.properties.incomingTrafficPolicy",
	"last_operation_name":         "Description.Service.properties.lastOperationName",
	"last_workflow_id":            "Description.Service.properties.lastWorkflowId",
	"name":                        "description.Service.name",
	"platform_integration_id":     "IntegrationID",
	"provisioning_state":          "Description.Service.properties.provisioningState",
	"resource_group":              "description.ResourceGroup",
	"storage_sync_service_status": "Description.Service.properties.storageSyncServiceStatus",
	"storage_sync_service_uid":    "Description.Service.properties.storageSyncServiceUid",
	"subscription":                "Description.Service.Properties.Subscription",
	"tags":                        "Description.Service.Tags",
	"title":                       "Description.Service.name",
	"type":                        "Description.Service.type",
}

func GetStorageSync(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStorageSync")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewStorageSyncPaginator(essdk.BuildFilter(ctx, d.QueryContext, getStorageSyncFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: StorageSync =============================

// ==========================  START: MssqlManagedInstance =============================

type MssqlManagedInstance struct {
	ResourceID      string                                `json:"resource_id"`
	PlatformID      string                                `json:"platform_id"`
	Description     azure.MssqlManagedInstanceDescription `json:"Description"`
	Metadata        azure.Metadata                        `json:"metadata"`
	DescribedBy     string                                `json:"described_by"`
	ResourceType    string                                `json:"resource_type"`
	IntegrationType string                                `json:"integration_type"`
	IntegrationID   string                                `json:"integration_id"`
}

type MssqlManagedInstanceHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  MssqlManagedInstance `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type MssqlManagedInstanceHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []MssqlManagedInstanceHit `json:"hits"`
}

type MssqlManagedInstanceSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  MssqlManagedInstanceHits `json:"hits"`
}

type MssqlManagedInstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMssqlManagedInstancePaginator(filters []essdk.BoolFilter, limit *int64) (MssqlManagedInstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_sql_managedinstances", filters, limit)
	if err != nil {
		return MssqlManagedInstancePaginator{}, err
	}

	p := MssqlManagedInstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MssqlManagedInstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MssqlManagedInstancePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p MssqlManagedInstancePaginator) NextPage(ctx context.Context) ([]MssqlManagedInstance, error) {
	var response MssqlManagedInstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MssqlManagedInstance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMssqlManagedInstanceFilters = map[string]string{
	"administrator_login":          "Description.ManagedInstance.properties.administratorLogin",
	"administrator_login_password": "Description.ManagedInstance.properties.administratorLoginPassword",
	"collation":                    "Description.ManagedInstance.properties.collation",
	"dns_zone":                     "Description.ManagedInstance.properties.dnsZone",
	"dns_zone_partner":             "Description.ManagedInstance.properties.dnsZonePartner",
	"encryption_protectors":        "Description.ManagedInstanceEncryptionProtectors",
	"fully_qualified_domain_name":  "Description.ManagedInstance.properties.fullyQualifiedDomainName",
	"id":                           "Description.ManagedInstance.id",
	"identity":                     "Description.ManagedInstance.Identity",
	"instance_pool_id":             "Description.ManagedInstance.properties.instancePoolId",
	"license_type":                 "Description.ManagedInstance.properties.licenseType",
	"maintenance_configuration_id": "Description.ManagedInstance.properties.maintenanceConfigurationId",
	"managed_instance_create_mode": "Description.ManagedInstance.properties.managedInstanceCreateMode",
	"minimal_tls_version":          "Description.ManagedInstance.properties.minimalTlsVersion",
	"name":                         "Description.ManagedInstance.name",
	"platform_integration_id":      "IntegrationID",
	"proxy_override":               "Description.ManagedInstance.properties.proxyOverride",
	"public_data_endpoint_enabled": "Description.ManagedInstance.properties.publicDataEndpointEnabled",
	"resource_group":               "Description.ResourceGroup",
	"security_alert_policies":      "Description.ManagedDatabaseSecurityAlertPolicies",
	"sku":                          "Description.ManagedInstance.SKU",
	"source_managed_instance_id":   "Description.ManagedInstance.properties.sourceManagedInstanceId",
	"state":                        "Description.ManagedInstance.properties.state",
	"storage_size_in_gb":           "Description.ManagedInstance.properties.storageSizeInGB",
	"subnet_id":                    "Description.ManagedInstance.properties.subnetId",
	"subscription":                 "Description.ManagedInstance.Properties.Subscription",
	"tags":                         "Description.ManagedInstance.Tags",
	"timezone_id":                  "Description.ManagedInstance.properties.timezoneId",
	"title":                        "Description.ManagedInstance.name",
	"type":                         "Description.ManagedInstance.type",
	"v_cores":                      "Description.ManagedInstance.properties.vCores",
	"vulnerability_assessments":    "Description.ManagedInstanceVulnerabilityAssessments",
}

func ListMssqlManagedInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMssqlManagedInstance")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListMssqlManagedInstance NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListMssqlManagedInstance NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListMssqlManagedInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListMssqlManagedInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListMssqlManagedInstance GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewMssqlManagedInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, listMssqlManagedInstanceFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListMssqlManagedInstance NewMssqlManagedInstancePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListMssqlManagedInstance paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getMssqlManagedInstanceFilters = map[string]string{
	"administrator_login":          "Description.ManagedInstance.properties.administratorLogin",
	"administrator_login_password": "Description.ManagedInstance.properties.administratorLoginPassword",
	"collation":                    "Description.ManagedInstance.properties.collation",
	"dns_zone":                     "Description.ManagedInstance.properties.dnsZone",
	"dns_zone_partner":             "Description.ManagedInstance.properties.dnsZonePartner",
	"encryption_protectors":        "Description.ManagedInstanceEncryptionProtectors",
	"fully_qualified_domain_name":  "Description.ManagedInstance.properties.fullyQualifiedDomainName",
	"id":                           "Description.ManagedInstance.id",
	"identity":                     "Description.ManagedInstance.Identity",
	"instance_pool_id":             "Description.ManagedInstance.properties.instancePoolId",
	"license_type":                 "Description.ManagedInstance.properties.licenseType",
	"maintenance_configuration_id": "Description.ManagedInstance.properties.maintenanceConfigurationId",
	"managed_instance_create_mode": "Description.ManagedInstance.properties.managedInstanceCreateMode",
	"minimal_tls_version":          "Description.ManagedInstance.properties.minimalTlsVersion",
	"name":                         "description.ManagedInstance.name",
	"platform_integration_id":      "IntegrationID",
	"proxy_override":               "Description.ManagedInstance.properties.proxyOverride",
	"public_data_endpoint_enabled": "Description.ManagedInstance.properties.publicDataEndpointEnabled",
	"resource_group":               "description.ResourceGroup",
	"security_alert_policies":      "Description.ManagedDatabaseSecurityAlertPolicies",
	"sku":                          "Description.ManagedInstance.SKU",
	"source_managed_instance_id":   "Description.ManagedInstance.properties.sourceManagedInstanceId",
	"state":                        "Description.ManagedInstance.properties.state",
	"storage_size_in_gb":           "Description.ManagedInstance.properties.storageSizeInGB",
	"subnet_id":                    "Description.ManagedInstance.properties.subnetId",
	"subscription":                 "Description.ManagedInstance.Properties.Subscription",
	"tags":                         "Description.ManagedInstance.Tags",
	"timezone_id":                  "Description.ManagedInstance.properties.timezoneId",
	"title":                        "Description.ManagedInstance.name",
	"type":                         "Description.ManagedInstance.type",
	"v_cores":                      "Description.ManagedInstance.properties.vCores",
	"vulnerability_assessments":    "Description.ManagedInstanceVulnerabilityAssessments",
}

func GetMssqlManagedInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMssqlManagedInstance")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewMssqlManagedInstancePaginator(essdk.BuildFilter(ctx, d.QueryContext, getMssqlManagedInstanceFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: MssqlManagedInstance =============================

// ==========================  START: MssqlManagedInstanceDatabases =============================

type MssqlManagedInstanceDatabases struct {
	ResourceID      string                                         `json:"resource_id"`
	PlatformID      string                                         `json:"platform_id"`
	Description     azure.MssqlManagedInstanceDatabasesDescription `json:"Description"`
	Metadata        azure.Metadata                                 `json:"metadata"`
	DescribedBy     string                                         `json:"described_by"`
	ResourceType    string                                         `json:"resource_type"`
	IntegrationType string                                         `json:"integration_type"`
	IntegrationID   string                                         `json:"integration_id"`
}

type MssqlManagedInstanceDatabasesHit struct {
	ID      string                        `json:"_id"`
	Score   float64                       `json:"_score"`
	Index   string                        `json:"_index"`
	Type    string                        `json:"_type"`
	Version int64                         `json:"_version,omitempty"`
	Source  MssqlManagedInstanceDatabases `json:"_source"`
	Sort    []interface{}                 `json:"sort"`
}

type MssqlManagedInstanceDatabasesHits struct {
	Total essdk.SearchTotal                  `json:"total"`
	Hits  []MssqlManagedInstanceDatabasesHit `json:"hits"`
}

type MssqlManagedInstanceDatabasesSearchResponse struct {
	PitID string                            `json:"pit_id"`
	Hits  MssqlManagedInstanceDatabasesHits `json:"hits"`
}

type MssqlManagedInstanceDatabasesPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMssqlManagedInstanceDatabasesPaginator(filters []essdk.BoolFilter, limit *int64) (MssqlManagedInstanceDatabasesPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_sql_managedinstances_databases", filters, limit)
	if err != nil {
		return MssqlManagedInstanceDatabasesPaginator{}, err
	}

	p := MssqlManagedInstanceDatabasesPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MssqlManagedInstanceDatabasesPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MssqlManagedInstanceDatabasesPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p MssqlManagedInstanceDatabasesPaginator) NextPage(ctx context.Context) ([]MssqlManagedInstanceDatabases, error) {
	var response MssqlManagedInstanceDatabasesSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MssqlManagedInstanceDatabases
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMssqlManagedInstanceDatabasesFilters = map[string]string{
	"id":                      "Description.ManagedInstance.id",
	"name":                    "Description.ManagedInstance.sku.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.ManagedInstance.Properties.Subscription",
	"tags":                    "Description.ManagedInstance.Tags",
	"title":                   "Description.ManagedInstance.sku.name",
}

func ListMssqlManagedInstanceDatabases(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMssqlManagedInstanceDatabases")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListMssqlManagedInstanceDatabases NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListMssqlManagedInstanceDatabases NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListMssqlManagedInstanceDatabases GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListMssqlManagedInstanceDatabases GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListMssqlManagedInstanceDatabases GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewMssqlManagedInstanceDatabasesPaginator(essdk.BuildFilter(ctx, d.QueryContext, listMssqlManagedInstanceDatabasesFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListMssqlManagedInstanceDatabases NewMssqlManagedInstanceDatabasesPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListMssqlManagedInstanceDatabases paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getMssqlManagedInstanceDatabasesFilters = map[string]string{
	"id":                      "Description.ManagedInstance.id",
	"name":                    "Description.ManagedInstance.sku.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.ManagedInstance.Properties.Subscription",
	"tags":                    "Description.ManagedInstance.Tags",
	"title":                   "Description.ManagedInstance.sku.name",
}

func GetMssqlManagedInstanceDatabases(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMssqlManagedInstanceDatabases")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewMssqlManagedInstanceDatabasesPaginator(essdk.BuildFilter(ctx, d.QueryContext, getMssqlManagedInstanceDatabasesFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: MssqlManagedInstanceDatabases =============================

// ==========================  START: SqlDatabase =============================

type SqlDatabase struct {
	ResourceID      string                       `json:"resource_id"`
	PlatformID      string                       `json:"platform_id"`
	Description     azure.SqlDatabaseDescription `json:"Description"`
	Metadata        azure.Metadata               `json:"metadata"`
	DescribedBy     string                       `json:"described_by"`
	ResourceType    string                       `json:"resource_type"`
	IntegrationType string                       `json:"integration_type"`
	IntegrationID   string                       `json:"integration_id"`
}

type SqlDatabaseHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SqlDatabase   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SqlDatabaseHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SqlDatabaseHit  `json:"hits"`
}

type SqlDatabaseSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  SqlDatabaseHits `json:"hits"`
}

type SqlDatabasePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSqlDatabasePaginator(filters []essdk.BoolFilter, limit *int64) (SqlDatabasePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_sql_servers_databases", filters, limit)
	if err != nil {
		return SqlDatabasePaginator{}, err
	}

	p := SqlDatabasePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SqlDatabasePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SqlDatabasePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SqlDatabasePaginator) NextPage(ctx context.Context) ([]SqlDatabase, error) {
	var response SqlDatabaseSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SqlDatabase
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSqlDatabaseFilters = map[string]string{
	"audit_policy":                 "Description.AuditPolicies",
	"collation":                    "Description.Database.properties.collation",
	"create_mode":                  "Description.Database.properties.createMode",
	"current_service_objective_id": "Description.Database.properties.currentServiceObjectiveName",
	"database_id":                  "Description.Database.properties.databaseId",
	"default_secondary_location":   "Description.Database.properties.defaultSecondaryLocation",
	"edition":                      "Description.Database.properties.requestedServiceObjectiveName",
	"elastic_pool_name":            "Description.Database.properties.elasticPoolId",
	"failover_group_id":            "Description.Database.properties.failoverGroupId",
	"id":                           "Description.Database.id",
	"kind":                         "Description.Database.kind",
	"location":                     "Description.Database.location",
	"max_size_bytes":               "Description.Database.properties.maxSizeBytes",
	"name":                         "Description.Database.name",
	"platform_integration_id":      "IntegrationID",
	"read_scale":                   "Description.Database.properties.readScale",
	"recovery_services_recovery_point_resource_id": "Description.Database.properties.recoveryServicesRecoveryPointId",
	"requested_service_objective_id":               "Description.Database.properties.requestedServiceObjectiveName",
	"requested_service_objective_name":             "Description.Database.properties.requestedServiceObjectiveName",
	"resource_group":                               "Description.ResourceGroup",
	"retention_policy_id":                          "Description.LongTermRetentionPolicy.id",
	"retention_policy_name":                        "Description.LongTermRetentionPolicy.name",
	"retention_policy_property":                    "Description.LongTermRetentionPolicy.Properties",
	"retention_policy_type":                        "Description.LongTermRetentionPolicy.type",
	"sample_name":                                  "Description.Database.properties.sampleName",
	"service_level_objective":                      "Description.Database.properties.requestedServiceObjectiveName",
	"service_tier_advisors":                        "Description.Advisors",
	"source_database_id":                           "Description.Database.properties.sourceDatabaseId",
	"status":                                       "Description.Database.properties.status",
	"subscription":                                 "Description.Database.Properties.Subscription",
	"tags":                                         "Description.Database.Tags",
	"title":                                        "Description.Database.name",
	"transparent_data_encryption":                  "Description.TransparentDataEncryption",
	"type":                                         "Description.Database.type",
	"vulnerability_assessment_scan_records":        "Description.VulnerabilityAssessmentScanRecords",
	"vulnerability_assessments":                    "Description.DatabaseVulnerabilityAssessments",
	"zone_redundant":                               "Description.Database.properties.zoneRedundant",
}

func ListSqlDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSqlDatabase")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlDatabase NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlDatabase NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlDatabase GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSqlDatabasePaginator(essdk.BuildFilter(ctx, d.QueryContext, listSqlDatabaseFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlDatabase NewSqlDatabasePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSqlDatabase paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSqlDatabaseFilters = map[string]string{
	"audit_policy":                 "Description.AuditPolicies",
	"collation":                    "Description.Database.properties.collation",
	"create_mode":                  "Description.Database.properties.createMode",
	"current_service_objective_id": "Description.Database.properties.currentServiceObjectiveName",
	"database_id":                  "Description.Database.properties.databaseId",
	"default_secondary_location":   "Description.Database.properties.defaultSecondaryLocation",
	"edition":                      "Description.Database.properties.requestedServiceObjectiveName",
	"elastic_pool_name":            "Description.Database.properties.elasticPoolId",
	"failover_group_id":            "Description.Database.properties.failoverGroupId",
	"id":                           "Description.Database.id",
	"kind":                         "Description.Database.kind",
	"location":                     "Description.Database.location",
	"max_size_bytes":               "Description.Database.properties.maxSizeBytes",
	"name":                         "description.Database.name",
	"platform_integration_id":      "IntegrationID",
	"read_scale":                   "Description.Database.properties.readScale",
	"recovery_services_recovery_point_resource_id": "Description.Database.properties.recoveryServicesRecoveryPointId",
	"requested_service_objective_id":               "Description.Database.properties.requestedServiceObjectiveName",
	"requested_service_objective_name":             "Description.Database.properties.requestedServiceObjectiveName",
	"resource_group":                               "description.ResourceGroup",
	"retention_policy_id":                          "Description.LongTermRetentionPolicy.id",
	"retention_policy_name":                        "Description.LongTermRetentionPolicy.name",
	"retention_policy_property":                    "Description.LongTermRetentionPolicy.Properties",
	"retention_policy_type":                        "Description.LongTermRetentionPolicy.type",
	"sample_name":                                  "Description.Database.properties.sampleName",
	"service_level_objective":                      "Description.Database.properties.requestedServiceObjectiveName",
	"service_tier_advisors":                        "Description.Advisors",
	"source_database_id":                           "Description.Database.properties.sourceDatabaseId",
	"status":                                       "Description.Database.properties.status",
	"subscription":                                 "Description.Database.Properties.Subscription",
	"tags":                                         "Description.Database.Tags",
	"title":                                        "Description.Database.name",
	"transparent_data_encryption":                  "Description.TransparentDataEncryption",
	"type":                                         "Description.Database.type",
	"vulnerability_assessment_scan_records":        "Description.VulnerabilityAssessmentScanRecords",
	"vulnerability_assessments":                    "Description.DatabaseVulnerabilityAssessments",
	"zone_redundant":                               "Description.Database.properties.zoneRedundant",
}

func GetSqlDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSqlDatabase")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSqlDatabasePaginator(essdk.BuildFilter(ctx, d.QueryContext, getSqlDatabaseFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SqlDatabase =============================

// ==========================  START: SqlInstancePool =============================

type SqlInstancePool struct {
	ResourceID      string                           `json:"resource_id"`
	PlatformID      string                           `json:"platform_id"`
	Description     azure.SqlInstancePoolDescription `json:"Description"`
	Metadata        azure.Metadata                   `json:"metadata"`
	DescribedBy     string                           `json:"described_by"`
	ResourceType    string                           `json:"resource_type"`
	IntegrationType string                           `json:"integration_type"`
	IntegrationID   string                           `json:"integration_id"`
}

type SqlInstancePoolHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  SqlInstancePool `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type SqlInstancePoolHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []SqlInstancePoolHit `json:"hits"`
}

type SqlInstancePoolSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  SqlInstancePoolHits `json:"hits"`
}

type SqlInstancePoolPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSqlInstancePoolPaginator(filters []essdk.BoolFilter, limit *int64) (SqlInstancePoolPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_sql_instancepools", filters, limit)
	if err != nil {
		return SqlInstancePoolPaginator{}, err
	}

	p := SqlInstancePoolPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SqlInstancePoolPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SqlInstancePoolPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SqlInstancePoolPaginator) NextPage(ctx context.Context) ([]SqlInstancePool, error) {
	var response SqlInstancePoolSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SqlInstancePool
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSqlInstancePoolFilters = map[string]string{
	"id":           "Description.InstancePool.id",
	"name":         "Description.InstancePool.name",
	"subscription": "Description.InstancePool.Properties.Subscription",
	"tags":         "Description.InstancePool.Tags",
	"title":        "Description.InstancePool.name",
}

func ListSqlInstancePool(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSqlInstancePool")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlInstancePool NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlInstancePool NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlInstancePool GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlInstancePool GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlInstancePool GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSqlInstancePoolPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSqlInstancePoolFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlInstancePool NewSqlInstancePoolPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSqlInstancePool paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSqlInstancePoolFilters = map[string]string{
	"id":           "Description.InstancePool.id",
	"name":         "Description.InstancePool.name",
	"subscription": "Description.InstancePool.Properties.Subscription",
	"tags":         "Description.InstancePool.Tags",
	"title":        "Description.InstancePool.name",
}

func GetSqlInstancePool(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSqlInstancePool")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSqlInstancePoolPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSqlInstancePoolFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SqlInstancePool =============================

// ==========================  START: SqlServer =============================

type SqlServer struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     azure.SqlServerDescription `json:"Description"`
	Metadata        azure.Metadata             `json:"metadata"`
	DescribedBy     string                     `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

type SqlServerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SqlServer     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SqlServerHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SqlServerHit    `json:"hits"`
}

type SqlServerSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  SqlServerHits `json:"hits"`
}

type SqlServerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSqlServerPaginator(filters []essdk.BoolFilter, limit *int64) (SqlServerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_sql_servers", filters, limit)
	if err != nil {
		return SqlServerPaginator{}, err
	}

	p := SqlServerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SqlServerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SqlServerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SqlServerPaginator) NextPage(ctx context.Context) ([]SqlServer, error) {
	var response SqlServerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SqlServer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSqlServerFilters = map[string]string{
	"administrator_login":             "Description.Server.properties.administratorLogin",
	"administrator_login_password":    "Description.Server.properties.administratorLoginPassword",
	"automatic_tuning":                "Description.AutomaticTuning",
	"encryption_protector":            "Description.EncryptionProtectors",
	"failover_groups":                 "Description.FailoverGroups",
	"firewall_rules":                  "Description.FirewallRules",
	"fully_qualified_domain_name":     "Description.Server.properties.fullyQualifiedDomainName",
	"id":                              "Description.Server.id",
	"kind":                            "Description.Server.kind",
	"location":                        "Description.Server.location",
	"minimal_tls_version":             "Description.Server.properties.minimalTlsVersion",
	"name":                            "Description.Server.name",
	"platform_integration_id":         "IntegrationID",
	"private_endpoint_connections":    "Description.PrivateEndpointConnections",
	"public_network_access":           "Description.Server.properties.publicNetworkAccess",
	"resource_group":                  "Description.ResourceGroup",
	"server_audit_policy":             "Description.ServerBlobAuditingPolicies",
	"server_azure_ad_administrator":   "Description.ServerAzureADAdministrators",
	"server_security_alert_policy":    "Description.ServerSecurityAlertPolicies",
	"server_vulnerability_assessment": "Description.ServerVulnerabilityAssessments",
	"state":                           "Description.Server.properties.state",
	"subscription":                    "Description.Server.Properties.Subscription",
	"tags":                            "Description.Server.Tags",
	"tags_src":                        "Description.Server.Tags",
	"title":                           "Description.Server.name",
	"type":                            "Description.Server.type",
	"version":                         "Description.Server.properties.version",
	"virtual_network_rules":           "Description.VirtualNetworkRules",
}

func ListSqlServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSqlServer")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServer NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServer NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServer GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServer GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServer GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSqlServerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSqlServerFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServer NewSqlServerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSqlServer paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSqlServerFilters = map[string]string{
	"administrator_login":             "Description.Server.properties.administratorLogin",
	"administrator_login_password":    "Description.Server.properties.administratorLoginPassword",
	"automatic_tuning":                "Description.AutomaticTuning",
	"encryption_protector":            "Description.EncryptionProtectors",
	"failover_groups":                 "Description.FailoverGroups",
	"firewall_rules":                  "Description.FirewallRules",
	"fully_qualified_domain_name":     "Description.Server.properties.fullyQualifiedDomainName",
	"id":                              "Description.Server.id",
	"kind":                            "Description.Server.kind",
	"location":                        "Description.Server.location",
	"minimal_tls_version":             "Description.Server.properties.minimalTlsVersion",
	"name":                            "description.Server.name",
	"platform_integration_id":         "IntegrationID",
	"private_endpoint_connections":    "Description.PrivateEndpointConnections",
	"public_network_access":           "Description.Server.properties.publicNetworkAccess",
	"resource_group":                  "description.ResourceGroup",
	"server_audit_policy":             "Description.ServerBlobAuditingPolicies",
	"server_azure_ad_administrator":   "Description.ServerAzureADAdministrators",
	"server_security_alert_policy":    "Description.ServerSecurityAlertPolicies",
	"server_vulnerability_assessment": "Description.ServerVulnerabilityAssessments",
	"state":                           "Description.Server.properties.state",
	"subscription":                    "Description.Server.Properties.Subscription",
	"tags":                            "Description.Server.Tags",
	"tags_src":                        "Description.Server.Tags",
	"title":                           "Description.Server.name",
	"type":                            "Description.Server.type",
	"version":                         "Description.Server.properties.version",
	"virtual_network_rules":           "Description.VirtualNetworkRules",
}

func GetSqlServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSqlServer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSqlServerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSqlServerFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SqlServer =============================

// ==========================  START: SqlServerJobAgent =============================

type SqlServerJobAgent struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     azure.SqlServerJobAgentDescription `json:"Description"`
	Metadata        azure.Metadata                     `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type SqlServerJobAgentHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  SqlServerJobAgent `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type SqlServerJobAgentHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []SqlServerJobAgentHit `json:"hits"`
}

type SqlServerJobAgentSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  SqlServerJobAgentHits `json:"hits"`
}

type SqlServerJobAgentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSqlServerJobAgentPaginator(filters []essdk.BoolFilter, limit *int64) (SqlServerJobAgentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_sql_servers_jobagents", filters, limit)
	if err != nil {
		return SqlServerJobAgentPaginator{}, err
	}

	p := SqlServerJobAgentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SqlServerJobAgentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SqlServerJobAgentPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SqlServerJobAgentPaginator) NextPage(ctx context.Context) ([]SqlServerJobAgent, error) {
	var response SqlServerJobAgentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SqlServerJobAgent
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSqlServerJobAgentFilters = map[string]string{
	"id":                      "Description.JobAgent.id",
	"name":                    "Description.JobAgent.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.JobAgent.Properties.Subscription",
	"tags":                    "Description.JobAgent.Tags",
	"title":                   "Description.JobAgent.name",
}

func ListSqlServerJobAgent(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSqlServerJobAgent")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerJobAgent NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerJobAgent NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerJobAgent GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerJobAgent GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerJobAgent GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSqlServerJobAgentPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSqlServerJobAgentFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerJobAgent NewSqlServerJobAgentPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSqlServerJobAgent paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSqlServerJobAgentFilters = map[string]string{
	"id":                      "Description.JobAgent.id",
	"name":                    "Description.JobAgent.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.JobAgent.Properties.Subscription",
	"tags":                    "Description.JobAgent.Tags",
	"title":                   "Description.JobAgent.name",
}

func GetSqlServerJobAgent(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSqlServerJobAgent")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSqlServerJobAgentPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSqlServerJobAgentFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SqlServerJobAgent =============================

// ==========================  START: SqlVirtualClusters =============================

type SqlVirtualClusters struct {
	ResourceID      string                              `json:"resource_id"`
	PlatformID      string                              `json:"platform_id"`
	Description     azure.SqlVirtualClustersDescription `json:"Description"`
	Metadata        azure.Metadata                      `json:"metadata"`
	DescribedBy     string                              `json:"described_by"`
	ResourceType    string                              `json:"resource_type"`
	IntegrationType string                              `json:"integration_type"`
	IntegrationID   string                              `json:"integration_id"`
}

type SqlVirtualClustersHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  SqlVirtualClusters `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type SqlVirtualClustersHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []SqlVirtualClustersHit `json:"hits"`
}

type SqlVirtualClustersSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  SqlVirtualClustersHits `json:"hits"`
}

type SqlVirtualClustersPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSqlVirtualClustersPaginator(filters []essdk.BoolFilter, limit *int64) (SqlVirtualClustersPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_sql_virtualclusters", filters, limit)
	if err != nil {
		return SqlVirtualClustersPaginator{}, err
	}

	p := SqlVirtualClustersPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SqlVirtualClustersPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SqlVirtualClustersPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SqlVirtualClustersPaginator) NextPage(ctx context.Context) ([]SqlVirtualClusters, error) {
	var response SqlVirtualClustersSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SqlVirtualClusters
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSqlVirtualClustersFilters = map[string]string{
	"id":                      "Description.VirtualClusters.id",
	"name":                    "Description.VirtualClusters.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.VirtualClusters.Properties.Subscription",
	"tags":                    "Description.VirtualClusters.Tags",
	"title":                   "Description.VirtualClusters.name",
}

func ListSqlVirtualClusters(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSqlVirtualClusters")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlVirtualClusters NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlVirtualClusters NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlVirtualClusters GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlVirtualClusters GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlVirtualClusters GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSqlVirtualClustersPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSqlVirtualClustersFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlVirtualClusters NewSqlVirtualClustersPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSqlVirtualClusters paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSqlVirtualClustersFilters = map[string]string{
	"id":                      "Description.VirtualClusters.id",
	"name":                    "Description.VirtualClusters.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.VirtualClusters.Properties.Subscription",
	"tags":                    "Description.VirtualClusters.Tags",
	"title":                   "Description.VirtualClusters.name",
}

func GetSqlVirtualClusters(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSqlVirtualClusters")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSqlVirtualClustersPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSqlVirtualClustersFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SqlVirtualClusters =============================

// ==========================  START: SqlServerElasticPool =============================

type SqlServerElasticPool struct {
	ResourceID      string                                `json:"resource_id"`
	PlatformID      string                                `json:"platform_id"`
	Description     azure.SqlServerElasticPoolDescription `json:"Description"`
	Metadata        azure.Metadata                        `json:"metadata"`
	DescribedBy     string                                `json:"described_by"`
	ResourceType    string                                `json:"resource_type"`
	IntegrationType string                                `json:"integration_type"`
	IntegrationID   string                                `json:"integration_id"`
}

type SqlServerElasticPoolHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  SqlServerElasticPool `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type SqlServerElasticPoolHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []SqlServerElasticPoolHit `json:"hits"`
}

type SqlServerElasticPoolSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  SqlServerElasticPoolHits `json:"hits"`
}

type SqlServerElasticPoolPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSqlServerElasticPoolPaginator(filters []essdk.BoolFilter, limit *int64) (SqlServerElasticPoolPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_sql_servers_elasticpools", filters, limit)
	if err != nil {
		return SqlServerElasticPoolPaginator{}, err
	}

	p := SqlServerElasticPoolPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SqlServerElasticPoolPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SqlServerElasticPoolPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SqlServerElasticPoolPaginator) NextPage(ctx context.Context) ([]SqlServerElasticPool, error) {
	var response SqlServerElasticPoolSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SqlServerElasticPool
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSqlServerElasticPoolFilters = map[string]string{
	"creation_date":           "Description.Pool.Properties.CreationDate",
	"database_dtu_max":        "Description.Pool.properties.perDatabaseSettings.maxCapacity",
	"database_dtu_min":        "Description.Pool.properties.perDatabaseSettings.minCapacity",
	"dtu":                     "Description.TotalDTU",
	"edition":                 "Description.Pool.sku.tier",
	"id":                      "Description.Pool.id",
	"kind":                    "Description.Pool.kind",
	"name":                    "Description.Pool.name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "Description.ResourceGroup",
	"server_name":             "Description.ServerName",
	"state":                   "Description.Pool.properties.state",
	"storage_mb":              "Description.Pool.properties.maxSizeBytes",
	"subscription":            "Description.Pool.Properties.Subscription",
	"tags":                    "Description.Pool.Tags",
	"title":                   "Description.Pool.name",
	"type":                    "Description.Pool.type",
	"zone_redundant":          "Description.Pool.properties.zoneRedundant",
}

func ListSqlServerElasticPool(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSqlServerElasticPool")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerElasticPool NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerElasticPool NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerElasticPool GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerElasticPool GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerElasticPool GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSqlServerElasticPoolPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSqlServerElasticPoolFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerElasticPool NewSqlServerElasticPoolPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSqlServerElasticPool paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSqlServerElasticPoolFilters = map[string]string{
	"creation_date":           "Description.Pool.Properties.CreationDate",
	"database_dtu_max":        "Description.Pool.properties.perDatabaseSettings.maxCapacity",
	"database_dtu_min":        "Description.Pool.properties.perDatabaseSettings.minCapacity",
	"dtu":                     "Description.TotalDTU",
	"edition":                 "Description.Pool.sku.tier",
	"id":                      "Description.Pool.id",
	"kind":                    "Description.Pool.kind",
	"name":                    "description.Pool.Name",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "description.ResourceGroup",
	"server_name":             "description.ServerName",
	"state":                   "Description.Pool.properties.state",
	"storage_mb":              "Description.Pool.properties.maxSizeBytes",
	"subscription":            "Description.Pool.Properties.Subscription",
	"tags":                    "Description.Pool.Tags",
	"title":                   "Description.Pool.name",
	"type":                    "Description.Pool.type",
	"zone_redundant":          "Description.Pool.properties.zoneRedundant",
}

func GetSqlServerElasticPool(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSqlServerElasticPool")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSqlServerElasticPoolPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSqlServerElasticPoolFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SqlServerElasticPool =============================

// ==========================  START: SqlServerVirtualMachine =============================

type SqlServerVirtualMachine struct {
	ResourceID      string                                   `json:"resource_id"`
	PlatformID      string                                   `json:"platform_id"`
	Description     azure.SqlServerVirtualMachineDescription `json:"Description"`
	Metadata        azure.Metadata                           `json:"metadata"`
	DescribedBy     string                                   `json:"described_by"`
	ResourceType    string                                   `json:"resource_type"`
	IntegrationType string                                   `json:"integration_type"`
	IntegrationID   string                                   `json:"integration_id"`
}

type SqlServerVirtualMachineHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  SqlServerVirtualMachine `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type SqlServerVirtualMachineHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []SqlServerVirtualMachineHit `json:"hits"`
}

type SqlServerVirtualMachineSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  SqlServerVirtualMachineHits `json:"hits"`
}

type SqlServerVirtualMachinePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSqlServerVirtualMachinePaginator(filters []essdk.BoolFilter, limit *int64) (SqlServerVirtualMachinePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_sqlvirtualmachine_sqlvirtualmachines", filters, limit)
	if err != nil {
		return SqlServerVirtualMachinePaginator{}, err
	}

	p := SqlServerVirtualMachinePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SqlServerVirtualMachinePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SqlServerVirtualMachinePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SqlServerVirtualMachinePaginator) NextPage(ctx context.Context) ([]SqlServerVirtualMachine, error) {
	var response SqlServerVirtualMachineSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SqlServerVirtualMachine
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSqlServerVirtualMachineFilters = map[string]string{
	"auto_backup_settings":          "Description.VirtualMachine.Properties.AutoBackupSettings",
	"auto_patching_settings":        "Description.VirtualMachine.Properties.AutoPatchingSettings",
	"id":                            "Description.VirtualMachine.id",
	"identity":                      "Description.VirtualMachine.Identity",
	"key_vault_credential_settings": "Description.VirtualMachine.Properties.KeyVaultCredentialSettings",
	"name":                          "Description.VirtualMachine.name",
	"platform_integration_id":       "IntegrationID",
	"provisioning_state":            "Description.VirtualMachine.properties.provisioningState",
	"resource_group":                "Description.ResourceGroup",
	"server_configurations_management_settings": "Description.VirtualMachine.Properties.ServerConfigurationsManagementSettings",
	"sql_image_offer":                       "Description.VirtualMachine.properties.sqlImageOffer",
	"sql_image_sku":                         "Description.VirtualMachine.properties.sqlImageSku",
	"sql_management":                        "Description.VirtualMachine.properties.sqlManagement",
	"sql_server_license_type":               "Description.VirtualMachine.properties.sqlServerLicenseType",
	"sql_virtual_machine_group_resource_id": "Description.VirtualMachine.properties.sqlVirtualMachineGroupResourceId",
	"storage_configuration_settings":        "Description.VirtualMachine.Properties.StorageConfigurationSettings",
	"subscription":                          "Description.VirtualMachine.Properties.Subscription",
	"tags":                                  "Description.VirtualMachine.Tags",
	"title":                                 "Description.VirtualMachine.name",
	"type":                                  "Description.VirtualMachine.type",
	"virtual_machine_resource_id":           "Description.VirtualMachine.properties.virtualMachineResourceId",
	"wsfc_domain_credentials":               "Description.VirtualMachine.Properties.WsfcDomainCredentials",
}

func ListSqlServerVirtualMachine(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSqlServerVirtualMachine")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerVirtualMachine NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerVirtualMachine NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerVirtualMachine GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerVirtualMachine GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerVirtualMachine GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSqlServerVirtualMachinePaginator(essdk.BuildFilter(ctx, d.QueryContext, listSqlServerVirtualMachineFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerVirtualMachine NewSqlServerVirtualMachinePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSqlServerVirtualMachine paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSqlServerVirtualMachineFilters = map[string]string{
	"auto_backup_settings":          "Description.VirtualMachine.Properties.AutoBackupSettings",
	"auto_patching_settings":        "Description.VirtualMachine.Properties.AutoPatchingSettings",
	"id":                            "Description.VirtualMachine.id",
	"identity":                      "Description.VirtualMachine.Identity",
	"key_vault_credential_settings": "Description.VirtualMachine.Properties.KeyVaultCredentialSettings",
	"name":                          "description.VirtualMachine.Name",
	"platform_integration_id":       "IntegrationID",
	"provisioning_state":            "Description.VirtualMachine.properties.provisioningState",
	"resource_group":                "description.ResourceGroup",
	"server_configurations_management_settings": "Description.VirtualMachine.Properties.ServerConfigurationsManagementSettings",
	"sql_image_offer":                       "Description.VirtualMachine.properties.sqlImageOffer",
	"sql_image_sku":                         "Description.VirtualMachine.properties.sqlImageSku",
	"sql_management":                        "Description.VirtualMachine.properties.sqlManagement",
	"sql_server_license_type":               "Description.VirtualMachine.properties.sqlServerLicenseType",
	"sql_virtual_machine_group_resource_id": "Description.VirtualMachine.properties.sqlVirtualMachineGroupResourceId",
	"storage_configuration_settings":        "Description.VirtualMachine.Properties.StorageConfigurationSettings",
	"subscription":                          "Description.VirtualMachine.Properties.Subscription",
	"tags":                                  "Description.VirtualMachine.Tags",
	"title":                                 "Description.VirtualMachine.name",
	"type":                                  "Description.VirtualMachine.type",
	"virtual_machine_resource_id":           "Description.VirtualMachine.properties.virtualMachineResourceId",
	"wsfc_domain_credentials":               "Description.VirtualMachine.Properties.WsfcDomainCredentials",
}

func GetSqlServerVirtualMachine(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSqlServerVirtualMachine")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSqlServerVirtualMachinePaginator(essdk.BuildFilter(ctx, d.QueryContext, getSqlServerVirtualMachineFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SqlServerVirtualMachine =============================

// ==========================  START: SqlServerVirtualMachineGroup =============================

type SqlServerVirtualMachineGroup struct {
	ResourceID      string                                        `json:"resource_id"`
	PlatformID      string                                        `json:"platform_id"`
	Description     azure.SqlServerVirtualMachineGroupDescription `json:"Description"`
	Metadata        azure.Metadata                                `json:"metadata"`
	DescribedBy     string                                        `json:"described_by"`
	ResourceType    string                                        `json:"resource_type"`
	IntegrationType string                                        `json:"integration_type"`
	IntegrationID   string                                        `json:"integration_id"`
}

type SqlServerVirtualMachineGroupHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  SqlServerVirtualMachineGroup `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type SqlServerVirtualMachineGroupHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []SqlServerVirtualMachineGroupHit `json:"hits"`
}

type SqlServerVirtualMachineGroupSearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  SqlServerVirtualMachineGroupHits `json:"hits"`
}

type SqlServerVirtualMachineGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSqlServerVirtualMachineGroupPaginator(filters []essdk.BoolFilter, limit *int64) (SqlServerVirtualMachineGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_sqlvirtualmachine_sqlvirtualmachinegroups", filters, limit)
	if err != nil {
		return SqlServerVirtualMachineGroupPaginator{}, err
	}

	p := SqlServerVirtualMachineGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SqlServerVirtualMachineGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SqlServerVirtualMachineGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SqlServerVirtualMachineGroupPaginator) NextPage(ctx context.Context) ([]SqlServerVirtualMachineGroup, error) {
	var response SqlServerVirtualMachineGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SqlServerVirtualMachineGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSqlServerVirtualMachineGroupFilters = map[string]string{
	"id":                      "Description.Group.id",
	"name":                    "Description.Group.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Group.Properties.Subscription",
	"tags":                    "Description.Group.Tags",
	"title":                   "Description.Group.name",
}

func ListSqlServerVirtualMachineGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSqlServerVirtualMachineGroup")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerVirtualMachineGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerVirtualMachineGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerVirtualMachineGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerVirtualMachineGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerVirtualMachineGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSqlServerVirtualMachineGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSqlServerVirtualMachineGroupFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerVirtualMachineGroup NewSqlServerVirtualMachineGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSqlServerVirtualMachineGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSqlServerVirtualMachineGroupFilters = map[string]string{
	"id":                      "Description.Group.id",
	"name":                    "Description.Group.name",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Group.Properties.Subscription",
	"tags":                    "Description.Group.Tags",
	"title":                   "Description.Group.name",
}

func GetSqlServerVirtualMachineGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSqlServerVirtualMachineGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSqlServerVirtualMachineGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSqlServerVirtualMachineGroupFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SqlServerVirtualMachineGroup =============================

// ==========================  START: SqlServerFlexibleServer =============================

type SqlServerFlexibleServer struct {
	ResourceID      string                                   `json:"resource_id"`
	PlatformID      string                                   `json:"platform_id"`
	Description     azure.SqlServerFlexibleServerDescription `json:"Description"`
	Metadata        azure.Metadata                           `json:"metadata"`
	DescribedBy     string                                   `json:"described_by"`
	ResourceType    string                                   `json:"resource_type"`
	IntegrationType string                                   `json:"integration_type"`
	IntegrationID   string                                   `json:"integration_id"`
}

type SqlServerFlexibleServerHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  SqlServerFlexibleServer `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type SqlServerFlexibleServerHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []SqlServerFlexibleServerHit `json:"hits"`
}

type SqlServerFlexibleServerSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  SqlServerFlexibleServerHits `json:"hits"`
}

type SqlServerFlexibleServerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSqlServerFlexibleServerPaginator(filters []essdk.BoolFilter, limit *int64) (SqlServerFlexibleServerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_sql_flexibleservers", filters, limit)
	if err != nil {
		return SqlServerFlexibleServerPaginator{}, err
	}

	p := SqlServerFlexibleServerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SqlServerFlexibleServerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SqlServerFlexibleServerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SqlServerFlexibleServerPaginator) NextPage(ctx context.Context) ([]SqlServerFlexibleServer, error) {
	var response SqlServerFlexibleServerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SqlServerFlexibleServer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSqlServerFlexibleServerFilters = map[string]string{
	"administrator_login":            "Description.FlexibleServer.properties.administratorLogin",
	"availability_zone":              "Description.FlexibleServer.properties.availabilityZone",
	"backup_retention_days":          "Description.FlexibleServer.properties.backup.backupRetentionDays",
	"create_mode":                    "Description.FlexibleServer.properties.createMode",
	"flexible_server_configurations": "Description.FlexibleServer.location",
	"fully_qualified_domain_name":    "Description.FlexibleServer.properties.fullyQualifiedDomainName",
	"geo_redundant_backup":           "Description.FlexibleServer.properties.backup.geoRedundantBackup",
	"high_availability":              "Description.FlexibleServer.Properties.HighAvailability",
	"id":                             "Description.FlexibleServer.id",
	"location":                       "Description.FlexibleServer.location",
	"maintenance_window":             "Description.FlexibleServer.Properties.MaintenanceWindow",
	"name":                           "Description.FlexibleServer.name",
	"network":                        "Description.FlexibleServer.Properties.Network",
	"platform_integration_id":        "IntegrationID",
	"public_network_access":          "Description.FlexibleServer.properties.network.publicNetworkAccess",
	"replica_capacity":               "Description.FlexibleServer.properties.replicaCapacity",
	"replication_role":               "Description.FlexibleServer.properties.replicationRole",
	"resource_group":                 "Description.ResourceGroup",
	"restore_point_in_time":          "Description.FlexibleServer.Properties.RestorePointInTime",
	"sku_name":                       "Description.FlexibleServer.sku.name",
	"sku_tier":                       "Description.FlexibleServer.sku.tier",
	"source_server_resource_id":      "Description.FlexibleServer.properties.sourceServerResourceId",
	"state":                          "Description.FlexibleServer.properties.state",
	"storage_auto_grow":              "Description.FlexibleServer.properties.storage.autoGrow",
	"storage_iops":                   "Description.FlexibleServer.properties.storage.iops",
	"storage_size_gb":                "Description.FlexibleServer.properties.storage.storageSizeGB",
	"storage_sku":                    "Description.FlexibleServer.properties.storage.storageSku",
	"subscription":                   "Description.FlexibleServer.Properties.Subscription",
	"system_data":                    "Description.FlexibleServer.SystemData",
	"tags":                           "Description.FlexibleServer.Tags",
	"title":                          "Description.FlexibleServer.name",
	"type":                           "Description.FlexibleServer.type",
	"version":                        "Description.FlexibleServer.properties.version",
}

func ListSqlServerFlexibleServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSqlServerFlexibleServer")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerFlexibleServer NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerFlexibleServer NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerFlexibleServer GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerFlexibleServer GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerFlexibleServer GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSqlServerFlexibleServerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSqlServerFlexibleServerFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSqlServerFlexibleServer NewSqlServerFlexibleServerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSqlServerFlexibleServer paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSqlServerFlexibleServerFilters = map[string]string{
	"administrator_login":            "Description.FlexibleServer.properties.administratorLogin",
	"availability_zone":              "Description.FlexibleServer.properties.availabilityZone",
	"backup_retention_days":          "Description.FlexibleServer.properties.backup.backupRetentionDays",
	"create_mode":                    "Description.FlexibleServer.properties.createMode",
	"flexible_server_configurations": "Description.FlexibleServer.location",
	"fully_qualified_domain_name":    "Description.FlexibleServer.properties.fullyQualifiedDomainName",
	"geo_redundant_backup":           "Description.FlexibleServer.properties.backup.geoRedundantBackup",
	"high_availability":              "Description.FlexibleServer.Properties.HighAvailability",
	"id":                             "Description.FlexibleServer.id",
	"location":                       "Description.FlexibleServer.location",
	"maintenance_window":             "Description.FlexibleServer.Properties.MaintenanceWindow",
	"name":                           "description.FlexibleServer.Name",
	"network":                        "Description.FlexibleServer.Properties.Network",
	"platform_integration_id":        "IntegrationID",
	"public_network_access":          "Description.FlexibleServer.properties.network.publicNetworkAccess",
	"replica_capacity":               "Description.FlexibleServer.properties.replicaCapacity",
	"replication_role":               "Description.FlexibleServer.properties.replicationRole",
	"resource_group":                 "description.ResourceGroup",
	"restore_point_in_time":          "Description.FlexibleServer.Properties.RestorePointInTime",
	"sku_name":                       "Description.FlexibleServer.sku.name",
	"sku_tier":                       "Description.FlexibleServer.sku.tier",
	"source_server_resource_id":      "Description.FlexibleServer.properties.sourceServerResourceId",
	"state":                          "Description.FlexibleServer.properties.state",
	"storage_auto_grow":              "Description.FlexibleServer.properties.storage.autoGrow",
	"storage_iops":                   "Description.FlexibleServer.properties.storage.iops",
	"storage_size_gb":                "Description.FlexibleServer.properties.storage.storageSizeGB",
	"storage_sku":                    "Description.FlexibleServer.properties.storage.storageSku",
	"subscription":                   "Description.FlexibleServer.Properties.Subscription",
	"system_data":                    "Description.FlexibleServer.SystemData",
	"tags":                           "Description.FlexibleServer.Tags",
	"title":                          "Description.FlexibleServer.name",
	"type":                           "Description.FlexibleServer.type",
	"version":                        "Description.FlexibleServer.properties.version",
}

func GetSqlServerFlexibleServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSqlServerFlexibleServer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSqlServerFlexibleServerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSqlServerFlexibleServerFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: SqlServerFlexibleServer =============================

// ==========================  START: StorageAccount =============================

type StorageAccount struct {
	ResourceID      string                          `json:"resource_id"`
	PlatformID      string                          `json:"platform_id"`
	Description     azure.StorageAccountDescription `json:"Description"`
	Metadata        azure.Metadata                  `json:"metadata"`
	DescribedBy     string                          `json:"described_by"`
	ResourceType    string                          `json:"resource_type"`
	IntegrationType string                          `json:"integration_type"`
	IntegrationID   string                          `json:"integration_id"`
}

type StorageAccountHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  StorageAccount `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type StorageAccountHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []StorageAccountHit `json:"hits"`
}

type StorageAccountSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  StorageAccountHits `json:"hits"`
}

type StorageAccountPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStorageAccountPaginator(filters []essdk.BoolFilter, limit *int64) (StorageAccountPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_storage_storageaccounts", filters, limit)
	if err != nil {
		return StorageAccountPaginator{}, err
	}

	p := StorageAccountPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StorageAccountPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StorageAccountPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p StorageAccountPaginator) NextPage(ctx context.Context) ([]StorageAccount, error) {
	var response StorageAccountSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StorageAccount
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStorageAccountFilters = map[string]string{
	"access_keys":                                            "Description.AccessKeys",
	"access_tier":                                            "Description.Account.properties.accessTier",
	"allow_blob_public_access":                               "Description.Account.properties.allowBlobPublicAccess",
	"blob_change_feed_enabled":                               "Description.BlobServiceProperties.properties.changeFeed.enabled",
	"blob_container_soft_delete_enabled":                     "Description.BlobServiceProperties.properties.containerDeleteRetentionPolicy.enabled",
	"blob_container_soft_delete_retention_days":              "Description.BlobServiceProperties.properties.containerDeleteRetentionPolicy.days",
	"blob_restore_policy_days":                               "Description.BlobServiceProperties.properties.restorePolicy.days",
	"blob_restore_policy_enabled":                            "Description.BlobServiceProperties.properties.restorePolicy.enabled",
	"blob_service_logging":                                   "Description.Logging",
	"blob_soft_delete_enabled":                               "Description.BlobServiceProperties.properties.containerDeleteRetentionPolicy.enabled",
	"blob_soft_delete_retention_days":                        "Description.BlobServiceProperties.properties.containerDeleteRetentionPolicy.days",
	"blob_versioning_enabled":                                "Description.BlobServiceProperties.properties.isVersioningEnabled",
	"enable_https_traffic_only":                              "Description.Account.properties.supportsHttpsTrafficOnly",
	"encryption_key_source":                                  "Description.Account.properties.encryption.keySource",
	"encryption_key_vault_properties_key_current_version_id": "Description.Account.properties.encryption.keyvaultproperties.currentVersionedKeyIdentifier",
	"encryption_key_vault_properties_key_name":               "Description.Account.properties.encryption.keyvaultproperties.keyname",
	"encryption_key_vault_properties_key_vault_uri":          "Description.Account.properties.encryption.keyvaultproperties.keyvaulturi",
	"encryption_key_vault_properties_key_version":            "Description.Account.properties.encryption.keyvaultproperties.keyversion",
	"encryption_services":                                    "Description.Account.Properties.Encryption.Services",
	"failover_in_progress":                                   "Description.Account.properties.failoverInProgress",
	"file_soft_delete_enabled":                               "Description.FileServiceProperties.properties.shareDeleteRetentionPolicy.enabled",
	"file_soft_delete_retention_days":                        "Description.FileServiceProperties.properties.shareDeleteRetentionPolicy.days",
	"id":                                                     "Description.Account.id",
	"is_hns_enabled":                                         "Description.Account.properties.isHnsEnabled",
	"kind":                                                   "Description.Account.kind",
	"minimum_tls_version":                                    "Description.Account.properties.minimumTlsVersion",
	"name":                                                   "Description.Account.name",
	"network_ip_rules":                                       "Description.Account.Properties.NetworkRuleSet.IPRules",
	"network_rule_bypass":                                    "Description.Account.properties.networkAcls.bypass",
	"network_rule_default_action":                            "Description.Account.properties.networkAcls.defaultAction",
	"platform_integration_id":                                "IntegrationID",
	"primary_blob_endpoint":                                  "Description.Account.properties.primaryEndpoints.blob",
	"primary_dfs_endpoint":                                   "Description.Account.properties.primaryEndpoints.dfs",
	"primary_file_endpoint":                                  "Description.Account.properties.primaryEndpoints.file",
	"primary_location":                                       "Description.Account.properties.primaryLocation",
	"primary_queue_endpoint":                                 "Description.Account.properties.primaryEndpoints.queue",
	"primary_table_endpoint":                                 "Description.Account.properties.primaryEndpoints.table",
	"primary_web_endpoint":                                   "Description.Account.properties.primaryEndpoints.web",
	"private_endpoint_connections":                           "Description.Account.Properties.PrivateEndpointConnections",
	"provisioning_state":                                     "Description.Account.properties.provisioningState",
	"public_network_access":                                  "Description.Account.properties.publicNetworkAccess",
	"queue_logging_delete":                                   "Description.StorageServiceProperties.Logging.Delete",
	"queue_logging_read":                                     "Description.StorageServiceProperties.Logging.Read",
	"queue_logging_retention_days":                           "Description.Logging.RetentionPolicy.Days",
	"queue_logging_retention_enabled":                        "Description.Logging.RetentionPolicy.Enabled",
	"queue_logging_version":                                  "Description.StorageServiceProperties.Logging.Version",
	"queue_logging_write":                                    "Description.StorageServiceProperties.Logging.Write",
	"require_infrastructure_encryption":                      "Description.Account.properties.encryption.requireInfrastructureEncryption",
	"sas_policy":                                             "Description.Account.Properties.SasPolicy",
	"secondary_location":                                     "Description.Account.properties.secondaryLocation",
	"sku_name":                                               "Description.Account.sku.name",
	"sku_tier":                                               "Description.Account.sku.tier",
	"status_of_primary":                                      "Description.Account.properties.statusOfPrimary",
	"status_of_secondary":                                    "Description.Account.properties.statusOfSecondary",
	"subscription":                                           "Description.Account.Properties.Subscription",
	"table_logging_delete":                                   "Description.StorageServiceProperties.Logging.Delete",
	"table_logging_read":                                     "Description.StorageServiceProperties.Logging.Read",
	"table_logging_retention_policy":                         "Description.StorageServiceProperties.Logging.RetentionPolicy",
	"table_logging_version":                                  "Description.StorageServiceProperties.Logging.Version",
	"table_logging_write":                                    "Description.StorageServiceProperties.Logging.Write",
	"table_properties":                                       "Description.TableProperties",
	"tags":                                                   "Description.Account.Tags",
	"title":                                                  "Description.Account.name",
	"type":                                                   "Description.Account.type",
	"virtual_network_rules":                                  "Description.Account.Properties.NetworkRuleSet.VirtualNetworkRules",
}

func ListStorageAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStorageAccount")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageAccount NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageAccount NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewStorageAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, listStorageAccountFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListStorageAccount NewStorageAccountPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListStorageAccount paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getStorageAccountFilters = map[string]string{
	"access_keys":                                            "Description.AccessKeys",
	"access_tier":                                            "Description.Account.properties.accessTier",
	"allow_blob_public_access":                               "Description.Account.properties.allowBlobPublicAccess",
	"blob_change_feed_enabled":                               "Description.BlobServiceProperties.properties.changeFeed.enabled",
	"blob_container_soft_delete_enabled":                     "Description.BlobServiceProperties.properties.containerDeleteRetentionPolicy.enabled",
	"blob_container_soft_delete_retention_days":              "Description.BlobServiceProperties.properties.containerDeleteRetentionPolicy.days",
	"blob_restore_policy_days":                               "Description.BlobServiceProperties.properties.restorePolicy.days",
	"blob_restore_policy_enabled":                            "Description.BlobServiceProperties.properties.restorePolicy.enabled",
	"blob_service_logging":                                   "Description.Logging",
	"blob_soft_delete_enabled":                               "Description.BlobServiceProperties.properties.containerDeleteRetentionPolicy.enabled",
	"blob_soft_delete_retention_days":                        "Description.BlobServiceProperties.properties.containerDeleteRetentionPolicy.days",
	"blob_versioning_enabled":                                "Description.BlobServiceProperties.properties.isVersioningEnabled",
	"enable_https_traffic_only":                              "Description.Account.properties.supportsHttpsTrafficOnly",
	"encryption_key_source":                                  "Description.Account.properties.encryption.keySource",
	"encryption_key_vault_properties_key_current_version_id": "Description.Account.properties.encryption.keyvaultproperties.currentVersionedKeyIdentifier",
	"encryption_key_vault_properties_key_name":               "Description.Account.properties.encryption.keyvaultproperties.keyname",
	"encryption_key_vault_properties_key_vault_uri":          "Description.Account.properties.encryption.keyvaultproperties.keyvaulturi",
	"encryption_key_vault_properties_key_version":            "Description.Account.properties.encryption.keyvaultproperties.keyversion",
	"encryption_services":                                    "Description.Account.Properties.Encryption.Services",
	"failover_in_progress":                                   "Description.Account.properties.failoverInProgress",
	"file_soft_delete_enabled":                               "Description.FileServiceProperties.properties.shareDeleteRetentionPolicy.enabled",
	"file_soft_delete_retention_days":                        "Description.FileServiceProperties.properties.shareDeleteRetentionPolicy.days",
	"id":                                                     "Description.Account.id",
	"is_hns_enabled":                                         "Description.Account.properties.isHnsEnabled",
	"kind":                                                   "Description.Account.kind",
	"minimum_tls_version":                                    "Description.Account.properties.minimumTlsVersion",
	"name":                                                   "description.Account.name",
	"network_ip_rules":                                       "Description.Account.Properties.NetworkRuleSet.IPRules",
	"network_rule_bypass":                                    "Description.Account.properties.networkAcls.bypass",
	"network_rule_default_action":                            "Description.Account.properties.networkAcls.defaultAction",
	"platform_integration_id":                                "IntegrationID",
	"primary_blob_endpoint":                                  "Description.Account.properties.primaryEndpoints.blob",
	"primary_dfs_endpoint":                                   "Description.Account.properties.primaryEndpoints.dfs",
	"primary_file_endpoint":                                  "Description.Account.properties.primaryEndpoints.file",
	"primary_location":                                       "Description.Account.properties.primaryLocation",
	"primary_queue_endpoint":                                 "Description.Account.properties.primaryEndpoints.queue",
	"primary_table_endpoint":                                 "Description.Account.properties.primaryEndpoints.table",
	"primary_web_endpoint":                                   "Description.Account.properties.primaryEndpoints.web",
	"private_endpoint_connections":                           "Description.Account.Properties.PrivateEndpointConnections",
	"provisioning_state":                                     "Description.Account.properties.provisioningState",
	"public_network_access":                                  "Description.Account.properties.publicNetworkAccess",
	"queue_logging_delete":                                   "Description.StorageServiceProperties.Logging.Delete",
	"queue_logging_read":                                     "Description.StorageServiceProperties.Logging.Read",
	"queue_logging_retention_days":                           "Description.Logging.RetentionPolicy.Days",
	"queue_logging_retention_enabled":                        "Description.Logging.RetentionPolicy.Enabled",
	"queue_logging_version":                                  "Description.StorageServiceProperties.Logging.Version",
	"queue_logging_write":                                    "Description.StorageServiceProperties.Logging.Write",
	"require_infrastructure_encryption":                      "Description.Account.properties.encryption.requireInfrastructureEncryption",
	"resource_group":                                         "description.ResourceGroup",
	"sas_policy":                                             "Description.Account.Properties.SasPolicy",
	"secondary_location":                                     "Description.Account.properties.secondaryLocation",
	"sku_name":                                               "Description.Account.sku.name",
	"sku_tier":                                               "Description.Account.sku.tier",
	"status_of_primary":                                      "Description.Account.properties.statusOfPrimary",
	"status_of_secondary":                                    "Description.Account.properties.statusOfSecondary",
	"subscription":                                           "Description.Account.Properties.Subscription",
	"table_logging_delete":                                   "Description.StorageServiceProperties.Logging.Delete",
	"table_logging_read":                                     "Description.StorageServiceProperties.Logging.Read",
	"table_logging_retention_policy":                         "Description.StorageServiceProperties.Logging.RetentionPolicy",
	"table_logging_version":                                  "Description.StorageServiceProperties.Logging.Version",
	"table_logging_write":                                    "Description.StorageServiceProperties.Logging.Write",
	"table_properties":                                       "Description.TableProperties",
	"tags":                                                   "Description.Account.Tags",
	"title":                                                  "Description.Account.name",
	"type":                                                   "Description.Account.type",
	"virtual_network_rules":                                  "Description.Account.Properties.NetworkRuleSet.VirtualNetworkRules",
}

func GetStorageAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStorageAccount")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewStorageAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, getStorageAccountFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: StorageAccount =============================

// ==========================  START: RecoveryServicesVault =============================

type RecoveryServicesVault struct {
	ResourceID      string                                 `json:"resource_id"`
	PlatformID      string                                 `json:"platform_id"`
	Description     azure.RecoveryServicesVaultDescription `json:"Description"`
	Metadata        azure.Metadata                         `json:"metadata"`
	DescribedBy     string                                 `json:"described_by"`
	ResourceType    string                                 `json:"resource_type"`
	IntegrationType string                                 `json:"integration_type"`
	IntegrationID   string                                 `json:"integration_id"`
}

type RecoveryServicesVaultHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  RecoveryServicesVault `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type RecoveryServicesVaultHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []RecoveryServicesVaultHit `json:"hits"`
}

type RecoveryServicesVaultSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  RecoveryServicesVaultHits `json:"hits"`
}

type RecoveryServicesVaultPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRecoveryServicesVaultPaginator(filters []essdk.BoolFilter, limit *int64) (RecoveryServicesVaultPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_recoveryservices_vaults", filters, limit)
	if err != nil {
		return RecoveryServicesVaultPaginator{}, err
	}

	p := RecoveryServicesVaultPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RecoveryServicesVaultPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RecoveryServicesVaultPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RecoveryServicesVaultPaginator) NextPage(ctx context.Context) ([]RecoveryServicesVault, error) {
	var response RecoveryServicesVaultSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RecoveryServicesVault
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRecoveryServicesVaultFilters = map[string]string{
	"diagnostic_settings":               "Description.DiagnosticSettingsResource",
	"etag":                              "Description.Vault.etag",
	"id":                                "Description.Vault.id",
	"identity":                          "Description.Vault.Identity",
	"name":                              "Description.Vault.name",
	"platform_integration_id":           "IntegrationID",
	"private_endpoint_connections":      "Description.Vault.Properties.PrivateEndpointConnections",
	"private_endpoint_state_for_backup": "Description.Vault.properties.privateEndpointStateForBackup",
	"private_endpoint_state_for_site_recovery": "Description.Vault.properties.privateEndpointStateForSiteRecovery",
	"provisioning_state":                       "Description.Vault.properties.provisioningState",
	"resource_group":                           "Description.ResourceGroup",
	"sku_name":                                 "Description.Vault.sku.name",
	"subscription":                             "Description.Vault.Properties.Subscription",
	"tags":                                     "Description.Vault.Tags",
	"title":                                    "Description.Vault.name",
	"type":                                     "Description.Vault.type",
	"upgrade_details":                          "Description.Vault.Properties.UpgradeDetails",
}

func ListRecoveryServicesVault(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRecoveryServicesVault")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRecoveryServicesVault NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRecoveryServicesVault NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRecoveryServicesVault GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRecoveryServicesVault GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRecoveryServicesVault GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRecoveryServicesVaultPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRecoveryServicesVaultFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRecoveryServicesVault NewRecoveryServicesVaultPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRecoveryServicesVault paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRecoveryServicesVaultFilters = map[string]string{
	"diagnostic_settings":               "Description.DiagnosticSettingsResource",
	"etag":                              "Description.Vault.etag",
	"id":                                "Description.Vault.id",
	"identity":                          "Description.Vault.Identity",
	"name":                              "description.Vault.Name",
	"platform_integration_id":           "IntegrationID",
	"private_endpoint_connections":      "Description.Vault.Properties.PrivateEndpointConnections",
	"private_endpoint_state_for_backup": "Description.Vault.properties.privateEndpointStateForBackup",
	"private_endpoint_state_for_site_recovery": "Description.Vault.properties.privateEndpointStateForSiteRecovery",
	"provisioning_state":                       "Description.Vault.properties.provisioningState",
	"resource_group":                           "description.ResourceGroup",
	"sku_name":                                 "Description.Vault.sku.name",
	"subscription":                             "Description.Vault.Properties.Subscription",
	"tags":                                     "Description.Vault.Tags",
	"title":                                    "Description.Vault.name",
	"type":                                     "Description.Vault.type",
	"upgrade_details":                          "Description.Vault.Properties.UpgradeDetails",
}

func GetRecoveryServicesVault(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRecoveryServicesVault")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRecoveryServicesVaultPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRecoveryServicesVaultFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RecoveryServicesVault =============================

// ==========================  START: RecoveryServicesBackupJob =============================

type RecoveryServicesBackupJob struct {
	ResourceID      string                                     `json:"resource_id"`
	PlatformID      string                                     `json:"platform_id"`
	Description     azure.RecoveryServicesBackupJobDescription `json:"Description"`
	Metadata        azure.Metadata                             `json:"metadata"`
	DescribedBy     string                                     `json:"described_by"`
	ResourceType    string                                     `json:"resource_type"`
	IntegrationType string                                     `json:"integration_type"`
	IntegrationID   string                                     `json:"integration_id"`
}

type RecoveryServicesBackupJobHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  RecoveryServicesBackupJob `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type RecoveryServicesBackupJobHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []RecoveryServicesBackupJobHit `json:"hits"`
}

type RecoveryServicesBackupJobSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  RecoveryServicesBackupJobHits `json:"hits"`
}

type RecoveryServicesBackupJobPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRecoveryServicesBackupJobPaginator(filters []essdk.BoolFilter, limit *int64) (RecoveryServicesBackupJobPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_recoveryservices_vaults_backupjobs", filters, limit)
	if err != nil {
		return RecoveryServicesBackupJobPaginator{}, err
	}

	p := RecoveryServicesBackupJobPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RecoveryServicesBackupJobPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RecoveryServicesBackupJobPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RecoveryServicesBackupJobPaginator) NextPage(ctx context.Context) ([]RecoveryServicesBackupJob, error) {
	var response RecoveryServicesBackupJobSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RecoveryServicesBackupJob
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRecoveryServicesBackupJobFilters = map[string]string{
	"etag":                    "Description.Job.ETag",
	"id":                      "Description.Job.ID",
	"name":                    "Description.Job.Name",
	"platform_integration_id": "IntegrationID",
	"properties":              "Description.Properties",
	"resource_group":          "Description.ResourceGroup",
	"subscription":            "Description.Job.Properties.Subscription",
	"tags":                    "Description.Job.Tags",
	"title":                   "Description.Job.Name",
	"type":                    "Description.Job.Type",
	"vault_name":              "Description.VaultName",
}

func ListRecoveryServicesBackupJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRecoveryServicesBackupJob")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRecoveryServicesBackupJob NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRecoveryServicesBackupJob NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRecoveryServicesBackupJob GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRecoveryServicesBackupJob GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRecoveryServicesBackupJob GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRecoveryServicesBackupJobPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRecoveryServicesBackupJobFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRecoveryServicesBackupJob NewRecoveryServicesBackupJobPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRecoveryServicesBackupJob paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRecoveryServicesBackupJobFilters = map[string]string{
	"etag":                    "Description.Job.ETag",
	"id":                      "Description.Job.ID",
	"name":                    "description.Vault.Name",
	"platform_integration_id": "IntegrationID",
	"properties":              "Description.Properties",
	"resource_group":          "description.ResourceGroup",
	"subscription":            "Description.Job.Properties.Subscription",
	"tags":                    "Description.Job.Tags",
	"title":                   "Description.Job.Name",
	"type":                    "Description.Job.Type",
	"vault_name":              "Description.VaultName",
}

func GetRecoveryServicesBackupJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRecoveryServicesBackupJob")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRecoveryServicesBackupJobPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRecoveryServicesBackupJobFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RecoveryServicesBackupJob =============================

// ==========================  START: RecoveryServicesBackupPolicy =============================

type RecoveryServicesBackupPolicy struct {
	ResourceID      string                                        `json:"resource_id"`
	PlatformID      string                                        `json:"platform_id"`
	Description     azure.RecoveryServicesBackupPolicyDescription `json:"Description"`
	Metadata        azure.Metadata                                `json:"metadata"`
	DescribedBy     string                                        `json:"described_by"`
	ResourceType    string                                        `json:"resource_type"`
	IntegrationType string                                        `json:"integration_type"`
	IntegrationID   string                                        `json:"integration_id"`
}

type RecoveryServicesBackupPolicyHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  RecoveryServicesBackupPolicy `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type RecoveryServicesBackupPolicyHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []RecoveryServicesBackupPolicyHit `json:"hits"`
}

type RecoveryServicesBackupPolicySearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  RecoveryServicesBackupPolicyHits `json:"hits"`
}

type RecoveryServicesBackupPolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRecoveryServicesBackupPolicyPaginator(filters []essdk.BoolFilter, limit *int64) (RecoveryServicesBackupPolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_recoveryservices_vaults_backuppolicies", filters, limit)
	if err != nil {
		return RecoveryServicesBackupPolicyPaginator{}, err
	}

	p := RecoveryServicesBackupPolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RecoveryServicesBackupPolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RecoveryServicesBackupPolicyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RecoveryServicesBackupPolicyPaginator) NextPage(ctx context.Context) ([]RecoveryServicesBackupPolicy, error) {
	var response RecoveryServicesBackupPolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RecoveryServicesBackupPolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRecoveryServicesBackupPolicyFilters = map[string]string{
	"id":                      "Description.Policy.ID",
	"name":                    "Description.Policy.Name",
	"platform_integration_id": "IntegrationID",
	"properties":              "Description.Properties",
	"resource_group":          "Description.ResourceGroup",
	"subscription":            "Description.Policy.Properties.Subscription",
	"title":                   "Description.Policy.Name",
	"vault_name":              "Description.VaultName",
}

func ListRecoveryServicesBackupPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRecoveryServicesBackupPolicy")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRecoveryServicesBackupPolicy NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRecoveryServicesBackupPolicy NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRecoveryServicesBackupPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRecoveryServicesBackupPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRecoveryServicesBackupPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRecoveryServicesBackupPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRecoveryServicesBackupPolicyFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRecoveryServicesBackupPolicy NewRecoveryServicesBackupPolicyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRecoveryServicesBackupPolicy paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRecoveryServicesBackupPolicyFilters = map[string]string{
	"id":                      "Description.Policy.ID",
	"name":                    "description.Policy.Name",
	"platform_integration_id": "IntegrationID",
	"properties":              "Description.Properties",
	"resource_group":          "description.ResourceGroup",
	"subscription":            "Description.Policy.Properties.Subscription",
	"title":                   "Description.Policy.Name",
	"vault_name":              "Description.VaultName",
}

func GetRecoveryServicesBackupPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRecoveryServicesBackupPolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRecoveryServicesBackupPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRecoveryServicesBackupPolicyFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RecoveryServicesBackupPolicy =============================

// ==========================  START: RecoveryServicesBackupItem =============================

type RecoveryServicesBackupItem struct {
	ResourceID      string                                      `json:"resource_id"`
	PlatformID      string                                      `json:"platform_id"`
	Description     azure.RecoveryServicesBackupItemDescription `json:"Description"`
	Metadata        azure.Metadata                              `json:"metadata"`
	DescribedBy     string                                      `json:"described_by"`
	ResourceType    string                                      `json:"resource_type"`
	IntegrationType string                                      `json:"integration_type"`
	IntegrationID   string                                      `json:"integration_id"`
}

type RecoveryServicesBackupItemHit struct {
	ID      string                     `json:"_id"`
	Score   float64                    `json:"_score"`
	Index   string                     `json:"_index"`
	Type    string                     `json:"_type"`
	Version int64                      `json:"_version,omitempty"`
	Source  RecoveryServicesBackupItem `json:"_source"`
	Sort    []interface{}              `json:"sort"`
}

type RecoveryServicesBackupItemHits struct {
	Total essdk.SearchTotal               `json:"total"`
	Hits  []RecoveryServicesBackupItemHit `json:"hits"`
}

type RecoveryServicesBackupItemSearchResponse struct {
	PitID string                         `json:"pit_id"`
	Hits  RecoveryServicesBackupItemHits `json:"hits"`
}

type RecoveryServicesBackupItemPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRecoveryServicesBackupItemPaginator(filters []essdk.BoolFilter, limit *int64) (RecoveryServicesBackupItemPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_recoveryservices_vaults_backupitems", filters, limit)
	if err != nil {
		return RecoveryServicesBackupItemPaginator{}, err
	}

	p := RecoveryServicesBackupItemPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RecoveryServicesBackupItemPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RecoveryServicesBackupItemPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RecoveryServicesBackupItemPaginator) NextPage(ctx context.Context) ([]RecoveryServicesBackupItem, error) {
	var response RecoveryServicesBackupItemSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RecoveryServicesBackupItem
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRecoveryServicesBackupItemFilters = map[string]string{
	"id":                      "Description.Item.ID",
	"name":                    "Description.Item.Name",
	"platform_integration_id": "IntegrationID",
	"properties":              "Description.Properties",
	"resource_group":          "Description.ResourceGroup",
	"subscription":            "Description.Item.Properties.Subscription",
	"title":                   "Description.Item.Name",
	"vault_name":              "Description.VaultName",
}

func ListRecoveryServicesBackupItem(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRecoveryServicesBackupItem")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRecoveryServicesBackupItem NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRecoveryServicesBackupItem NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRecoveryServicesBackupItem GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRecoveryServicesBackupItem GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRecoveryServicesBackupItem GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRecoveryServicesBackupItemPaginator(essdk.BuildFilter(ctx, d.QueryContext, listRecoveryServicesBackupItemFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRecoveryServicesBackupItem NewRecoveryServicesBackupItemPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRecoveryServicesBackupItem paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRecoveryServicesBackupItemFilters = map[string]string{
	"id":                      "Description.Item.ID",
	"name":                    "description.Item.Name",
	"platform_integration_id": "IntegrationID",
	"properties":              "Description.Properties",
	"resource_group":          "description.ResourceGroup",
	"subscription":            "Description.Item.Properties.Subscription",
	"title":                   "Description.Item.Name",
	"vault_name":              "Description.VaultName",
}

func GetRecoveryServicesBackupItem(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRecoveryServicesBackupItem")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRecoveryServicesBackupItemPaginator(essdk.BuildFilter(ctx, d.QueryContext, getRecoveryServicesBackupItemFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: RecoveryServicesBackupItem =============================

// ==========================  START: HybridKubernetesConnectedCluster =============================

type HybridKubernetesConnectedCluster struct {
	ResourceID      string                                            `json:"resource_id"`
	PlatformID      string                                            `json:"platform_id"`
	Description     azure.HybridKubernetesConnectedClusterDescription `json:"Description"`
	Metadata        azure.Metadata                                    `json:"metadata"`
	DescribedBy     string                                            `json:"described_by"`
	ResourceType    string                                            `json:"resource_type"`
	IntegrationType string                                            `json:"integration_type"`
	IntegrationID   string                                            `json:"integration_id"`
}

type HybridKubernetesConnectedClusterHit struct {
	ID      string                           `json:"_id"`
	Score   float64                          `json:"_score"`
	Index   string                           `json:"_index"`
	Type    string                           `json:"_type"`
	Version int64                            `json:"_version,omitempty"`
	Source  HybridKubernetesConnectedCluster `json:"_source"`
	Sort    []interface{}                    `json:"sort"`
}

type HybridKubernetesConnectedClusterHits struct {
	Total essdk.SearchTotal                     `json:"total"`
	Hits  []HybridKubernetesConnectedClusterHit `json:"hits"`
}

type HybridKubernetesConnectedClusterSearchResponse struct {
	PitID string                               `json:"pit_id"`
	Hits  HybridKubernetesConnectedClusterHits `json:"hits"`
}

type HybridKubernetesConnectedClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewHybridKubernetesConnectedClusterPaginator(filters []essdk.BoolFilter, limit *int64) (HybridKubernetesConnectedClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_kubernetes_connectedclusters", filters, limit)
	if err != nil {
		return HybridKubernetesConnectedClusterPaginator{}, err
	}

	p := HybridKubernetesConnectedClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p HybridKubernetesConnectedClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p HybridKubernetesConnectedClusterPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p HybridKubernetesConnectedClusterPaginator) NextPage(ctx context.Context) ([]HybridKubernetesConnectedCluster, error) {
	var response HybridKubernetesConnectedClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []HybridKubernetesConnectedCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listHybridKubernetesConnectedClusterFilters = map[string]string{
	"agent_public_key_certificate": "Description.ConnectedCluster.properties.agentPublicKeyCertificate",
	"agent_version":                "Description.ConnectedCluster.properties.agentVersion",
	"connectivity_status":          "Description.ConnectedCluster.properties.connectivityStatus",
	"created_by":                   "Description.ConnectedCluster.systemData.createdBy",
	"created_by_type":              "Description.ConnectedCluster.systemData.createdByType",
	"distribution":                 "Description.ConnectedCluster.properties.distribution",
	"extensions":                   "Description.ConnectedClusterExtensions",
	"identity":                     "Description.ConnectedCluster.Identity",
	"infrastructure":               "Description.ConnectedCluster.properties.infrastructure",
	"kubernetes_version":           "Description.ConnectedCluster.properties.kubernetesVersion",
	"last_modified_by":             "Description.ConnectedCluster.systemData.lastModifiedBy",
	"last_modified_by_type":        "Description.ConnectedCluster.systemData.lastModifiedByType",
	"location":                     "Description.ConnectedCluster.location",
	"name":                         "Description.ConnectedCluster.name",
	"offering":                     "Description.ConnectedCluster.properties.offering",
	"platform_integration_id":      "IntegrationID",
	"provisioning_state":           "Description.ConnectedCluster.properties.provisioningState",
	"resource_group":               "Description.ResourceGroup",
	"subscription":                 "Description.ConnectedCluster.Properties.Subscription",
	"tags":                         "Description.ConnectedCluster.Tags",
	"title":                        "Description.ConnectedCluster.name",
	"total_core_count":             "Description.ConnectedCluster.properties.totalCoreCount",
	"total_node_count":             "Description.ConnectedCluster.properties.totalNodeCount",
	"type":                         "Description.ConnectedCluster.type",
}

func ListHybridKubernetesConnectedCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListHybridKubernetesConnectedCluster")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListHybridKubernetesConnectedCluster NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListHybridKubernetesConnectedCluster NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListHybridKubernetesConnectedCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListHybridKubernetesConnectedCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListHybridKubernetesConnectedCluster GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewHybridKubernetesConnectedClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, listHybridKubernetesConnectedClusterFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListHybridKubernetesConnectedCluster NewHybridKubernetesConnectedClusterPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListHybridKubernetesConnectedCluster paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getHybridKubernetesConnectedClusterFilters = map[string]string{
	"agent_public_key_certificate": "Description.ConnectedCluster.properties.agentPublicKeyCertificate",
	"agent_version":                "Description.ConnectedCluster.properties.agentVersion",
	"connectivity_status":          "Description.ConnectedCluster.properties.connectivityStatus",
	"created_by":                   "Description.ConnectedCluster.systemData.createdBy",
	"created_by_type":              "Description.ConnectedCluster.systemData.createdByType",
	"distribution":                 "Description.ConnectedCluster.properties.distribution",
	"extensions":                   "Description.ConnectedClusterExtensions",
	"identity":                     "Description.ConnectedCluster.Identity",
	"infrastructure":               "Description.ConnectedCluster.properties.infrastructure",
	"kubernetes_version":           "Description.ConnectedCluster.properties.kubernetesVersion",
	"last_modified_by":             "Description.ConnectedCluster.systemData.lastModifiedBy",
	"last_modified_by_type":        "Description.ConnectedCluster.systemData.lastModifiedByType",
	"location":                     "Description.ConnectedCluster.location",
	"name":                         "description.ConnectedCluster.Name",
	"offering":                     "Description.ConnectedCluster.properties.offering",
	"platform_integration_id":      "IntegrationID",
	"provisioning_state":           "Description.ConnectedCluster.properties.provisioningState",
	"resource_group":               "description.ResourceGroup",
	"subscription":                 "Description.ConnectedCluster.Properties.Subscription",
	"tags":                         "Description.ConnectedCluster.Tags",
	"title":                        "Description.ConnectedCluster.name",
	"total_core_count":             "Description.ConnectedCluster.properties.totalCoreCount",
	"total_node_count":             "Description.ConnectedCluster.properties.totalNodeCount",
	"type":                         "Description.ConnectedCluster.type",
}

func GetHybridKubernetesConnectedCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetHybridKubernetesConnectedCluster")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewHybridKubernetesConnectedClusterPaginator(essdk.BuildFilter(ctx, d.QueryContext, getHybridKubernetesConnectedClusterFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: HybridKubernetesConnectedCluster =============================

// ==========================  START: CostManagementCostByResourceType =============================

type CostManagementCostByResourceType struct {
	ResourceID      string                                            `json:"resource_id"`
	PlatformID      string                                            `json:"platform_id"`
	Description     azure.CostManagementCostByResourceTypeDescription `json:"Description"`
	Metadata        azure.Metadata                                    `json:"metadata"`
	DescribedBy     string                                            `json:"described_by"`
	ResourceType    string                                            `json:"resource_type"`
	IntegrationType string                                            `json:"integration_type"`
	IntegrationID   string                                            `json:"integration_id"`
}

type CostManagementCostByResourceTypeHit struct {
	ID      string                           `json:"_id"`
	Score   float64                          `json:"_score"`
	Index   string                           `json:"_index"`
	Type    string                           `json:"_type"`
	Version int64                            `json:"_version,omitempty"`
	Source  CostManagementCostByResourceType `json:"_source"`
	Sort    []interface{}                    `json:"sort"`
}

type CostManagementCostByResourceTypeHits struct {
	Total essdk.SearchTotal                     `json:"total"`
	Hits  []CostManagementCostByResourceTypeHit `json:"hits"`
}

type CostManagementCostByResourceTypeSearchResponse struct {
	PitID string                               `json:"pit_id"`
	Hits  CostManagementCostByResourceTypeHits `json:"hits"`
}

type CostManagementCostByResourceTypePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCostManagementCostByResourceTypePaginator(filters []essdk.BoolFilter, limit *int64) (CostManagementCostByResourceTypePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_costmanagement_costbyresourcetype", filters, limit)
	if err != nil {
		return CostManagementCostByResourceTypePaginator{}, err
	}

	p := CostManagementCostByResourceTypePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CostManagementCostByResourceTypePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CostManagementCostByResourceTypePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CostManagementCostByResourceTypePaginator) NextPage(ctx context.Context) ([]CostManagementCostByResourceType, error) {
	var response CostManagementCostByResourceTypeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CostManagementCostByResourceType
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCostManagementCostByResourceTypeFilters = map[string]string{
	"cost":                    "Description.CostManagementCostByResourceType.Cost",
	"id":                      "ResourceID",
	"platform_integration_id": "IntegrationID",
	"publisher_type":          "Description.CostManagementCostByResourceType.PublisherType",
	"resource_type":           "Metadata.ResourceType",
	"service_name":            "Description.CostManagementCostByResourceType.ServiceName",
	"subscription":            "Description.CostManagementCostByResourceType.Subscription",
	"usage_date":              "Description.CostManagementCostByResourceType.UsageDate",
}

func ListCostManagementCostByResourceType(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCostManagementCostByResourceType")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostManagementCostByResourceType NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostManagementCostByResourceType NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostManagementCostByResourceType GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostManagementCostByResourceType GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostManagementCostByResourceType GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCostManagementCostByResourceTypePaginator(essdk.BuildFilter(ctx, d.QueryContext, listCostManagementCostByResourceTypeFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostManagementCostByResourceType NewCostManagementCostByResourceTypePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCostManagementCostByResourceType paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCostManagementCostByResourceTypeFilters = map[string]string{
	"cost":                    "Description.CostManagementCostByResourceType.Cost",
	"id":                      "ResourceID",
	"platform_integration_id": "IntegrationID",
	"publisher_type":          "Description.CostManagementCostByResourceType.PublisherType",
	"resource_type":           "Metadata.ResourceType",
	"service_name":            "Description.CostManagementCostByResourceType.ServiceName",
	"subscription":            "Description.CostManagementCostByResourceType.Subscription",
	"usage_date":              "Description.CostManagementCostByResourceType.UsageDate",
}

func GetCostManagementCostByResourceType(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCostManagementCostByResourceType")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCostManagementCostByResourceTypePaginator(essdk.BuildFilter(ctx, d.QueryContext, getCostManagementCostByResourceTypeFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CostManagementCostByResourceType =============================

// ==========================  START: CostManagementCostBySubscription =============================

type CostManagementCostBySubscription struct {
	ResourceID      string                                            `json:"resource_id"`
	PlatformID      string                                            `json:"platform_id"`
	Description     azure.CostManagementCostBySubscriptionDescription `json:"Description"`
	Metadata        azure.Metadata                                    `json:"metadata"`
	DescribedBy     string                                            `json:"described_by"`
	ResourceType    string                                            `json:"resource_type"`
	IntegrationType string                                            `json:"integration_type"`
	IntegrationID   string                                            `json:"integration_id"`
}

type CostManagementCostBySubscriptionHit struct {
	ID      string                           `json:"_id"`
	Score   float64                          `json:"_score"`
	Index   string                           `json:"_index"`
	Type    string                           `json:"_type"`
	Version int64                            `json:"_version,omitempty"`
	Source  CostManagementCostBySubscription `json:"_source"`
	Sort    []interface{}                    `json:"sort"`
}

type CostManagementCostBySubscriptionHits struct {
	Total essdk.SearchTotal                     `json:"total"`
	Hits  []CostManagementCostBySubscriptionHit `json:"hits"`
}

type CostManagementCostBySubscriptionSearchResponse struct {
	PitID string                               `json:"pit_id"`
	Hits  CostManagementCostBySubscriptionHits `json:"hits"`
}

type CostManagementCostBySubscriptionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCostManagementCostBySubscriptionPaginator(filters []essdk.BoolFilter, limit *int64) (CostManagementCostBySubscriptionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_costmanagement_costbysubscription", filters, limit)
	if err != nil {
		return CostManagementCostBySubscriptionPaginator{}, err
	}

	p := CostManagementCostBySubscriptionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CostManagementCostBySubscriptionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CostManagementCostBySubscriptionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p CostManagementCostBySubscriptionPaginator) NextPage(ctx context.Context) ([]CostManagementCostBySubscription, error) {
	var response CostManagementCostBySubscriptionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CostManagementCostBySubscription
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCostManagementCostBySubscriptionFilters = map[string]string{
	"id":                      "ResourceID",
	"name":                    "Description.CostManagementCostBySubscription",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.CostManagementCostBySubscription.Subscription",
}

func ListCostManagementCostBySubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCostManagementCostBySubscription")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostManagementCostBySubscription NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostManagementCostBySubscription NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostManagementCostBySubscription GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostManagementCostBySubscription GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostManagementCostBySubscription GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewCostManagementCostBySubscriptionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listCostManagementCostBySubscriptionFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListCostManagementCostBySubscription NewCostManagementCostBySubscriptionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListCostManagementCostBySubscription paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getCostManagementCostBySubscriptionFilters = map[string]string{
	"id":                      "ResourceID",
	"name":                    "Description.CostManagementCostBySubscription",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.CostManagementCostBySubscription.Subscription",
}

func GetCostManagementCostBySubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCostManagementCostBySubscription")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewCostManagementCostBySubscriptionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getCostManagementCostBySubscriptionFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: CostManagementCostBySubscription =============================

// ==========================  START: LoadBalancer =============================

type LoadBalancer struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     azure.LoadBalancerDescription `json:"Description"`
	Metadata        azure.Metadata                `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type LoadBalancerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  LoadBalancer  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type LoadBalancerHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []LoadBalancerHit `json:"hits"`
}

type LoadBalancerSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  LoadBalancerHits `json:"hits"`
}

type LoadBalancerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLoadBalancerPaginator(filters []essdk.BoolFilter, limit *int64) (LoadBalancerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_loadbalancers", filters, limit)
	if err != nil {
		return LoadBalancerPaginator{}, err
	}

	p := LoadBalancerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LoadBalancerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LoadBalancerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LoadBalancerPaginator) NextPage(ctx context.Context) ([]LoadBalancer, error) {
	var response LoadBalancerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LoadBalancer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLoadBalancerFilters = map[string]string{
	"backend_address_pools":      "Description.LoadBalancer.Properties.BackendAddressPools",
	"diagnostic_settings":        "Description.DiagnosticSetting",
	"etag":                       "Description.LoadBalancer.etag",
	"extended_location_name":     "Description.LoadBalancer.extendedLocation.name",
	"extended_location_type":     "Description.LoadBalancer.extendedLocation.type",
	"frontend_ip_configurations": "Description.LoadBalancer.Properties.FrontendIPConfigurations",
	"id":                         "Description.LoadBalancer.id",
	"inbound_nat_pools":          "Description.LoadBalancer.Properties.InboundNatPools",
	"inbound_nat_rules":          "Description.LoadBalancer.Properties.InboundNatRules",
	"load_balancing_rules":       "Description.LoadBalancer.Properties.LoadBalancingRules",
	"name":                       "Description.LoadBalancer.name",
	"outbound_rules":             "Description.LoadBalancer.Properties.OutboundRules",
	"platform_integration_id":    "IntegrationID",
	"probes":                     "Description.LoadBalancer.Properties.Probes",
	"provisioning_state":         "Description.LoadBalancer.properties.provisioningState",
	"resource_group":             "Description.ResourceGroup",
	"resource_guid":              "Description.LoadBalancer.properties.resourceGuid",
	"sku_name":                   "Description.LoadBalancer.sku.name",
	"sku_tier":                   "Description.LoadBalancer.sku.tier",
	"subscription":               "Description.LoadBalancer.Properties.Subscription",
	"tags":                       "Description.LoadBalancer.Tags",
	"title":                      "Description.LoadBalancer.name",
	"type":                       "Description.LoadBalancer.type",
}

func ListLoadBalancer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLoadBalancer")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancer NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancer NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancer GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancer GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancer GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLoadBalancerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listLoadBalancerFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancer NewLoadBalancerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLoadBalancer paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLoadBalancerFilters = map[string]string{
	"backend_address_pools":      "Description.LoadBalancer.Properties.BackendAddressPools",
	"diagnostic_settings":        "Description.DiagnosticSetting",
	"etag":                       "Description.LoadBalancer.etag",
	"extended_location_name":     "Description.LoadBalancer.extendedLocation.name",
	"extended_location_type":     "Description.LoadBalancer.extendedLocation.type",
	"frontend_ip_configurations": "Description.LoadBalancer.Properties.FrontendIPConfigurations",
	"id":                         "Description.LoadBalancer.id",
	"inbound_nat_pools":          "Description.LoadBalancer.Properties.InboundNatPools",
	"inbound_nat_rules":          "Description.LoadBalancer.Properties.InboundNatRules",
	"load_balancing_rules":       "Description.LoadBalancer.Properties.LoadBalancingRules",
	"name":                       "description.LoadBalancer.Name",
	"outbound_rules":             "Description.LoadBalancer.Properties.OutboundRules",
	"platform_integration_id":    "IntegrationID",
	"probes":                     "Description.LoadBalancer.Properties.Probes",
	"provisioning_state":         "Description.LoadBalancer.properties.provisioningState",
	"resource_group":             "description.ResourceGroup",
	"resource_guid":              "Description.LoadBalancer.properties.resourceGuid",
	"sku_name":                   "Description.LoadBalancer.sku.name",
	"sku_tier":                   "Description.LoadBalancer.sku.tier",
	"subscription":               "Description.LoadBalancer.Properties.Subscription",
	"tags":                       "Description.LoadBalancer.Tags",
	"title":                      "Description.LoadBalancer.name",
	"type":                       "Description.LoadBalancer.type",
}

func GetLoadBalancer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLoadBalancer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLoadBalancerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getLoadBalancerFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: LoadBalancer =============================

// ==========================  START: LoadBalancerBackendAddressPool =============================

type LoadBalancerBackendAddressPool struct {
	ResourceID      string                                          `json:"resource_id"`
	PlatformID      string                                          `json:"platform_id"`
	Description     azure.LoadBalancerBackendAddressPoolDescription `json:"Description"`
	Metadata        azure.Metadata                                  `json:"metadata"`
	DescribedBy     string                                          `json:"described_by"`
	ResourceType    string                                          `json:"resource_type"`
	IntegrationType string                                          `json:"integration_type"`
	IntegrationID   string                                          `json:"integration_id"`
}

type LoadBalancerBackendAddressPoolHit struct {
	ID      string                         `json:"_id"`
	Score   float64                        `json:"_score"`
	Index   string                         `json:"_index"`
	Type    string                         `json:"_type"`
	Version int64                          `json:"_version,omitempty"`
	Source  LoadBalancerBackendAddressPool `json:"_source"`
	Sort    []interface{}                  `json:"sort"`
}

type LoadBalancerBackendAddressPoolHits struct {
	Total essdk.SearchTotal                   `json:"total"`
	Hits  []LoadBalancerBackendAddressPoolHit `json:"hits"`
}

type LoadBalancerBackendAddressPoolSearchResponse struct {
	PitID string                             `json:"pit_id"`
	Hits  LoadBalancerBackendAddressPoolHits `json:"hits"`
}

type LoadBalancerBackendAddressPoolPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLoadBalancerBackendAddressPoolPaginator(filters []essdk.BoolFilter, limit *int64) (LoadBalancerBackendAddressPoolPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_loadbalancers_backendaddresspools", filters, limit)
	if err != nil {
		return LoadBalancerBackendAddressPoolPaginator{}, err
	}

	p := LoadBalancerBackendAddressPoolPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LoadBalancerBackendAddressPoolPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LoadBalancerBackendAddressPoolPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LoadBalancerBackendAddressPoolPaginator) NextPage(ctx context.Context) ([]LoadBalancerBackendAddressPool, error) {
	var response LoadBalancerBackendAddressPoolSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LoadBalancerBackendAddressPool
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLoadBalancerBackendAddressPoolFilters = map[string]string{
	"backend_ip_configurations":              "Description.Pool.Properties.BackendIPConfigurations",
	"etag":                                   "Description.Pool.etag",
	"gateway_load_balancer_tunnel_interface": "Description.Pool.Properties.TunnelInterfaces",
	"id":                                     "Description.Pool.id",
	"load_balancer_backend_addresses":        "Description.Pool.Properties.LoadBalancerBackendAddresses",
	"load_balancer_name":                     "Description.LoadBalancer.name",
	"load_balancing_rules":                   "Description.LoadBalancer.Properties.LoadBalancingRules",
	"name":                                   "Description.Pool.name",
	"outbound_rule_id":                       "Description.Pool.properties.outboundRule.id",
	"outbound_rules":                         "Description.LoadBalancer.Properties.OutboundRules",
	"platform_integration_id":                "IntegrationID",
	"provisioning_state":                     "Description.LoadBalancer.properties.provisioningState",
	"resource_group":                         "Description.ResourceGroup",
	"subscription":                           "Description.Pool.Properties.Subscription",
	"title":                                  "Description.Pool.name",
	"type":                                   "Description.Pool.type",
}

func ListLoadBalancerBackendAddressPool(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLoadBalancerBackendAddressPool")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerBackendAddressPool NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerBackendAddressPool NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerBackendAddressPool GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerBackendAddressPool GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerBackendAddressPool GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLoadBalancerBackendAddressPoolPaginator(essdk.BuildFilter(ctx, d.QueryContext, listLoadBalancerBackendAddressPoolFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerBackendAddressPool NewLoadBalancerBackendAddressPoolPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLoadBalancerBackendAddressPool paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLoadBalancerBackendAddressPoolFilters = map[string]string{
	"backend_ip_configurations":              "Description.Pool.Properties.BackendIPConfigurations",
	"etag":                                   "Description.Pool.etag",
	"gateway_load_balancer_tunnel_interface": "Description.Pool.Properties.TunnelInterfaces",
	"id":                                     "Description.Pool.id",
	"load_balancer_backend_addresses":        "Description.Pool.Properties.LoadBalancerBackendAddresses",
	"load_balancer_name":                     "description.LoadBalancer.Name",
	"load_balancing_rules":                   "Description.LoadBalancer.Properties.LoadBalancingRules",
	"name":                                   "description.Pool.Name",
	"outbound_rule_id":                       "Description.Pool.properties.outboundRule.id",
	"outbound_rules":                         "Description.LoadBalancer.Properties.OutboundRules",
	"platform_integration_id":                "IntegrationID",
	"provisioning_state":                     "Description.LoadBalancer.properties.provisioningState",
	"resource_group":                         "description.ResourceGroup",
	"subscription":                           "Description.Pool.Properties.Subscription",
	"title":                                  "Description.Pool.name",
	"type":                                   "Description.Pool.type",
}

func GetLoadBalancerBackendAddressPool(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLoadBalancerBackendAddressPool")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLoadBalancerBackendAddressPoolPaginator(essdk.BuildFilter(ctx, d.QueryContext, getLoadBalancerBackendAddressPoolFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: LoadBalancerBackendAddressPool =============================

// ==========================  START: LoadBalancerNatRule =============================

type LoadBalancerNatRule struct {
	ResourceID      string                               `json:"resource_id"`
	PlatformID      string                               `json:"platform_id"`
	Description     azure.LoadBalancerNatRuleDescription `json:"Description"`
	Metadata        azure.Metadata                       `json:"metadata"`
	DescribedBy     string                               `json:"described_by"`
	ResourceType    string                               `json:"resource_type"`
	IntegrationType string                               `json:"integration_type"`
	IntegrationID   string                               `json:"integration_id"`
}

type LoadBalancerNatRuleHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  LoadBalancerNatRule `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type LoadBalancerNatRuleHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []LoadBalancerNatRuleHit `json:"hits"`
}

type LoadBalancerNatRuleSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  LoadBalancerNatRuleHits `json:"hits"`
}

type LoadBalancerNatRulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLoadBalancerNatRulePaginator(filters []essdk.BoolFilter, limit *int64) (LoadBalancerNatRulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_loadbalancers_inboundnatrules", filters, limit)
	if err != nil {
		return LoadBalancerNatRulePaginator{}, err
	}

	p := LoadBalancerNatRulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LoadBalancerNatRulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LoadBalancerNatRulePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LoadBalancerNatRulePaginator) NextPage(ctx context.Context) ([]LoadBalancerNatRule, error) {
	var response LoadBalancerNatRuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LoadBalancerNatRule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLoadBalancerNatRuleFilters = map[string]string{
	"backend_ip_configuration":  "Description.Rule.Properties.BackendIPConfiguration",
	"backend_port":              "Description.Rule.properties.backendPort",
	"enable_floating_ip":        "Description.Rule.properties.enableFloatingIP",
	"enable_tcp_reset":          "Description.Rule.properties.enableTcpReset",
	"etag":                      "Description.Rule.etag",
	"frontend_ip_configuration": "Description.Rule.Properties.FrontendIPConfiguration",
	"frontend_port":             "Description.Rule.properties.frontendPort",
	"id":                        "Description.Rule.id",
	"idle_timeout_in_minutes":   "Description.Rule.properties.idleTimeoutInMinutes",
	"load_balancer_name":        "Description.LoadBalancerName",
	"name":                      "Description.Rule.name",
	"platform_integration_id":   "IntegrationID",
	"protocol":                  "Description.Rule.properties.protocol",
	"provisioning_state":        "Description.Rule.properties.provisioningState",
	"resource_group":            "Description.ResourceGroup",
	"subscription":              "Description.Rule.Properties.Subscription",
	"title":                     "Description.Rule.name",
	"type":                      "Description.Rule.type",
}

func ListLoadBalancerNatRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLoadBalancerNatRule")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerNatRule NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerNatRule NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerNatRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerNatRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerNatRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLoadBalancerNatRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, listLoadBalancerNatRuleFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerNatRule NewLoadBalancerNatRulePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLoadBalancerNatRule paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLoadBalancerNatRuleFilters = map[string]string{
	"backend_ip_configuration":  "Description.Rule.Properties.BackendIPConfiguration",
	"backend_port":              "Description.Rule.properties.backendPort",
	"enable_floating_ip":        "Description.Rule.properties.enableFloatingIP",
	"enable_tcp_reset":          "Description.Rule.properties.enableTcpReset",
	"etag":                      "Description.Rule.etag",
	"frontend_ip_configuration": "Description.Rule.Properties.FrontendIPConfiguration",
	"frontend_port":             "Description.Rule.properties.frontendPort",
	"id":                        "Description.Rule.id",
	"idle_timeout_in_minutes":   "Description.Rule.properties.idleTimeoutInMinutes",
	"load_balancer_name":        "description.LoadBalancerName",
	"name":                      "description.Rule.Name",
	"platform_integration_id":   "IntegrationID",
	"protocol":                  "Description.Rule.properties.protocol",
	"provisioning_state":        "Description.Rule.properties.provisioningState",
	"resource_group":            "description.ResourceGroup",
	"subscription":              "Description.Rule.Properties.Subscription",
	"title":                     "Description.Rule.name",
	"type":                      "Description.Rule.type",
}

func GetLoadBalancerNatRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLoadBalancerNatRule")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLoadBalancerNatRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, getLoadBalancerNatRuleFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: LoadBalancerNatRule =============================

// ==========================  START: LoadBalancerOutboundRule =============================

type LoadBalancerOutboundRule struct {
	ResourceID      string                                    `json:"resource_id"`
	PlatformID      string                                    `json:"platform_id"`
	Description     azure.LoadBalancerOutboundRuleDescription `json:"Description"`
	Metadata        azure.Metadata                            `json:"metadata"`
	DescribedBy     string                                    `json:"described_by"`
	ResourceType    string                                    `json:"resource_type"`
	IntegrationType string                                    `json:"integration_type"`
	IntegrationID   string                                    `json:"integration_id"`
}

type LoadBalancerOutboundRuleHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  LoadBalancerOutboundRule `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type LoadBalancerOutboundRuleHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []LoadBalancerOutboundRuleHit `json:"hits"`
}

type LoadBalancerOutboundRuleSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  LoadBalancerOutboundRuleHits `json:"hits"`
}

type LoadBalancerOutboundRulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLoadBalancerOutboundRulePaginator(filters []essdk.BoolFilter, limit *int64) (LoadBalancerOutboundRulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_loadbalancers_outboundrules", filters, limit)
	if err != nil {
		return LoadBalancerOutboundRulePaginator{}, err
	}

	p := LoadBalancerOutboundRulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LoadBalancerOutboundRulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LoadBalancerOutboundRulePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LoadBalancerOutboundRulePaginator) NextPage(ctx context.Context) ([]LoadBalancerOutboundRule, error) {
	var response LoadBalancerOutboundRuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LoadBalancerOutboundRule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLoadBalancerOutboundRuleFilters = map[string]string{
	"allocated_outbound_ports":   "Description.Rule.properties.allocatedOutboundPorts",
	"backend_address_pools":      "Description.Rule.Properties.BackendAddressPool",
	"enable_tcp_reset":           "Description.Rule.properties.enableTcpReset",
	"etag":                       "Description.Rule.etag",
	"frontend_ip_configurations": "Description.Rule.Properties.FrontendIPConfigurations",
	"id":                         "Description.Rule.id",
	"idle_timeout_in_minutes":    "Description.Rule.properties.idleTimeoutInMinutes",
	"load_balancer_name":         "Description.LoadBalancerName",
	"name":                       "Description.Rule.name",
	"platform_integration_id":    "IntegrationID",
	"protocol":                   "Description.Rule.properties.protocol",
	"provisioning_state":         "Description.Rule.properties.provisioningState",
	"resource_group":             "Description.ResourceGroup",
	"subscription":               "Description.Rule.Properties.Subscription",
	"title":                      "Description.Rule.name",
	"type":                       "Description.Rule.type",
}

func ListLoadBalancerOutboundRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLoadBalancerOutboundRule")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerOutboundRule NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerOutboundRule NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerOutboundRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerOutboundRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerOutboundRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLoadBalancerOutboundRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, listLoadBalancerOutboundRuleFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerOutboundRule NewLoadBalancerOutboundRulePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLoadBalancerOutboundRule paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLoadBalancerOutboundRuleFilters = map[string]string{
	"allocated_outbound_ports":   "Description.Rule.properties.allocatedOutboundPorts",
	"backend_address_pools":      "Description.Rule.Properties.BackendAddressPool",
	"enable_tcp_reset":           "Description.Rule.properties.enableTcpReset",
	"etag":                       "Description.Rule.etag",
	"frontend_ip_configurations": "Description.Rule.Properties.FrontendIPConfigurations",
	"id":                         "Description.Rule.id",
	"idle_timeout_in_minutes":    "Description.Rule.properties.idleTimeoutInMinutes",
	"load_balancer_name":         "description.LoadBalancerName",
	"name":                       "description.Rule.Name",
	"platform_integration_id":    "IntegrationID",
	"protocol":                   "Description.Rule.properties.protocol",
	"provisioning_state":         "Description.Rule.properties.provisioningState",
	"resource_group":             "description.ResourceGroup",
	"subscription":               "Description.Rule.Properties.Subscription",
	"title":                      "Description.Rule.name",
	"type":                       "Description.Rule.type",
}

func GetLoadBalancerOutboundRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLoadBalancerOutboundRule")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLoadBalancerOutboundRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, getLoadBalancerOutboundRuleFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: LoadBalancerOutboundRule =============================

// ==========================  START: LoadBalancerProbe =============================

type LoadBalancerProbe struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     azure.LoadBalancerProbeDescription `json:"Description"`
	Metadata        azure.Metadata                     `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type LoadBalancerProbeHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  LoadBalancerProbe `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type LoadBalancerProbeHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []LoadBalancerProbeHit `json:"hits"`
}

type LoadBalancerProbeSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  LoadBalancerProbeHits `json:"hits"`
}

type LoadBalancerProbePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLoadBalancerProbePaginator(filters []essdk.BoolFilter, limit *int64) (LoadBalancerProbePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_loadbalancers_probes", filters, limit)
	if err != nil {
		return LoadBalancerProbePaginator{}, err
	}

	p := LoadBalancerProbePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LoadBalancerProbePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LoadBalancerProbePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LoadBalancerProbePaginator) NextPage(ctx context.Context) ([]LoadBalancerProbe, error) {
	var response LoadBalancerProbeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LoadBalancerProbe
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLoadBalancerProbeFilters = map[string]string{
	"etag":                    "Description.Probe.etag",
	"id":                      "Description.Probe.id",
	"interval_in_seconds":     "Description.Probe.properties.intervalInSeconds",
	"load_balancer_name":      "Description.LoadBalancerName",
	"load_balancing_rules":    "Description.Probe.Properties.LoadBalancingRules",
	"name":                    "Description.Probe.name",
	"number_of_probes":        "Description.Probe.properties.numberOfProbes",
	"platform_integration_id": "IntegrationID",
	"port":                    "Description.Probe.properties.port",
	"protocol":                "Description.Probe.properties.protocol",
	"provisioning_state":      "Description.Probe.properties.provisioningState",
	"request_path":            "Description.Probe.properties.requestPath",
	"resource_group":          "Description.ResourceGroup",
	"subscription":            "Description.Probe.Properties.Subscription",
	"title":                   "Description.Probe.name",
	"type":                    "Description.Probe.type",
}

func ListLoadBalancerProbe(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLoadBalancerProbe")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerProbe NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerProbe NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerProbe GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerProbe GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerProbe GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLoadBalancerProbePaginator(essdk.BuildFilter(ctx, d.QueryContext, listLoadBalancerProbeFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerProbe NewLoadBalancerProbePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLoadBalancerProbe paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLoadBalancerProbeFilters = map[string]string{
	"etag":                    "Description.Probe.etag",
	"id":                      "Description.Probe.id",
	"interval_in_seconds":     "Description.Probe.properties.intervalInSeconds",
	"load_balancer_name":      "description.LoadBalancerName",
	"load_balancing_rules":    "Description.Probe.Properties.LoadBalancingRules",
	"name":                    "description.Probe.Name",
	"number_of_probes":        "Description.Probe.properties.numberOfProbes",
	"platform_integration_id": "IntegrationID",
	"port":                    "Description.Probe.properties.port",
	"protocol":                "Description.Probe.properties.protocol",
	"provisioning_state":      "Description.Probe.properties.provisioningState",
	"request_path":            "Description.Probe.properties.requestPath",
	"resource_group":          "description.ResourceGroup",
	"subscription":            "Description.Probe.Properties.Subscription",
	"title":                   "Description.Probe.name",
	"type":                    "Description.Probe.type",
}

func GetLoadBalancerProbe(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLoadBalancerProbe")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLoadBalancerProbePaginator(essdk.BuildFilter(ctx, d.QueryContext, getLoadBalancerProbeFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: LoadBalancerProbe =============================

// ==========================  START: LoadBalancerRule =============================

type LoadBalancerRule struct {
	ResourceID      string                            `json:"resource_id"`
	PlatformID      string                            `json:"platform_id"`
	Description     azure.LoadBalancerRuleDescription `json:"Description"`
	Metadata        azure.Metadata                    `json:"metadata"`
	DescribedBy     string                            `json:"described_by"`
	ResourceType    string                            `json:"resource_type"`
	IntegrationType string                            `json:"integration_type"`
	IntegrationID   string                            `json:"integration_id"`
}

type LoadBalancerRuleHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  LoadBalancerRule `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type LoadBalancerRuleHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []LoadBalancerRuleHit `json:"hits"`
}

type LoadBalancerRuleSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  LoadBalancerRuleHits `json:"hits"`
}

type LoadBalancerRulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLoadBalancerRulePaginator(filters []essdk.BoolFilter, limit *int64) (LoadBalancerRulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_loadbalancers_loadbalancingrules", filters, limit)
	if err != nil {
		return LoadBalancerRulePaginator{}, err
	}

	p := LoadBalancerRulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LoadBalancerRulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LoadBalancerRulePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LoadBalancerRulePaginator) NextPage(ctx context.Context) ([]LoadBalancerRule, error) {
	var response LoadBalancerRuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LoadBalancerRule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLoadBalancerRuleFilters = map[string]string{
	"backend_address_pool_id":      "Description.Rule.properties.backendAddressPool.id",
	"backend_address_pools":        "Description.Rule.Properties.BackendAddressPools",
	"backend_port":                 "Description.Rule.properties.backendPort",
	"disable_outbound_snat":        "Description.Rule.properties.disableOutboundSnat",
	"enable_floating_ip":           "Description.Rule.properties.enableFloatingIP",
	"enable_tcp_reset":             "Description.Rule.properties.enableTcpReset",
	"etag":                         "Description.Rule.etag",
	"frontend_ip_configuration_id": "Description.Rule.properties.frontendIPConfiguration.id",
	"frontend_port":                "Description.Rule.properties.frontendPort",
	"id":                           "Description.Rule.id",
	"idle_timeout_in_minutes":      "Description.Rule.properties.idleTimeoutInMinutes",
	"load_balancer_name":           "Description.LoadBalancerName",
	"load_distribution":            "Description.Rule.properties.loadDistribution",
	"name":                         "Description.Rule.name",
	"platform_integration_id":      "IntegrationID",
	"probe_id":                     "Description.Rule.properties.probe.id",
	"protocol":                     "Description.Rule.properties.protocol",
	"provisioning_state":           "Description.Rule.properties.provisioningState",
	"resource_group":               "Description.ResourceGroup",
	"subscription":                 "Description.Rule.Properties.Subscription",
	"title":                        "Description.Rule.name",
	"type":                         "Description.Rule.type",
}

func ListLoadBalancerRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLoadBalancerRule")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerRule NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerRule NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLoadBalancerRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, listLoadBalancerRuleFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerRule NewLoadBalancerRulePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLoadBalancerRule paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLoadBalancerRuleFilters = map[string]string{
	"backend_address_pool_id":      "Description.Rule.properties.backendAddressPool.id",
	"backend_address_pools":        "Description.Rule.Properties.BackendAddressPools",
	"backend_port":                 "Description.Rule.properties.backendPort",
	"disable_outbound_snat":        "Description.Rule.properties.disableOutboundSnat",
	"enable_floating_ip":           "Description.Rule.properties.enableFloatingIP",
	"enable_tcp_reset":             "Description.Rule.properties.enableTcpReset",
	"etag":                         "Description.Rule.etag",
	"frontend_ip_configuration_id": "Description.Rule.properties.frontendIPConfiguration.id",
	"frontend_port":                "Description.Rule.properties.frontendPort",
	"id":                           "Description.Rule.id",
	"idle_timeout_in_minutes":      "Description.Rule.properties.idleTimeoutInMinutes",
	"load_balancer_name":           "description.LoadBalancerName",
	"load_distribution":            "Description.Rule.properties.loadDistribution",
	"name":                         "description.Rule.Name",
	"platform_integration_id":      "IntegrationID",
	"probe_id":                     "Description.Rule.properties.probe.id",
	"protocol":                     "Description.Rule.properties.protocol",
	"provisioning_state":           "Description.Rule.properties.provisioningState",
	"resource_group":               "description.ResourceGroup",
	"subscription":                 "Description.Rule.Properties.Subscription",
	"title":                        "Description.Rule.name",
	"type":                         "Description.Rule.type",
}

func GetLoadBalancerRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLoadBalancerRule")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLoadBalancerRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, getLoadBalancerRuleFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: LoadBalancerRule =============================

// ==========================  START: ManagementGroup =============================

type ManagementGroup struct {
	ResourceID      string                           `json:"resource_id"`
	PlatformID      string                           `json:"platform_id"`
	Description     azure.ManagementGroupDescription `json:"Description"`
	Metadata        azure.Metadata                   `json:"metadata"`
	DescribedBy     string                           `json:"described_by"`
	ResourceType    string                           `json:"resource_type"`
	IntegrationType string                           `json:"integration_type"`
	IntegrationID   string                           `json:"integration_id"`
}

type ManagementGroupHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  ManagementGroup `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type ManagementGroupHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []ManagementGroupHit `json:"hits"`
}

type ManagementGroupSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  ManagementGroupHits `json:"hits"`
}

type ManagementGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewManagementGroupPaginator(filters []essdk.BoolFilter, limit *int64) (ManagementGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_management_managementgroups", filters, limit)
	if err != nil {
		return ManagementGroupPaginator{}, err
	}

	p := ManagementGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ManagementGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ManagementGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ManagementGroupPaginator) NextPage(ctx context.Context) ([]ManagementGroup, error) {
	var response ManagementGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ManagementGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listManagementGroupFilters = map[string]string{
	"children":                "Description.Group.Properties.Children",
	"display_name":            "Description.Group.properties.displayName",
	"id":                      "Description.Group.id",
	"name":                    "Description.Group.name",
	"parent":                  "Description.Group.Properties.Details.Parent",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Group.Properties.Subscription",
	"tenant_id":               "Description.Group.properties.tenantId",
	"title":                   "Description.Group.name",
	"type":                    "Description.Group.type",
	"updated_by":              "Description.Group.properties.details.updatedBy",
	"updated_time":            "Description.Group.Properties.Details.UpdatedTime.Time",
	"version":                 "Description.Group.properties.details.version",
}

func ListManagementGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListManagementGroup")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListManagementGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListManagementGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListManagementGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListManagementGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListManagementGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewManagementGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listManagementGroupFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListManagementGroup NewManagementGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListManagementGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getManagementGroupFilters = map[string]string{
	"children":                "Description.Group.Properties.Children",
	"display_name":            "Description.Group.properties.displayName",
	"id":                      "Description.Group.id",
	"name":                    "description.Group.Name",
	"parent":                  "Description.Group.Properties.Details.Parent",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Group.Properties.Subscription",
	"tenant_id":               "Description.Group.properties.tenantId",
	"title":                   "Description.Group.name",
	"type":                    "Description.Group.type",
	"updated_by":              "Description.Group.properties.details.updatedBy",
	"updated_time":            "Description.Group.Properties.Details.UpdatedTime.Time",
	"version":                 "Description.Group.properties.details.version",
}

func GetManagementGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetManagementGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewManagementGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getManagementGroupFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ManagementGroup =============================

// ==========================  START: ManagementLock =============================

type ManagementLock struct {
	ResourceID      string                          `json:"resource_id"`
	PlatformID      string                          `json:"platform_id"`
	Description     azure.ManagementLockDescription `json:"Description"`
	Metadata        azure.Metadata                  `json:"metadata"`
	DescribedBy     string                          `json:"described_by"`
	ResourceType    string                          `json:"resource_type"`
	IntegrationType string                          `json:"integration_type"`
	IntegrationID   string                          `json:"integration_id"`
}

type ManagementLockHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  ManagementLock `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type ManagementLockHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []ManagementLockHit `json:"hits"`
}

type ManagementLockSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  ManagementLockHits `json:"hits"`
}

type ManagementLockPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewManagementLockPaginator(filters []essdk.BoolFilter, limit *int64) (ManagementLockPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_management_locks", filters, limit)
	if err != nil {
		return ManagementLockPaginator{}, err
	}

	p := ManagementLockPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ManagementLockPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ManagementLockPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ManagementLockPaginator) NextPage(ctx context.Context) ([]ManagementLock, error) {
	var response ManagementLockSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ManagementLock
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listManagementLockFilters = map[string]string{
	"id":                      "Description.Lock.id",
	"lock_level":              "Description.Lock.properties.level",
	"name":                    "Description.Lock.name",
	"notes":                   "Description.Lock.properties.notes",
	"owners":                  "Description.Lock.Properties.Owners",
	"platform_integration_id": "IntegrationID",
	"subscription":            "Description.Lock.Properties.Subscription",
	"title":                   "Description.Lock.name",
	"type":                    "Description.Lock.type",
}

func ListManagementLock(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListManagementLock")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListManagementLock NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListManagementLock NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListManagementLock GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListManagementLock GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListManagementLock GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewManagementLockPaginator(essdk.BuildFilter(ctx, d.QueryContext, listManagementLockFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListManagementLock NewManagementLockPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListManagementLock paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getManagementLockFilters = map[string]string{
	"id":                      "Description.Lock.id",
	"lock_level":              "Description.Lock.properties.level",
	"name":                    "description.Lock.Name",
	"notes":                   "Description.Lock.properties.notes",
	"owners":                  "Description.Lock.Properties.Owners",
	"platform_integration_id": "IntegrationID",
	"resource_group":          "description.ResourceGroup",
	"subscription":            "Description.Lock.Properties.Subscription",
	"title":                   "Description.Lock.name",
	"type":                    "Description.Lock.type",
}

func GetManagementLock(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetManagementLock")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewManagementLockPaginator(essdk.BuildFilter(ctx, d.QueryContext, getManagementLockFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ManagementLock =============================

// ==========================  START: ResourceProvider =============================

type ResourceProvider struct {
	ResourceID      string                            `json:"resource_id"`
	PlatformID      string                            `json:"platform_id"`
	Description     azure.ResourceProviderDescription `json:"Description"`
	Metadata        azure.Metadata                    `json:"metadata"`
	DescribedBy     string                            `json:"described_by"`
	ResourceType    string                            `json:"resource_type"`
	IntegrationType string                            `json:"integration_type"`
	IntegrationID   string                            `json:"integration_id"`
}

type ResourceProviderHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  ResourceProvider `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type ResourceProviderHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []ResourceProviderHit `json:"hits"`
}

type ResourceProviderSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  ResourceProviderHits `json:"hits"`
}

type ResourceProviderPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewResourceProviderPaginator(filters []essdk.BoolFilter, limit *int64) (ResourceProviderPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_resources_providers", filters, limit)
	if err != nil {
		return ResourceProviderPaginator{}, err
	}

	p := ResourceProviderPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ResourceProviderPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ResourceProviderPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ResourceProviderPaginator) NextPage(ctx context.Context) ([]ResourceProvider, error) {
	var response ResourceProviderSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ResourceProvider
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listResourceProviderFilters = map[string]string{
	"id":                      "Description.Provider.id",
	"namespace":               "Description.Provider.namespace",
	"platform_integration_id": "IntegrationID",
	"registration_state":      "Description.Provider.registrationState",
	"resource_types":          "Description.Provider.ResourceTypes",
	"subscription":            "Description.Provider.Properties.Subscription",
	"title":                   "Description.Provider.namespace",
}

func ListResourceProvider(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListResourceProvider")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceProvider NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceProvider NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceProvider GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceProvider GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceProvider GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewResourceProviderPaginator(essdk.BuildFilter(ctx, d.QueryContext, listResourceProviderFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceProvider NewResourceProviderPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListResourceProvider paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getResourceProviderFilters = map[string]string{
	"id":                      "Description.Provider.id",
	"namespace":               "description.Provider.Namespace",
	"platform_integration_id": "IntegrationID",
	"registration_state":      "Description.Provider.registrationState",
	"resource_types":          "Description.Provider.ResourceTypes",
	"subscription":            "Description.Provider.Properties.Subscription",
	"title":                   "Description.Provider.namespace",
}

func GetResourceProvider(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetResourceProvider")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewResourceProviderPaginator(essdk.BuildFilter(ctx, d.QueryContext, getResourceProviderFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ResourceProvider =============================

// ==========================  START: ResourceGroup =============================

type ResourceGroup struct {
	ResourceID      string                         `json:"resource_id"`
	PlatformID      string                         `json:"platform_id"`
	Description     azure.ResourceGroupDescription `json:"Description"`
	Metadata        azure.Metadata                 `json:"metadata"`
	DescribedBy     string                         `json:"described_by"`
	ResourceType    string                         `json:"resource_type"`
	IntegrationType string                         `json:"integration_type"`
	IntegrationID   string                         `json:"integration_id"`
}

type ResourceGroupHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ResourceGroup `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ResourceGroupHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []ResourceGroupHit `json:"hits"`
}

type ResourceGroupSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  ResourceGroupHits `json:"hits"`
}

type ResourceGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewResourceGroupPaginator(filters []essdk.BoolFilter, limit *int64) (ResourceGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_resources_subscriptions_resourcegroups", filters, limit)
	if err != nil {
		return ResourceGroupPaginator{}, err
	}

	p := ResourceGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ResourceGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ResourceGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ResourceGroupPaginator) NextPage(ctx context.Context) ([]ResourceGroup, error) {
	var response ResourceGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ResourceGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listResourceGroupFilters = map[string]string{
	"id":                      "Description.Group.id",
	"managed_by":              "Description.Group.managedBy",
	"name":                    "Description.Group.name",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.Group.properties.provisioningState",
	"subscription":            "Description.Group.Properties.Subscription",
	"tags":                    "Description.Group.Tags",
	"title":                   "Description.Group.name",
	"type":                    "Description.Group.type",
}

func ListResourceGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListResourceGroup")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewResourceGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listResourceGroupFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListResourceGroup NewResourceGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListResourceGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getResourceGroupFilters = map[string]string{
	"id":                      "Description.Group.id",
	"managed_by":              "Description.Group.managedBy",
	"name":                    "description.Group.Name",
	"platform_integration_id": "IntegrationID",
	"provisioning_state":      "Description.Group.properties.provisioningState",
	"subscription":            "Description.Group.Properties.Subscription",
	"tags":                    "Description.Group.Tags",
	"title":                   "Description.Group.name",
	"type":                    "Description.Group.type",
}

func GetResourceGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetResourceGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewResourceGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getResourceGroupFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ResourceGroup =============================

// ==========================  START: GenericResource =============================

type GenericResource struct {
	ResourceID      string                           `json:"resource_id"`
	PlatformID      string                           `json:"platform_id"`
	Description     azure.GenericResourceDescription `json:"Description"`
	Metadata        azure.Metadata                   `json:"metadata"`
	DescribedBy     string                           `json:"described_by"`
	ResourceType    string                           `json:"resource_type"`
	IntegrationType string                           `json:"integration_type"`
	IntegrationID   string                           `json:"integration_id"`
}

type GenericResourceHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  GenericResource `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type GenericResourceHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []GenericResourceHit `json:"hits"`
}

type GenericResourceSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  GenericResourceHits `json:"hits"`
}

type GenericResourcePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewGenericResourcePaginator(filters []essdk.BoolFilter, limit *int64) (GenericResourcePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_resources_subscriptions_resources", filters, limit)
	if err != nil {
		return GenericResourcePaginator{}, err
	}

	p := GenericResourcePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p GenericResourcePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p GenericResourcePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p GenericResourcePaginator) NextPage(ctx context.Context) ([]GenericResource, error) {
	var response GenericResourceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []GenericResource
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listGenericResourceFilters = map[string]string{
	"changed_time":          "Description.GenericResource.ChangedTime",
	"created_time":          "Description.GenericResource.CreatedTime",
	"extended_location":     "Description.GenericResource.ExtendedLocation",
	"id":                    "Description.GenericResource.id",
	"identity":              "Description.GenericResource.Identity",
	"identity_principal_id": "Description.GenericResource.identity.principalId",
	"kind":                  "Description.GenericResource.kind",
	"managed_by":            "Description.GenericResource.managedBy",
	"name":                  "Description.GenericResource.name",
	"plan_name":             "Description.GenericResource.plan.name",
	"plan_product":          "Description.GenericResource.plan.product",
	"plan_promotion_code":   "Description.GenericResource.plan.promotionCode",
	"plan_publisher":        "Description.GenericResource.plan.publisher",
	"plan_version":          "Description.GenericResource.plan.version",
	"properties":            "Description.GenericResource.Properties",
	"provisioning_state":    "Description.GenericResource.Identity.ProvisioningState",
	"sku":                   "Description.GenericResource.SKU",
	"subscription":          "Description.GenericResource.Properties.Subscription",
	"tags":                  "Description.GenericResource.Tags",
	"title":                 "Description.GenericResource.name",
	"type":                  "Description.GenericResource.type",
}

func ListGenericResource(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListGenericResource")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListGenericResource NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListGenericResource NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListGenericResource GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListGenericResource GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListGenericResource GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewGenericResourcePaginator(essdk.BuildFilter(ctx, d.QueryContext, listGenericResourceFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListGenericResource NewGenericResourcePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListGenericResource paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getGenericResourceFilters = map[string]string{
	"changed_time":          "Description.GenericResource.ChangedTime",
	"created_time":          "Description.GenericResource.CreatedTime",
	"extended_location":     "Description.GenericResource.ExtendedLocation",
	"id":                    "Description.GenericResource.id",
	"identity":              "Description.GenericResource.Identity",
	"identity_principal_id": "Description.GenericResource.identity.principalId",
	"kind":                  "Description.GenericResource.kind",
	"managed_by":            "Description.GenericResource.managedBy",
	"name":                  "Description.GenericResource.name",
	"plan_name":             "Description.GenericResource.plan.name",
	"plan_product":          "Description.GenericResource.plan.product",
	"plan_promotion_code":   "Description.GenericResource.plan.promotionCode",
	"plan_publisher":        "Description.GenericResource.plan.publisher",
	"plan_version":          "Description.GenericResource.plan.version",
	"properties":            "Description.GenericResource.Properties",
	"provisioning_state":    "Description.GenericResource.Identity.ProvisioningState",
	"sku":                   "Description.GenericResource.SKU",
	"subscription":          "Description.GenericResource.Properties.Subscription",
	"tags":                  "Description.GenericResource.Tags",
	"title":                 "Description.GenericResource.name",
	"type":                  "Description.GenericResource.type",
}

func GetGenericResource(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetGenericResource")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewGenericResourcePaginator(essdk.BuildFilter(ctx, d.QueryContext, getGenericResourceFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: GenericResource =============================

// ==========================  START: BotServiceBot =============================

type BotServiceBot struct {
	ResourceID      string                         `json:"resource_id"`
	PlatformID      string                         `json:"platform_id"`
	Description     azure.BotServiceBotDescription `json:"Description"`
	Metadata        azure.Metadata                 `json:"metadata"`
	DescribedBy     string                         `json:"described_by"`
	ResourceType    string                         `json:"resource_type"`
	IntegrationType string                         `json:"integration_type"`
	IntegrationID   string                         `json:"integration_id"`
}

type BotServiceBotHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  BotServiceBot `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type BotServiceBotHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []BotServiceBotHit `json:"hits"`
}

type BotServiceBotSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  BotServiceBotHits `json:"hits"`
}

type BotServiceBotPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBotServiceBotPaginator(filters []essdk.BoolFilter, limit *int64) (BotServiceBotPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_botservice_botservices", filters, limit)
	if err != nil {
		return BotServiceBotPaginator{}, err
	}

	p := BotServiceBotPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BotServiceBotPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BotServiceBotPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BotServiceBotPaginator) NextPage(ctx context.Context) ([]BotServiceBot, error) {
	var response BotServiceBotSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BotServiceBot
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBotServiceBotFilters = map[string]string{
	"id":           "Description.Bot.id",
	"name":         "Description.Bot.name",
	"subscription": "Description.Bot.Properties.Subscription",
	"tags":         "Description.Bot.Tags",
	"title":        "Description.Bot.properties.displayName",
}

func ListBotServiceBot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBotServiceBot")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBotServiceBot NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBotServiceBot NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBotServiceBot GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBotServiceBot GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBotServiceBot GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBotServiceBotPaginator(essdk.BuildFilter(ctx, d.QueryContext, listBotServiceBotFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBotServiceBot NewBotServiceBotPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBotServiceBot paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBotServiceBotFilters = map[string]string{
	"id":           "Description.Bot.id",
	"name":         "Description.Bot.name",
	"subscription": "Description.Bot.Properties.Subscription",
	"tags":         "Description.Bot.Tags",
	"title":        "Description.Bot.properties.displayName",
}

func GetBotServiceBot(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBotServiceBot")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBotServiceBotPaginator(essdk.BuildFilter(ctx, d.QueryContext, getBotServiceBotFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: BotServiceBot =============================

// ==========================  START: NetAppAccount =============================

type NetAppAccount struct {
	ResourceID      string                         `json:"resource_id"`
	PlatformID      string                         `json:"platform_id"`
	Description     azure.NetAppAccountDescription `json:"Description"`
	Metadata        azure.Metadata                 `json:"metadata"`
	DescribedBy     string                         `json:"described_by"`
	ResourceType    string                         `json:"resource_type"`
	IntegrationType string                         `json:"integration_type"`
	IntegrationID   string                         `json:"integration_id"`
}

type NetAppAccountHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  NetAppAccount `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type NetAppAccountHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []NetAppAccountHit `json:"hits"`
}

type NetAppAccountSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  NetAppAccountHits `json:"hits"`
}

type NetAppAccountPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNetAppAccountPaginator(filters []essdk.BoolFilter, limit *int64) (NetAppAccountPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_netapp_netappaccounts", filters, limit)
	if err != nil {
		return NetAppAccountPaginator{}, err
	}

	p := NetAppAccountPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NetAppAccountPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NetAppAccountPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p NetAppAccountPaginator) NextPage(ctx context.Context) ([]NetAppAccount, error) {
	var response NetAppAccountSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NetAppAccount
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNetAppAccountFilters = map[string]string{
	"id":           "Description.Account.id",
	"name":         "Description.Account.name",
	"subscription": "Description.Account.Properties.Subscription",
	"tags":         "Description.Account.Tags",
	"title":        "Description.Account.name",
}

func ListNetAppAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNetAppAccount")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetAppAccount NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetAppAccount NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetAppAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetAppAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetAppAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewNetAppAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, listNetAppAccountFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetAppAccount NewNetAppAccountPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListNetAppAccount paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getNetAppAccountFilters = map[string]string{
	"id":           "Description.Account.id",
	"name":         "Description.Account.name",
	"subscription": "Description.Account.Properties.Subscription",
	"tags":         "Description.Account.Tags",
	"title":        "Description.Account.name",
}

func GetNetAppAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNetAppAccount")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewNetAppAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, getNetAppAccountFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: NetAppAccount =============================

// ==========================  START: NetAppCapacityPool =============================

type NetAppCapacityPool struct {
	ResourceID      string                              `json:"resource_id"`
	PlatformID      string                              `json:"platform_id"`
	Description     azure.NetAppCapacityPoolDescription `json:"Description"`
	Metadata        azure.Metadata                      `json:"metadata"`
	DescribedBy     string                              `json:"described_by"`
	ResourceType    string                              `json:"resource_type"`
	IntegrationType string                              `json:"integration_type"`
	IntegrationID   string                              `json:"integration_id"`
}

type NetAppCapacityPoolHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  NetAppCapacityPool `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type NetAppCapacityPoolHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []NetAppCapacityPoolHit `json:"hits"`
}

type NetAppCapacityPoolSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  NetAppCapacityPoolHits `json:"hits"`
}

type NetAppCapacityPoolPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNetAppCapacityPoolPaginator(filters []essdk.BoolFilter, limit *int64) (NetAppCapacityPoolPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_netapp_netappaccounts_capacitypools", filters, limit)
	if err != nil {
		return NetAppCapacityPoolPaginator{}, err
	}

	p := NetAppCapacityPoolPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NetAppCapacityPoolPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NetAppCapacityPoolPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p NetAppCapacityPoolPaginator) NextPage(ctx context.Context) ([]NetAppCapacityPool, error) {
	var response NetAppCapacityPoolSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NetAppCapacityPool
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNetAppCapacityPoolFilters = map[string]string{
	"id":           "Description.CapacityPool.id",
	"name":         "Description.CapacityPool.name",
	"subscription": "Description.CapacityPool.Properties.Subscription",
	"tags":         "Description.CapacityPool.Tags",
	"title":        "Description.CapacityPool.name",
}

func ListNetAppCapacityPool(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNetAppCapacityPool")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetAppCapacityPool NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetAppCapacityPool NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetAppCapacityPool GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetAppCapacityPool GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetAppCapacityPool GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewNetAppCapacityPoolPaginator(essdk.BuildFilter(ctx, d.QueryContext, listNetAppCapacityPoolFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListNetAppCapacityPool NewNetAppCapacityPoolPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListNetAppCapacityPool paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getNetAppCapacityPoolFilters = map[string]string{
	"id":           "Description.CapacityPool.id",
	"name":         "Description.CapacityPool.name",
	"subscription": "Description.CapacityPool.Properties.Subscription",
	"tags":         "Description.CapacityPool.Tags",
	"title":        "Description.CapacityPool.name",
}

func GetNetAppCapacityPool(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNetAppCapacityPool")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewNetAppCapacityPoolPaginator(essdk.BuildFilter(ctx, d.QueryContext, getNetAppCapacityPoolFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: NetAppCapacityPool =============================

// ==========================  START: DashboardGrafana =============================

type DashboardGrafana struct {
	ResourceID      string                            `json:"resource_id"`
	PlatformID      string                            `json:"platform_id"`
	Description     azure.DashboardGrafanaDescription `json:"Description"`
	Metadata        azure.Metadata                    `json:"metadata"`
	DescribedBy     string                            `json:"described_by"`
	ResourceType    string                            `json:"resource_type"`
	IntegrationType string                            `json:"integration_type"`
	IntegrationID   string                            `json:"integration_id"`
}

type DashboardGrafanaHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  DashboardGrafana `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type DashboardGrafanaHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []DashboardGrafanaHit `json:"hits"`
}

type DashboardGrafanaSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  DashboardGrafanaHits `json:"hits"`
}

type DashboardGrafanaPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDashboardGrafanaPaginator(filters []essdk.BoolFilter, limit *int64) (DashboardGrafanaPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_dashboard_grafana", filters, limit)
	if err != nil {
		return DashboardGrafanaPaginator{}, err
	}

	p := DashboardGrafanaPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DashboardGrafanaPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DashboardGrafanaPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DashboardGrafanaPaginator) NextPage(ctx context.Context) ([]DashboardGrafana, error) {
	var response DashboardGrafanaSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DashboardGrafana
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDashboardGrafanaFilters = map[string]string{
	"id":           "Description.Grafana.id",
	"name":         "Description.Grafana.name",
	"subscription": "Description.Grafana.Subscription",
	"title":        "Description.Grafana.name",
}

func ListDashboardGrafana(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDashboardGrafana")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDashboardGrafana NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDashboardGrafana NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDashboardGrafana GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDashboardGrafana GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDashboardGrafana GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDashboardGrafanaPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDashboardGrafanaFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDashboardGrafana NewDashboardGrafanaPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDashboardGrafana paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDashboardGrafanaFilters = map[string]string{
	"id":           "Description.Grafana.id",
	"name":         "Description.Grafana.name",
	"subscription": "Description.Grafana.Subscription",
	"title":        "Description.Grafana.name",
}

func GetDashboardGrafana(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDashboardGrafana")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDashboardGrafanaPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDashboardGrafanaFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DashboardGrafana =============================

// ==========================  START: DesktopVirtualizationHostPool =============================

type DesktopVirtualizationHostPool struct {
	ResourceID      string                                         `json:"resource_id"`
	PlatformID      string                                         `json:"platform_id"`
	Description     azure.DesktopVirtualizationHostPoolDescription `json:"Description"`
	Metadata        azure.Metadata                                 `json:"metadata"`
	DescribedBy     string                                         `json:"described_by"`
	ResourceType    string                                         `json:"resource_type"`
	IntegrationType string                                         `json:"integration_type"`
	IntegrationID   string                                         `json:"integration_id"`
}

type DesktopVirtualizationHostPoolHit struct {
	ID      string                        `json:"_id"`
	Score   float64                       `json:"_score"`
	Index   string                        `json:"_index"`
	Type    string                        `json:"_type"`
	Version int64                         `json:"_version,omitempty"`
	Source  DesktopVirtualizationHostPool `json:"_source"`
	Sort    []interface{}                 `json:"sort"`
}

type DesktopVirtualizationHostPoolHits struct {
	Total essdk.SearchTotal                  `json:"total"`
	Hits  []DesktopVirtualizationHostPoolHit `json:"hits"`
}

type DesktopVirtualizationHostPoolSearchResponse struct {
	PitID string                            `json:"pit_id"`
	Hits  DesktopVirtualizationHostPoolHits `json:"hits"`
}

type DesktopVirtualizationHostPoolPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDesktopVirtualizationHostPoolPaginator(filters []essdk.BoolFilter, limit *int64) (DesktopVirtualizationHostPoolPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_desktopvirtualization_hostpools", filters, limit)
	if err != nil {
		return DesktopVirtualizationHostPoolPaginator{}, err
	}

	p := DesktopVirtualizationHostPoolPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DesktopVirtualizationHostPoolPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DesktopVirtualizationHostPoolPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DesktopVirtualizationHostPoolPaginator) NextPage(ctx context.Context) ([]DesktopVirtualizationHostPool, error) {
	var response DesktopVirtualizationHostPoolSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DesktopVirtualizationHostPool
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDesktopVirtualizationHostPoolFilters = map[string]string{
	"id":           "Description.HostPool.id",
	"name":         "Description.HostPool.name",
	"subscription": "Description.HostPool.Properties.Subscription",
	"tags":         "Description.HostPool.Tags",
	"title":        "Description.HostPool.name",
}

func ListDesktopVirtualizationHostPool(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDesktopVirtualizationHostPool")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDesktopVirtualizationHostPool NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDesktopVirtualizationHostPool NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDesktopVirtualizationHostPool GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDesktopVirtualizationHostPool GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDesktopVirtualizationHostPool GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDesktopVirtualizationHostPoolPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDesktopVirtualizationHostPoolFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDesktopVirtualizationHostPool NewDesktopVirtualizationHostPoolPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDesktopVirtualizationHostPool paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDesktopVirtualizationHostPoolFilters = map[string]string{
	"id":           "Description.HostPool.id",
	"name":         "Description.HostPool.name",
	"subscription": "Description.HostPool.Properties.Subscription",
	"tags":         "Description.HostPool.Tags",
	"title":        "Description.HostPool.name",
}

func GetDesktopVirtualizationHostPool(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDesktopVirtualizationHostPool")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDesktopVirtualizationHostPoolPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDesktopVirtualizationHostPoolFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DesktopVirtualizationHostPool =============================

// ==========================  START: DesktopVirtualizationWorkspace =============================

type DesktopVirtualizationWorkspace struct {
	ResourceID      string                                          `json:"resource_id"`
	PlatformID      string                                          `json:"platform_id"`
	Description     azure.DesktopVirtualizationWorkspaceDescription `json:"Description"`
	Metadata        azure.Metadata                                  `json:"metadata"`
	DescribedBy     string                                          `json:"described_by"`
	ResourceType    string                                          `json:"resource_type"`
	IntegrationType string                                          `json:"integration_type"`
	IntegrationID   string                                          `json:"integration_id"`
}

type DesktopVirtualizationWorkspaceHit struct {
	ID      string                         `json:"_id"`
	Score   float64                        `json:"_score"`
	Index   string                         `json:"_index"`
	Type    string                         `json:"_type"`
	Version int64                          `json:"_version,omitempty"`
	Source  DesktopVirtualizationWorkspace `json:"_source"`
	Sort    []interface{}                  `json:"sort"`
}

type DesktopVirtualizationWorkspaceHits struct {
	Total essdk.SearchTotal                   `json:"total"`
	Hits  []DesktopVirtualizationWorkspaceHit `json:"hits"`
}

type DesktopVirtualizationWorkspaceSearchResponse struct {
	PitID string                             `json:"pit_id"`
	Hits  DesktopVirtualizationWorkspaceHits `json:"hits"`
}

type DesktopVirtualizationWorkspacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDesktopVirtualizationWorkspacePaginator(filters []essdk.BoolFilter, limit *int64) (DesktopVirtualizationWorkspacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_desktopvirtualization_workspaces", filters, limit)
	if err != nil {
		return DesktopVirtualizationWorkspacePaginator{}, err
	}

	p := DesktopVirtualizationWorkspacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DesktopVirtualizationWorkspacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DesktopVirtualizationWorkspacePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DesktopVirtualizationWorkspacePaginator) NextPage(ctx context.Context) ([]DesktopVirtualizationWorkspace, error) {
	var response DesktopVirtualizationWorkspaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DesktopVirtualizationWorkspace
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDesktopVirtualizationWorkspaceFilters = map[string]string{
	"id":           "Description.Workspace.id",
	"name":         "Description.Workspace.name",
	"subscription": "Description.Workspace.Properties.Subscription",
	"tags":         "Description.Workspace.Tags",
	"title":        "Description.Workspace.name",
}

func ListDesktopVirtualizationWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDesktopVirtualizationWorkspace")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDesktopVirtualizationWorkspace NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDesktopVirtualizationWorkspace NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDesktopVirtualizationWorkspace GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDesktopVirtualizationWorkspace GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDesktopVirtualizationWorkspace GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDesktopVirtualizationWorkspacePaginator(essdk.BuildFilter(ctx, d.QueryContext, listDesktopVirtualizationWorkspaceFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDesktopVirtualizationWorkspace NewDesktopVirtualizationWorkspacePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDesktopVirtualizationWorkspace paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDesktopVirtualizationWorkspaceFilters = map[string]string{
	"id":           "Description.Workspace.id",
	"name":         "Description.Workspace.name",
	"subscription": "Description.Workspace.Properties.Subscription",
	"tags":         "Description.Workspace.Tags",
	"title":        "Description.Workspace.name",
}

func GetDesktopVirtualizationWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDesktopVirtualizationWorkspace")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDesktopVirtualizationWorkspacePaginator(essdk.BuildFilter(ctx, d.QueryContext, getDesktopVirtualizationWorkspaceFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DesktopVirtualizationWorkspace =============================

// ==========================  START: DevTestLabLab =============================

type DevTestLabLab struct {
	ResourceID      string                         `json:"resource_id"`
	PlatformID      string                         `json:"platform_id"`
	Description     azure.DevTestLabLabDescription `json:"Description"`
	Metadata        azure.Metadata                 `json:"metadata"`
	DescribedBy     string                         `json:"described_by"`
	ResourceType    string                         `json:"resource_type"`
	IntegrationType string                         `json:"integration_type"`
	IntegrationID   string                         `json:"integration_id"`
}

type DevTestLabLabHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  DevTestLabLab `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DevTestLabLabHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []DevTestLabLabHit `json:"hits"`
}

type DevTestLabLabSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  DevTestLabLabHits `json:"hits"`
}

type DevTestLabLabPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDevTestLabLabPaginator(filters []essdk.BoolFilter, limit *int64) (DevTestLabLabPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_devtestlab_labs", filters, limit)
	if err != nil {
		return DevTestLabLabPaginator{}, err
	}

	p := DevTestLabLabPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DevTestLabLabPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DevTestLabLabPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DevTestLabLabPaginator) NextPage(ctx context.Context) ([]DevTestLabLab, error) {
	var response DevTestLabLabSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DevTestLabLab
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDevTestLabLabFilters = map[string]string{
	"id":           "Description.Lab.id",
	"name":         "Description.Lab.properties.vaultName",
	"subscription": "Description.Lab.Properties.Subscription",
	"tags":         "Description.Lab.properties.labStorageType",
	"title":        "Description.Lab.properties.vaultName",
}

func ListDevTestLabLab(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDevTestLabLab")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDevTestLabLab NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDevTestLabLab NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDevTestLabLab GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDevTestLabLab GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDevTestLabLab GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDevTestLabLabPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDevTestLabLabFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDevTestLabLab NewDevTestLabLabPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDevTestLabLab paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDevTestLabLabFilters = map[string]string{
	"id":           "Description.Lab.id",
	"name":         "Description.Lab.properties.vaultName",
	"subscription": "Description.Lab.Properties.Subscription",
	"tags":         "Description.Lab.properties.labStorageType",
	"title":        "Description.Lab.properties.vaultName",
}

func GetDevTestLabLab(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDevTestLabLab")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDevTestLabLabPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDevTestLabLabFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DevTestLabLab =============================

// ==========================  START: PurviewAccount =============================

type PurviewAccount struct {
	ResourceID      string                          `json:"resource_id"`
	PlatformID      string                          `json:"platform_id"`
	Description     azure.PurviewAccountDescription `json:"Description"`
	Metadata        azure.Metadata                  `json:"metadata"`
	DescribedBy     string                          `json:"described_by"`
	ResourceType    string                          `json:"resource_type"`
	IntegrationType string                          `json:"integration_type"`
	IntegrationID   string                          `json:"integration_id"`
}

type PurviewAccountHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  PurviewAccount `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type PurviewAccountHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []PurviewAccountHit `json:"hits"`
}

type PurviewAccountSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  PurviewAccountHits `json:"hits"`
}

type PurviewAccountPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPurviewAccountPaginator(filters []essdk.BoolFilter, limit *int64) (PurviewAccountPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_purview_accounts", filters, limit)
	if err != nil {
		return PurviewAccountPaginator{}, err
	}

	p := PurviewAccountPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PurviewAccountPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PurviewAccountPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p PurviewAccountPaginator) NextPage(ctx context.Context) ([]PurviewAccount, error) {
	var response PurviewAccountSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PurviewAccount
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPurviewAccountFilters = map[string]string{
	"id":           "Description.Account.id",
	"name":         "Description.Account.name",
	"subscription": "Description.Account.Properties.Subscription",
	"tags":         "Description.Account.Tags",
	"title":        "Description.Account.name",
}

func ListPurviewAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPurviewAccount")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListPurviewAccount NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListPurviewAccount NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListPurviewAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListPurviewAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListPurviewAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewPurviewAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, listPurviewAccountFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListPurviewAccount NewPurviewAccountPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListPurviewAccount paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getPurviewAccountFilters = map[string]string{
	"id":           "Description.Account.id",
	"name":         "Description.Account.name",
	"subscription": "Description.Account.Properties.Subscription",
	"tags":         "Description.Account.Tags",
	"title":        "Description.Account.name",
}

func GetPurviewAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPurviewAccount")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewPurviewAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, getPurviewAccountFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: PurviewAccount =============================

// ==========================  START: PowerBIDedicatedCapacity =============================

type PowerBIDedicatedCapacity struct {
	ResourceID      string                                    `json:"resource_id"`
	PlatformID      string                                    `json:"platform_id"`
	Description     azure.PowerBIDedicatedCapacityDescription `json:"Description"`
	Metadata        azure.Metadata                            `json:"metadata"`
	DescribedBy     string                                    `json:"described_by"`
	ResourceType    string                                    `json:"resource_type"`
	IntegrationType string                                    `json:"integration_type"`
	IntegrationID   string                                    `json:"integration_id"`
}

type PowerBIDedicatedCapacityHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  PowerBIDedicatedCapacity `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type PowerBIDedicatedCapacityHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []PowerBIDedicatedCapacityHit `json:"hits"`
}

type PowerBIDedicatedCapacitySearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  PowerBIDedicatedCapacityHits `json:"hits"`
}

type PowerBIDedicatedCapacityPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPowerBIDedicatedCapacityPaginator(filters []essdk.BoolFilter, limit *int64) (PowerBIDedicatedCapacityPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_powerbidedicated_capacities", filters, limit)
	if err != nil {
		return PowerBIDedicatedCapacityPaginator{}, err
	}

	p := PowerBIDedicatedCapacityPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PowerBIDedicatedCapacityPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PowerBIDedicatedCapacityPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p PowerBIDedicatedCapacityPaginator) NextPage(ctx context.Context) ([]PowerBIDedicatedCapacity, error) {
	var response PowerBIDedicatedCapacitySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PowerBIDedicatedCapacity
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPowerBIDedicatedCapacityFilters = map[string]string{
	"id":           "Description.Capacity.id",
	"name":         "Description.Capacity.name",
	"subscription": "Description.Capacity.Properties.Subscription",
	"tags":         "Description.Capacity.Tags",
	"title":        "Description.Capacity.name",
}

func ListPowerBIDedicatedCapacity(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPowerBIDedicatedCapacity")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListPowerBIDedicatedCapacity NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListPowerBIDedicatedCapacity NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListPowerBIDedicatedCapacity GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListPowerBIDedicatedCapacity GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListPowerBIDedicatedCapacity GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewPowerBIDedicatedCapacityPaginator(essdk.BuildFilter(ctx, d.QueryContext, listPowerBIDedicatedCapacityFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListPowerBIDedicatedCapacity NewPowerBIDedicatedCapacityPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListPowerBIDedicatedCapacity paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getPowerBIDedicatedCapacityFilters = map[string]string{
	"id":           "Description.Capacity.id",
	"name":         "Description.Capacity.name",
	"subscription": "Description.Capacity.Properties.Subscription",
	"tags":         "Description.Capacity.Tags",
	"title":        "Description.Capacity.name",
}

func GetPowerBIDedicatedCapacity(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPowerBIDedicatedCapacity")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewPowerBIDedicatedCapacityPaginator(essdk.BuildFilter(ctx, d.QueryContext, getPowerBIDedicatedCapacityFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: PowerBIDedicatedCapacity =============================

// ==========================  START: ApplicationInsightsComponent =============================

type ApplicationInsightsComponent struct {
	ResourceID      string                                        `json:"resource_id"`
	PlatformID      string                                        `json:"platform_id"`
	Description     azure.ApplicationInsightsComponentDescription `json:"Description"`
	Metadata        azure.Metadata                                `json:"metadata"`
	DescribedBy     string                                        `json:"described_by"`
	ResourceType    string                                        `json:"resource_type"`
	IntegrationType string                                        `json:"integration_type"`
	IntegrationID   string                                        `json:"integration_id"`
}

type ApplicationInsightsComponentHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  ApplicationInsightsComponent `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type ApplicationInsightsComponentHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []ApplicationInsightsComponentHit `json:"hits"`
}

type ApplicationInsightsComponentSearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  ApplicationInsightsComponentHits `json:"hits"`
}

type ApplicationInsightsComponentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApplicationInsightsComponentPaginator(filters []essdk.BoolFilter, limit *int64) (ApplicationInsightsComponentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_insights_components", filters, limit)
	if err != nil {
		return ApplicationInsightsComponentPaginator{}, err
	}

	p := ApplicationInsightsComponentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApplicationInsightsComponentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApplicationInsightsComponentPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ApplicationInsightsComponentPaginator) NextPage(ctx context.Context) ([]ApplicationInsightsComponent, error) {
	var response ApplicationInsightsComponentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApplicationInsightsComponent
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApplicationInsightsComponentFilters = map[string]string{
	"app_id":                              "Description.Component.properties.AppId",
	"application_type":                    "Description.Component.properties.Application_Type",
	"connection_string":                   "Description.Component.properties.ConnectionString",
	"creation_date":                       "Description.Component.Properties.CreationDate",
	"disable_ip_masking":                  "Description.Component.properties.DisableIpMasking",
	"disable_local_auth":                  "Description.Component.properties.DisableLocalAuth",
	"etag":                                "Description.Component.etag",
	"flow_type":                           "Description.Component.properties.Flow_Type",
	"force_customer_storage_for_profiler": "Description.Component.properties.ForceCustomerStorageForProfiler",
	"id":                                  "Description.Component.id",
	"immediate_purge_data_on_30_days":     "Description.Component.properties.ImmediatePurgeDataOn30Days",
	"ingestion_mode":                      "Description.Component.properties.IngestionMode",
	"instrumentation_key":                 "Description.Component.properties.InstrumentationKey",
	"kind":                                "Description.Component.kind",
	"name":                                "Description.Component.name",
	"private_link_scoped_resources":       "Description.Component.Properties.PrivateLinkScopedResources",
	"provisioning_state":                  "Description.Component.properties.provisioningState",
	"public_network_access_for_ingestion": "Description.Component.properties.publicNetworkAccessForIngestion",
	"public_network_access_for_query":     "Description.Component.properties.publicNetworkAccessForQuery",
	"request_source":                      "Description.Component.properties.Request_Source",
	"resource_group":                      "Description.ResourceGroup",
	"retention_in_days":                   "Description.Component.properties.RetentionInDays",
	"sampling_percentage":                 "Description.Component.properties.SamplingPercentage",
	"subscription":                        "Description.Component.Properties.Subscription",
	"tags":                                "Description.Component.Tags",
	"tenant_id":                           "Description.Component.properties.TenantId",
	"title":                               "Description.Component.name",
	"type":                                "Description.Component.type",
	"workspace_resource_id":               "Description.Component.properties.WorkspaceResourceId",
}

func ListApplicationInsightsComponent(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApplicationInsightsComponent")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListApplicationInsightsComponent NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListApplicationInsightsComponent NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListApplicationInsightsComponent GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListApplicationInsightsComponent GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListApplicationInsightsComponent GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewApplicationInsightsComponentPaginator(essdk.BuildFilter(ctx, d.QueryContext, listApplicationInsightsComponentFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListApplicationInsightsComponent NewApplicationInsightsComponentPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListApplicationInsightsComponent paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getApplicationInsightsComponentFilters = map[string]string{
	"app_id":                              "Description.Component.properties.AppId",
	"application_type":                    "Description.Component.properties.Application_Type",
	"connection_string":                   "Description.Component.properties.ConnectionString",
	"creation_date":                       "Description.Component.Properties.CreationDate",
	"disable_ip_masking":                  "Description.Component.properties.DisableIpMasking",
	"disable_local_auth":                  "Description.Component.properties.DisableLocalAuth",
	"etag":                                "Description.Component.etag",
	"flow_type":                           "Description.Component.properties.Flow_Type",
	"force_customer_storage_for_profiler": "Description.Component.properties.ForceCustomerStorageForProfiler",
	"id":                                  "Description.Component.id",
	"immediate_purge_data_on_30_days":     "Description.Component.properties.ImmediatePurgeDataOn30Days",
	"ingestion_mode":                      "Description.Component.properties.IngestionMode",
	"instrumentation_key":                 "Description.Component.properties.InstrumentationKey",
	"kind":                                "Description.Component.kind",
	"name":                                "Description.Component.name",
	"private_link_scoped_resources":       "Description.Component.Properties.PrivateLinkScopedResources",
	"provisioning_state":                  "Description.Component.properties.provisioningState",
	"public_network_access_for_ingestion": "Description.Component.properties.publicNetworkAccessForIngestion",
	"public_network_access_for_query":     "Description.Component.properties.publicNetworkAccessForQuery",
	"request_source":                      "Description.Component.properties.Request_Source",
	"resource_group":                      "Description.ResourceGroup",
	"retention_in_days":                   "Description.Component.properties.RetentionInDays",
	"sampling_percentage":                 "Description.Component.properties.SamplingPercentage",
	"subscription":                        "Description.Component.Properties.Subscription",
	"tags":                                "Description.Component.Tags",
	"tenant_id":                           "Description.Component.properties.TenantId",
	"title":                               "Description.Component.name",
	"type":                                "Description.Component.type",
	"workspace_resource_id":               "Description.Component.properties.WorkspaceResourceId",
}

func GetApplicationInsightsComponent(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApplicationInsightsComponent")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewApplicationInsightsComponentPaginator(essdk.BuildFilter(ctx, d.QueryContext, getApplicationInsightsComponentFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ApplicationInsightsComponent =============================

// ==========================  START: LighthouseDefinition =============================

type LighthouseDefinition struct {
	ResourceID      string                                `json:"resource_id"`
	PlatformID      string                                `json:"platform_id"`
	Description     azure.LighthouseDefinitionDescription `json:"Description"`
	Metadata        azure.Metadata                        `json:"metadata"`
	DescribedBy     string                                `json:"described_by"`
	ResourceType    string                                `json:"resource_type"`
	IntegrationType string                                `json:"integration_type"`
	IntegrationID   string                                `json:"integration_id"`
}

type LighthouseDefinitionHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  LighthouseDefinition `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type LighthouseDefinitionHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []LighthouseDefinitionHit `json:"hits"`
}

type LighthouseDefinitionSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  LighthouseDefinitionHits `json:"hits"`
}

type LighthouseDefinitionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLighthouseDefinitionPaginator(filters []essdk.BoolFilter, limit *int64) (LighthouseDefinitionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_lighthouse_definition", filters, limit)
	if err != nil {
		return LighthouseDefinitionPaginator{}, err
	}

	p := LighthouseDefinitionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LighthouseDefinitionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LighthouseDefinitionPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LighthouseDefinitionPaginator) NextPage(ctx context.Context) ([]LighthouseDefinition, error) {
	var response LighthouseDefinitionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LighthouseDefinition
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLighthouseDefinitionFilters = map[string]string{
	"authorizations":               "Description.LighthouseDefinition.Properties.Authorizations",
	"description":                  "Description.LighthouseDefinition.properties.description",
	"eligible_authorizations":      "Description.LighthouseDefinition.Properties.EligibleAuthorizations",
	"id":                           "Description.LighthouseDefinition.id",
	"managed_by_tenant_id":         "Description.LighthouseDefinition.properties.managedByTenantId",
	"managed_by_tenant_name":       "Description.LighthouseDefinition.properties.managedByTenantName",
	"managed_tenant_name":          "Description.LighthouseDefinition.properties.manageeTenantName",
	"name":                         "Description.LighthouseDefinition.name",
	"registration_definition_name": "Description.LighthouseDefinition.properties.registrationDefinitionName",
	"resource_group":               "Description.ResourceGroup",
	"scope":                        "Description.Scope",
	"subscription":                 "Description.LighthouseDefinition.Properties.Subscription",
	"title":                        "Description.LighthouseDefinition.name",
	"type":                         "Description.LighthouseDefinition.type",
}

func ListLighthouseDefinition(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLighthouseDefinition")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLighthouseDefinition NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLighthouseDefinition NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLighthouseDefinition GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLighthouseDefinition GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLighthouseDefinition GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLighthouseDefinitionPaginator(essdk.BuildFilter(ctx, d.QueryContext, listLighthouseDefinitionFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLighthouseDefinition NewLighthouseDefinitionPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLighthouseDefinition paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLighthouseDefinitionFilters = map[string]string{
	"authorizations":               "Description.LighthouseDefinition.Properties.Authorizations",
	"description":                  "Description.LighthouseDefinition.properties.description",
	"eligible_authorizations":      "Description.LighthouseDefinition.Properties.EligibleAuthorizations",
	"id":                           "Description.LighthouseDefinition.id",
	"managed_by_tenant_id":         "Description.LighthouseDefinition.properties.managedByTenantId",
	"managed_by_tenant_name":       "Description.LighthouseDefinition.properties.managedByTenantName",
	"managed_tenant_name":          "Description.LighthouseDefinition.properties.manageeTenantName",
	"name":                         "Description.LighthouseDefinition.name",
	"registration_definition_name": "Description.LighthouseDefinition.properties.registrationDefinitionName",
	"resource_group":               "Description.ResourceGroup",
	"scope":                        "Description.Scope",
	"subscription":                 "Description.LighthouseDefinition.Properties.Subscription",
	"title":                        "Description.LighthouseDefinition.name",
	"type":                         "Description.LighthouseDefinition.type",
}

func GetLighthouseDefinition(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLighthouseDefinition")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLighthouseDefinitionPaginator(essdk.BuildFilter(ctx, d.QueryContext, getLighthouseDefinitionFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: LighthouseDefinition =============================

// ==========================  START: LighthouseAssignment =============================

type LighthouseAssignment struct {
	ResourceID      string                                `json:"resource_id"`
	PlatformID      string                                `json:"platform_id"`
	Description     azure.LighthouseAssignmentDescription `json:"Description"`
	Metadata        azure.Metadata                        `json:"metadata"`
	DescribedBy     string                                `json:"described_by"`
	ResourceType    string                                `json:"resource_type"`
	IntegrationType string                                `json:"integration_type"`
	IntegrationID   string                                `json:"integration_id"`
}

type LighthouseAssignmentHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  LighthouseAssignment `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type LighthouseAssignmentHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []LighthouseAssignmentHit `json:"hits"`
}

type LighthouseAssignmentSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  LighthouseAssignmentHits `json:"hits"`
}

type LighthouseAssignmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLighthouseAssignmentPaginator(filters []essdk.BoolFilter, limit *int64) (LighthouseAssignmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_lighthouse_assignment", filters, limit)
	if err != nil {
		return LighthouseAssignmentPaginator{}, err
	}

	p := LighthouseAssignmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LighthouseAssignmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LighthouseAssignmentPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LighthouseAssignmentPaginator) NextPage(ctx context.Context) ([]LighthouseAssignment, error) {
	var response LighthouseAssignmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LighthouseAssignment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLighthouseAssignmentFilters = map[string]string{
	"id":                         "Description.LighthouseAssignment.id",
	"name":                       "Description.LighthouseAssignment.name",
	"provisioning_state":         "Description.LighthouseAssignment.properties.provisioningState",
	"registration_definition_id": "Description.LighthouseAssignment.properties.registrationDefinitionId",
	"resource_group":             "Description.ResourceGroup",
	"scope":                      "Description.Scope",
	"subscription":               "Description.LighthouseAssignment.Properties.Subscription",
	"title":                      "Description.LighthouseAssignment.name",
	"type":                       "Description.LighthouseAssignment.type",
}

func ListLighthouseAssignment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLighthouseAssignment")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLighthouseAssignment NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLighthouseAssignment NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLighthouseAssignment GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLighthouseAssignment GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLighthouseAssignment GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLighthouseAssignmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, listLighthouseAssignmentFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLighthouseAssignment NewLighthouseAssignmentPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLighthouseAssignment paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLighthouseAssignmentFilters = map[string]string{
	"id":                         "Description.LighthouseAssignment.id",
	"name":                       "Description.LighthouseAssignment.name",
	"provisioning_state":         "Description.LighthouseAssignment.properties.provisioningState",
	"registration_definition_id": "Description.LighthouseAssignment.properties.registrationDefinitionId",
	"resource_group":             "Description.ResourceGroup",
	"scope":                      "Description.Scope",
	"subscription":               "Description.LighthouseAssignment.Properties.Subscription",
	"title":                      "Description.LighthouseAssignment.name",
	"type":                       "Description.LighthouseAssignment.type",
}

func GetLighthouseAssignment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLighthouseAssignment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLighthouseAssignmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, getLighthouseAssignmentFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: LighthouseAssignment =============================

// ==========================  START: MaintenanceConfiguration =============================

type MaintenanceConfiguration struct {
	ResourceID      string                                    `json:"resource_id"`
	PlatformID      string                                    `json:"platform_id"`
	Description     azure.MaintenanceConfigurationDescription `json:"Description"`
	Metadata        azure.Metadata                            `json:"metadata"`
	DescribedBy     string                                    `json:"described_by"`
	ResourceType    string                                    `json:"resource_type"`
	IntegrationType string                                    `json:"integration_type"`
	IntegrationID   string                                    `json:"integration_id"`
}

type MaintenanceConfigurationHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  MaintenanceConfiguration `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type MaintenanceConfigurationHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []MaintenanceConfigurationHit `json:"hits"`
}

type MaintenanceConfigurationSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  MaintenanceConfigurationHits `json:"hits"`
}

type MaintenanceConfigurationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMaintenanceConfigurationPaginator(filters []essdk.BoolFilter, limit *int64) (MaintenanceConfigurationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_maintenance_maintenanceconfigurations", filters, limit)
	if err != nil {
		return MaintenanceConfigurationPaginator{}, err
	}

	p := MaintenanceConfigurationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MaintenanceConfigurationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MaintenanceConfigurationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p MaintenanceConfigurationPaginator) NextPage(ctx context.Context) ([]MaintenanceConfiguration, error) {
	var response MaintenanceConfigurationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MaintenanceConfiguration
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMaintenanceConfigurationFilters = map[string]string{
	"created_by":            "Description.MaintenanceConfiguration.systemData.createdBy",
	"created_by_type":       "Description.MaintenanceConfiguration.systemData.createdByType",
	"extension_properties":  "CDescription.MaintenanceConfiguration.Properties.ExtensionProperties",
	"id":                    "Description.MaintenanceConfiguration.id",
	"last_modified_by":      "Description.MaintenanceConfiguration.systemData.lastModifiedBy",
	"last_modified_by_type": "Description.MaintenanceConfiguration.systemData.lastModifiedByType",
	"maintenance_scope":     "Description.MaintenanceConfiguration.properties.maintenanceScope",
	"name":                  "Description.MaintenanceConfiguration.name",
	"namespace":             "Description.MaintenanceConfiguration.properties.namespace",
	"resource_group":        "Description.ResourceGroup",
	"subscription":          "Description.MaintenanceConfiguration.Properties.Subscription",
	"system_data":           "Description.MaintenanceConfiguration.SystemData",
	"tags":                  "Description.MaintenanceConfiguration.Tags",
	"title":                 "Description.MaintenanceConfiguration.name",
	"type":                  "Description.MaintenanceConfiguration.type",
	"visibility":            "Description.MaintenanceConfiguration.properties.visibility",
	"window":                "Description.MaintenanceConfiguration.Properties.Window",
}

func ListMaintenanceConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMaintenanceConfiguration")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListMaintenanceConfiguration NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListMaintenanceConfiguration NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListMaintenanceConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListMaintenanceConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListMaintenanceConfiguration GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewMaintenanceConfigurationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listMaintenanceConfigurationFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListMaintenanceConfiguration NewMaintenanceConfigurationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListMaintenanceConfiguration paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getMaintenanceConfigurationFilters = map[string]string{
	"created_by":            "Description.MaintenanceConfiguration.systemData.createdBy",
	"created_by_type":       "Description.MaintenanceConfiguration.systemData.createdByType",
	"extension_properties":  "CDescription.MaintenanceConfiguration.Properties.ExtensionProperties",
	"id":                    "Description.MaintenanceConfiguration.id",
	"last_modified_by":      "Description.MaintenanceConfiguration.systemData.lastModifiedBy",
	"last_modified_by_type": "Description.MaintenanceConfiguration.systemData.lastModifiedByType",
	"maintenance_scope":     "Description.MaintenanceConfiguration.properties.maintenanceScope",
	"name":                  "Description.MaintenanceConfiguration.name",
	"namespace":             "Description.MaintenanceConfiguration.properties.namespace",
	"resource_group":        "Description.ResourceGroup",
	"subscription":          "Description.MaintenanceConfiguration.Properties.Subscription",
	"system_data":           "Description.MaintenanceConfiguration.SystemData",
	"tags":                  "Description.MaintenanceConfiguration.Tags",
	"title":                 "Description.MaintenanceConfiguration.name",
	"type":                  "Description.MaintenanceConfiguration.type",
	"visibility":            "Description.MaintenanceConfiguration.properties.visibility",
	"window":                "Description.MaintenanceConfiguration.Properties.Window",
}

func GetMaintenanceConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMaintenanceConfiguration")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewMaintenanceConfigurationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getMaintenanceConfigurationFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: MaintenanceConfiguration =============================

// ==========================  START: MonitorLogProfile =============================

type MonitorLogProfile struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     azure.MonitorLogProfileDescription `json:"Description"`
	Metadata        azure.Metadata                     `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type MonitorLogProfileHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  MonitorLogProfile `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type MonitorLogProfileHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []MonitorLogProfileHit `json:"hits"`
}

type MonitorLogProfileSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  MonitorLogProfileHits `json:"hits"`
}

type MonitorLogProfilePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMonitorLogProfilePaginator(filters []essdk.BoolFilter, limit *int64) (MonitorLogProfilePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_monitor_logprofiles", filters, limit)
	if err != nil {
		return MonitorLogProfilePaginator{}, err
	}

	p := MonitorLogProfilePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MonitorLogProfilePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MonitorLogProfilePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p MonitorLogProfilePaginator) NextPage(ctx context.Context) ([]MonitorLogProfile, error) {
	var response MonitorLogProfileSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MonitorLogProfile
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMonitorLogProfileFilters = map[string]string{
	"categories":          "Description.LogProfile.Properties.Categories",
	"id":                  "Description.LogProfile.id",
	"location":            "Description.LogProfile.location",
	"locations":           "Description.LogProfile.Properties.Locations",
	"name":                "Description.LogProfile.name",
	"retention_policy":    "Description.LogProfile.Properties.RetentionPolicy",
	"service_bus_rule_id": "Description.LogProfile.properties.serviceBusRuleId",
	"storage_account_id":  "Description.LogProfile.properties.storageAccountId",
	"subscription":        "Description.LogProfile.Properties.Subscription",
	"tags":                "Description.LogProfile.Tags",
	"title":               "Description.LogProfile.name",
	"type":                "Description.LogProfile.type",
}

func ListMonitorLogProfile(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMonitorLogProfile")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListMonitorLogProfile NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListMonitorLogProfile NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListMonitorLogProfile GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListMonitorLogProfile GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListMonitorLogProfile GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewMonitorLogProfilePaginator(essdk.BuildFilter(ctx, d.QueryContext, listMonitorLogProfileFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListMonitorLogProfile NewMonitorLogProfilePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListMonitorLogProfile paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getMonitorLogProfileFilters = map[string]string{
	"categories":          "Description.LogProfile.Properties.Categories",
	"id":                  "Description.LogProfile.id",
	"location":            "Description.LogProfile.location",
	"locations":           "Description.LogProfile.Properties.Locations",
	"name":                "Description.LogProfile.name",
	"retention_policy":    "Description.LogProfile.Properties.RetentionPolicy",
	"service_bus_rule_id": "Description.LogProfile.properties.serviceBusRuleId",
	"storage_account_id":  "Description.LogProfile.properties.storageAccountId",
	"subscription":        "Description.LogProfile.Properties.Subscription",
	"tags":                "Description.LogProfile.Tags",
	"title":               "Description.LogProfile.name",
	"type":                "Description.LogProfile.type",
}

func GetMonitorLogProfile(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMonitorLogProfile")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewMonitorLogProfilePaginator(essdk.BuildFilter(ctx, d.QueryContext, getMonitorLogProfileFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: MonitorLogProfile =============================
